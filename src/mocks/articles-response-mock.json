[
  {
    "_id": "68aa34a7f63b8048002544d4",
    "title": "Pictorial diagram of Angular architecture",
    "content": "Слово \"pictorial\" <b>означает</b> живописный, изобразительный, наглядный или иллюстрированный.",
    "group": "Angular",
    "imageUrls": "https://github.com/sudheerj/angular-interview-questions/raw/master/images/architecture.png",
    "_created": "2025-08-23T21:37:43.417Z",
    "_changed": "2025-09-01T18:26:35.127Z",
    "_createdby": "api",
    "_changedby": "osokinkostyan12@gmail.com",
    "_keywords": [
      "api",
      "osokinkostyan12",
      "gmail",
      "com",
      "pictorial",
      "diagram",
      "of",
      "angular",
      "architecture",
      "слово",
      "\"pictorial\"",
      "означает",
      "живописный",
      "изобразительный",
      "наглядный",
      "или",
      "иллюстрированный",
      "https://github",
      "png",
      "basic"
    ],
    "_tags": "api osokinkostyan12 gmail com pictorial diagram of angular architecture слово \"pictorial\" означает живописный изобразительный наглядный или иллюстрированный https://github png basic",
    "_version": 25,
    "subGroup": "Angular basic",
    "editing": false,
    "order": 2
  },
  {
    "_id": "68b89c7cf63b8048002664db",
    "title": "Test",
    "content": "Test",
    "group": "ToDo",
    "subGroup": "empty",
    "ignoreHtml": false,
    "order": 1,
    "imageUrls": "",
    "_created": "2025-09-03T19:52:28.412Z",
    "_changed": "2025-09-03T19:52:28.412Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "test",
      "todo",
      "empty"
    ],
    "_tags": "api test todo empty",
    "_version": 0
  },
  {
    "_id": "68c4573df63b80480027523b",
    "title": "AAAAAff2",
    "content": "AAAAff1",
    "group": "Группа1",
    "subGroup": "sdfsdfsdf",
    "ignoreHtml": false,
    "order": 8,
    "imageUrls": "",
    "_created": "2025-09-12T17:24:13.378Z",
    "_changed": "2025-09-19T10:30:18.010Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "aaaaaff2",
      "aaaaff1",
      "группа1",
      "sdfsdfsdf"
    ],
    "_tags": "api aaaaaff2 aaaaff1 группа1 sdfsdfsdf",
    "_version": 3
  },
  {
    "_id": "68c972acf63b80480027b7d7",
    "title": "115",
    "content": "222",
    "group": "Группа1",
    "subGroup": "qweqweqweqwe",
    "ignoreHtml": false,
    "order": 2,
    "_created": "2025-09-16T14:22:36.475Z",
    "_changed": "2025-09-18T19:22:48.373Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "115",
      "222",
      "группа1",
      "qweqweqweqwe"
    ],
    "_tags": "api 115 222 группа1 qweqweqweqwe",
    "_version": 6
  },
  {
    "_id": "68a8dc8df63b804800252d14",
    "title": "What is the difference between AngularJS and Angular?",
    "content": "AngularJS (version 1.x) is a JavaScript framework, whereas Angular (version 2+) is a complete rewrite of AngularJS using TypeScript, providing better performance, mobile support, modularity, and a more modern architecture.\nAngularJS\t                Angular\nIt is based on MVC architecture\t                This is based on Service/Controller\nIt uses JavaScript to build the application\tUses TypeScript to build the application\nBased on controllers concept\t                This is a component based UI approach\nNo support for mobile platforms\t                Fully supports mobile platforms\nDifficult to build SEO friendly application\tEase to build SEO friendly applications\n",
    "group": "Angular",
    "imageUrls": "",
    "_created": "2025-08-22T21:09:33.023Z",
    "_changed": "2025-09-01T20:30:12.787Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "what",
      "is",
      "the",
      "difference",
      "between",
      "angularjs",
      "and",
      "angular?",
      "(version",
      "x)",
      "javascript",
      "framework",
      "whereas",
      "angular",
      "2+)",
      "complete",
      "rewrite",
      "of",
      "using",
      "typescript",
      "providing",
      "better",
      "performance",
      "mobile",
      "support",
      "modularity",
      "more",
      "modern",
      "architecture",
      "angularjs\t",
      "it",
      "based",
      "on",
      "mvc",
      "architecture\t",
      "this",
      "service/controller",
      "uses",
      "to",
      "build",
      "application\tuses",
      "application",
      "controllers",
      "concept\t",
      "component",
      "ui",
      "approach",
      "no",
      "for",
      "platforms\t",
      "fully",
      "supports",
      "platforms",
      "difficult",
      "seo",
      "friendly",
      "application\tease",
      "applications",
      "basic"
    ],
    "_tags": "api what is the difference between angularjs and angular? (version x) javascript framework whereas angular 2+) complete rewrite of using typescript providing better performance mobile support modularity more modern architecture angularjs\t it based on mvc architecture\t this service/controller uses to build application\tuses application controllers concept\t component ui approach no for platforms\t fully supports platforms difficult seo friendly application\tease applications basic",
    "_version": 12,
    "subGroup": "Angular basic",
    "order": 9
  },
  {
    "_id": "68b4b0abf63b8048002619cd",
    "title": "ssdffsd78888",
    "content": "sdfsdfsd00000",
    "group": "Группа1",
    "imageUrls": [],
    "subGroup": "sdfsdfsdf",
    "order": 8,
    "_created": "2025-08-31T20:29:31.456Z",
    "_changed": "2025-09-18T19:55:03.303Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "ssdffsd78888",
      "sdfsdfsd00000",
      "группа1",
      "sdfsdfsdf"
    ],
    "_tags": "api ssdffsd78888 sdfsdfsd00000 группа1 sdfsdfsdf",
    "_version": 8,
    "ignoreHtml": false
  },
  {
    "_id": "68b0cab0f63b80480025caa7",
    "title": "What are Components",
    "group": "Angular",
    "imageUrls": "https://ik.imagekit.io/ygtb3rzhz/What%20are%20components?updatedAt=1756417400437",
    "subGroup": "Angular basic",
    "order": 7,
    "content": "",
    "_created": "2025-08-28T21:31:28.474Z",
    "_changed": "2025-09-01T20:30:14.784Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "what",
      "are",
      "components",
      "angular",
      "https://ik",
      "imagekit",
      "basic"
    ],
    "_tags": "api what are components angular https://ik imagekit basic",
    "_version": 14,
    "editing": false
  },
  {
    "_id": "68acbed2f63b80480025797a",
    "title": "Directives",
    "group": "Angular",
    "imageUrls": "https://ik.imagekit.io/ygtb3rzhz/Directives.png?updatedAt=1756152381160",
    "content": "",
    "_created": "2025-08-25T19:51:46.500Z",
    "_changed": "2025-09-01T20:30:13.782Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "directives",
      "angular",
      "https://ik",
      "imagekit",
      "io/ygtb3rzhz/directives",
      "png?updatedat=1756152381160",
      "basic"
    ],
    "_tags": "api directives angular https://ik imagekit io/ygtb3rzhz/directives png?updatedat=1756152381160 basic",
    "_version": 22,
    "editing": false,
    "subGroup": "Angular basic",
    "order": 8
  },
  {
    "_id": "68aa3440f63b8048002544ce",
    "title": "What is TypeScript?",
    "content": "TypeScript is a strongly typed superset of JavaScript created by Microsoft that adds optional types, classes, async/await and many other features, and compiles to plain JavaScript. Angular is written entirely in TypeScript as a primary language. You can install TypeScript globally as\nnpm install -g typescript",
    "group": "Angular",
    "imageUrls": "",
    "_created": "2025-08-23T21:36:00.239Z",
    "_changed": "2025-08-31T20:49:21.002Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "what",
      "is",
      "typescript?",
      "typescript",
      "strongly",
      "typed",
      "superset",
      "of",
      "javascript",
      "created",
      "by",
      "microsoft",
      "that",
      "adds",
      "optional",
      "types",
      "classes",
      "async/await",
      "and",
      "many",
      "other",
      "features",
      "compiles",
      "to",
      "plain",
      "angular",
      "written",
      "entirely",
      "in",
      "as",
      "primary",
      "language",
      "you",
      "can",
      "install",
      "globally",
      "npm",
      "-g",
      "basic"
    ],
    "_tags": "api what is typescript? typescript strongly typed superset of javascript created by microsoft that adds optional types classes async/await and many other features compiles to plain angular written entirely in as primary language you can install globally npm -g basic",
    "_version": 17,
    "subGroup": "Angular basic",
    "order": 3
  },
  {
    "_id": "68b5ebc0f63b80480026303a",
    "title": "Asdasd2",
    "content": "asdadaasdasdasd2 <b>asdasdasdasdasdasdasd</b> asdasdasdasdasd",
    "group": "Группа1",
    "subGroup": "sdfsdfsdf",
    "order": 8,
    "imageUrls": "",
    "_created": "2025-09-01T18:53:52.245Z",
    "_changed": "2025-09-18T19:31:22.042Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "asdasd2",
      "asdadaasdasdasd2",
      "asdasdasdasdasdasdasd",
      "asdasdasdasdasd",
      "группа1",
      "sdfsdfsdf"
    ],
    "_tags": "api asdasd2 asdadaasdasdasd2 asdasdasdasdasdasdasd asdasdasdasdasd группа1 sdfsdfsdf",
    "_version": 2,
    "ignoreHtml": false
  },
  {
    "_id": "68a8dc23f63b804800252d0b",
    "title": "What is Angular Framework?",
    "content": "Angular is a TypeScript-based open-source front-end platform that makes it easy to build web, mobile and desktop applications. The major features of this framework include declarative templates, dependency injection, end to end tooling which ease application development.",
    "group": "Angular",
    "imageUrls": "",
    "_created": "2025-08-22T21:07:47.505Z",
    "_changed": "2025-09-04T18:02:13.257Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "what",
      "is",
      "angular",
      "framework?",
      "typescript-based",
      "open-source",
      "front-end",
      "platform",
      "that",
      "makes",
      "it",
      "easy",
      "to",
      "build",
      "web",
      "mobile",
      "and",
      "desktop",
      "applications",
      "the",
      "major",
      "features",
      "of",
      "this",
      "framework",
      "include",
      "declarative",
      "templates",
      "dependency",
      "injection",
      "end",
      "tooling",
      "which",
      "ease",
      "application",
      "development",
      "basic"
    ],
    "_tags": "api what is angular framework? typescript-based open-source front-end platform that makes it easy to build web mobile and desktop applications the major features of this framework include declarative templates dependency injection end tooling which ease application development basic",
    "_version": 12,
    "subGroup": "Angular basic",
    "order": 1,
    "done": false
  },
  {
    "_id": "68b0bee7f63b80480025c9dc",
    "title": "Drag and drop",
    "content": "https://angular.dev/guide/drag-drop\nThis page describes the drag and drop directives which lets you quickly create drag and drop interfaces with the following:\nFree dragging\nCreate a list of reorderable draggable elements\nTransfer draggable elements between lists\nDragging animations\nLock draggable elements along an axis or element\nAdd custom drag handles\nAdd previews on drag\nAdd custom drag placeholder\n",
    "group": "Angular",
    "imageUrls": [
      "https://ik.imagekit.io/ygtb3rzhz/cdk%20drag%20and%20drop?updatedAt=1756414395100"
    ],
    "subGroup": "Angular CDK",
    "order": 3,
    "_created": "2025-08-28T20:41:11.298Z",
    "_changed": "2025-08-29T17:19:00.752Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "drag",
      "and",
      "drop",
      "https://angular",
      "dev/guide/drag-drop",
      "this",
      "page",
      "describes",
      "the",
      "directives",
      "which",
      "lets",
      "you",
      "quickly",
      "create",
      "interfaces",
      "with",
      "following:",
      "free",
      "dragging",
      "list",
      "of",
      "reorderable",
      "draggable",
      "elements",
      "transfer",
      "between",
      "lists",
      "animations",
      "lock",
      "along",
      "an",
      "axis",
      "or",
      "element",
      "add",
      "custom",
      "handles",
      "previews",
      "on",
      "placeholder",
      "angular",
      "https://ik",
      "imagekit",
      "cdk"
    ],
    "_tags": "api drag and drop https://angular dev/guide/drag-drop this page describes the directives which lets you quickly create interfaces with following: free dragging list of reorderable draggable elements transfer between lists animations lock along an axis or element add custom handles previews on placeholder angular https://ik imagekit cdk",
    "_version": 3
  },
  {
    "_id": "68b0cb53f63b80480025cab4",
    "title": "What are Modules",
    "content": "Modules are logical boundaries in your application and the application is divided into separate modules to separate the functionality of your application.\nThe NgModule decorator has five important (among all) options:\nThe imports option is used to import other dependent modules. The BrowserModule is required by default for any web based angular application.\nThe declarations option is used to define components in the respective module.\nThe bootstrap option tells Angular which Component to bootstrap in the application.\nThe providers option is used to configure a set of injectable objects that are available in the injector of this module.\nThe entryComponents option is a set of components dynamically loaded into the view.\n\n Lets take an example of app.module.ts root module declared with @NgModule decorator as below,",
    "group": "Angular",
    "imageUrls": "https://ik.imagekit.io/ygtb3rzhz/modules?updatedAt=1756417573404",
    "subGroup": "Angular basic",
    "order": 6,
    "_created": "2025-08-28T21:34:11.312Z",
    "_changed": "2025-09-01T20:30:15.800Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "what",
      "are",
      "modules",
      "logical",
      "boundaries",
      "in",
      "your",
      "application",
      "and",
      "the",
      "is",
      "divided",
      "into",
      "separate",
      "to",
      "functionality",
      "of",
      "ngmodule",
      "decorator",
      "has",
      "five",
      "important",
      "(among",
      "all)",
      "options:",
      "imports",
      "option",
      "used",
      "import",
      "other",
      "dependent",
      "browsermodule",
      "required",
      "by",
      "default",
      "for",
      "any",
      "web",
      "based",
      "angular",
      "declarations",
      "define",
      "components",
      "respective",
      "module",
      "bootstrap",
      "tells",
      "which",
      "component",
      "providers",
      "configure",
      "set",
      "injectable",
      "objects",
      "that",
      "available",
      "injector",
      "this",
      "entrycomponents",
      "dynamically",
      "loaded",
      "view",
      "lets",
      "take",
      "an",
      "example",
      "app",
      "ts",
      "root",
      "declared",
      "with",
      "as",
      "below",
      "https://ik",
      "imagekit",
      "io/ygtb3rzhz/modules?updatedat=1756417573404",
      "basic"
    ],
    "_tags": "api what are modules logical boundaries in your application and the is divided into separate to functionality of ngmodule decorator has five important (among all) options: imports option used import other dependent browsermodule required by default for any web based angular declarations define components respective module bootstrap tells which component providers configure set injectable objects that available injector this entrycomponents dynamically loaded view lets take an example app ts root declared with as below https://ik imagekit io/ygtb3rzhz/modules?updatedat=1756417573404 basic",
    "_version": 17
  },
  {
    "_id": "68b60183f63b8048002631b5",
    "title": "Data binding",
    "group": "Angular",
    "imageUrls": "https://ik.imagekit.io/ygtb3rzhz/ddtabinding.png?updatedAt=1756759121953",
    "subGroup": "Angular basic",
    "order": 11,
    "content": "",
    "_created": "2025-09-01T20:26:43.535Z",
    "_changed": "2025-09-01T20:29:57.757Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "data",
      "binding",
      "angular",
      "https://ik",
      "imagekit",
      "io/ygtb3rzhz/ddtabinding",
      "png?updatedat=1756759121953",
      "basic",
      "11"
    ],
    "_tags": "api data binding angular https://ik imagekit io/ygtb3rzhz/ddtabinding png?updatedat=1756759121953 basic 11",
    "_version": 1
  },
  {
    "_id": "68b5f486f63b8048002630d4",
    "title": "serwer",
    "content": "dsxfvsdfsdfsdfsdfsdfsdf <p><img src=\"https://github.com/sudheerj/angular-interview-questions/raw/master/images/architecture.png\" alt=\"Вставленное изображение\" style=\"max-width: 100%;\"></p> dsfsdfsdfsdfsdfsdfsdfsdf",
    "group": "Группа1",
    "subGroup": "sdfsdfsdf",
    "order": 3,
    "imageUrls": "",
    "_created": "2025-09-01T19:31:18.178Z",
    "_changed": "2025-09-03T20:04:40.714Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "serwer",
      "dsxfvsdfsdfsdfsdfsdfsdf",
      "dsfsdfsdfsdfsdfsdfsdfsdf",
      "группа1",
      "sdfsdfsdf"
    ],
    "_tags": "api serwer dsxfvsdfsdfsdfsdfsdfsdf dsfsdfsdfsdfsdfsdfsdfsdf группа1 sdfsdfsdf",
    "_version": 3
  },
  {
    "_id": "68ab80adf63b80480025619b",
    "title": "What are the key components of Angular?",
    "content": "Component: These are the basic building blocks of an Angular application to control HTML views.\n\nModules: An Angular module is a set of angular basic building blocks like components, directives, services etc. An application is divided into logical pieces and each piece of code is called as \"module\" which perform a single task.\n\nTemplates: These represent the views of an Angular application.\n\nServices: Are used to create components which can be shared across the entire application.\n\nMetadata: This can be used to add more data to an Angular class.",
    "group": "Angular",
    "imageUrls": "",
    "_created": "2025-08-24T21:14:21.799Z",
    "_changed": "2025-09-01T20:30:03.761Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "what",
      "are",
      "the",
      "key",
      "components",
      "of",
      "angular?",
      "component:",
      "these",
      "basic",
      "building",
      "blocks",
      "an",
      "angular",
      "application",
      "to",
      "control",
      "html",
      "views",
      "modules:",
      "module",
      "is",
      "set",
      "like",
      "directives",
      "services",
      "etc",
      "divided",
      "into",
      "logical",
      "pieces",
      "and",
      "each",
      "piece",
      "code",
      "called",
      "as",
      "\"module\"",
      "which",
      "perform",
      "single",
      "task",
      "templates:",
      "represent",
      "services:",
      "used",
      "create",
      "can",
      "be",
      "shared",
      "across",
      "entire",
      "metadata:",
      "this",
      "add",
      "more",
      "data",
      "class",
      "10"
    ],
    "_tags": "api what are the key components of angular? component: these basic building blocks an angular application to control html views modules: module is set like directives services etc divided into logical pieces and each piece code called as \"module\" which perform single task templates: represent services: used create can be shared across entire metadata: this add more data class 10",
    "_version": 20,
    "editing": false,
    "subGroup": "Angular basic",
    "order": 10
  },
  {
    "_id": "68b89fe1f63b80480026651d",
    "title": "Перетаскивание",
    "content": "Сделать нормальное перетаскивание статей (не через одну как сейчас), возможно ограничить число запросов требующих для перетаскивания и выдавать ошибку если их слишком много \nПодумать над сортировкой групп и подгрупп...",
    "group": "ToDo",
    "subGroup": "empty",
    "ignoreHtml": false,
    "order": 7,
    "imageUrls": "",
    "_created": "2025-09-03T20:06:57.443Z",
    "_changed": "2025-09-03T20:06:57.443Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "перетаскивание",
      "сделать",
      "нормальное",
      "статей",
      "(не",
      "через",
      "одну",
      "как",
      "сейчас)",
      "возможно",
      "ограничить",
      "число",
      "запросов",
      "требующих",
      "для",
      "перетаскивания",
      "выдавать",
      "ошибку",
      "если",
      "их",
      "слишком",
      "много",
      "подумать",
      "над",
      "сортировкой",
      "групп",
      "подгрупп",
      "todo",
      "empty"
    ],
    "_tags": "api перетаскивание сделать нормальное статей (не через одну как сейчас) возможно ограничить число запросов требующих для перетаскивания выдавать ошибку если их слишком много подумать над сортировкой групп подгрупп todo empty",
    "_version": 0
  },
  {
    "_id": "68b89eb7f63b804800266506",
    "title": "Скрытие формы",
    "content": "Сделать скрытие формы",
    "group": "ToDo",
    "subGroup": "empty",
    "ignoreHtml": false,
    "order": 6,
    "imageUrls": "",
    "_created": "2025-09-03T20:01:59.218Z",
    "_changed": "2025-09-04T17:44:05.723Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "скрытие",
      "формы",
      "сделать",
      "todo",
      "empty"
    ],
    "_tags": "api скрытие формы сделать todo empty",
    "_version": 1,
    "done": true
  },
  {
    "_id": "68c45753f63b80480027523c",
    "title": "b",
    "content": "b",
    "group": "Группа1",
    "subGroup": "sdfsdfsdf",
    "ignoreHtml": false,
    "order": 8,
    "imageUrls": "",
    "_created": "2025-09-12T17:24:35.404Z",
    "_changed": "2025-09-18T19:32:48.966Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "группа1",
      "sdfsdfsdf"
    ],
    "_tags": "api группа1 sdfsdfsdf",
    "_version": 1
  },
  {
    "_id": "68b89ea1f63b804800266505",
    "title": "Галочка у статей",
    "content": "Добавить булевое значение для статей в БД и checkbox в ЮАЕ для выделения прочитанных/непрочитанных статей и для TODo списка",
    "group": "ToDo",
    "subGroup": "empty",
    "ignoreHtml": false,
    "order": 5,
    "imageUrls": "",
    "_created": "2025-09-03T20:01:37.884Z",
    "_changed": "2025-09-04T17:29:45.995Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "галочка",
      "статей",
      "добавить",
      "булевое",
      "значение",
      "для",
      "бд",
      "checkbox",
      "юае",
      "выделения",
      "прочитанных/непрочитанных",
      "todo",
      "списка",
      "empty"
    ],
    "_tags": "api галочка статей добавить булевое значение для бд checkbox юае выделения прочитанных/непрочитанных todo списка empty",
    "_version": 5,
    "done": true
  },
  {
    "_id": "68b9e2a7f63b8048002680c0",
    "title": "Использовать форму добавления для редактирования",
    "content": "Использовать форму добавления для редактирования",
    "group": "ToDo",
    "subGroup": "empty",
    "ignoreHtml": false,
    "order": 9,
    "imageUrls": "",
    "_created": "2025-09-04T19:04:07.944Z",
    "_changed": "2025-09-26T19:49:33.095Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "использовать",
      "форму",
      "добавления",
      "для",
      "редактирования",
      "todo",
      "empty"
    ],
    "_tags": "api использовать форму добавления для редактирования todo empty",
    "_version": 1,
    "done": true
  },
  {
    "_id": "68c1c253f63b8048002721db",
    "title": "Переделать форму на реактивную",
    "content": "Переделать форму на реактивную",
    "group": "ToDo",
    "subGroup": "empty",
    "ignoreHtml": false,
    "order": 10,
    "imageUrls": "",
    "_created": "2025-09-10T18:24:19.893Z",
    "_changed": "2025-09-26T19:49:35.077Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "переделать",
      "форму",
      "на",
      "реактивную",
      "todo",
      "empty",
      "10"
    ],
    "_tags": "api переделать форму на реактивную todo empty 10",
    "_version": 1,
    "done": true
  },
  {
    "_id": "68c31365f63b804800273990",
    "title": "Селектор дочерних элементов >",
    "content": "Комбинатор > разделяет 2 селектора, находит элементы заданные вторым селектором, являющие прямыми потомками для элементов отобранных первым селектором. Напротив, два селектора в селекторе потомков находят элементы не обязательно являющиеся прямыми потомками, т.е. несмотря на количество \"прыжков\" до них в DOM.\nСинтаксис\nselector1 > selector2 { style properties }\n <p><img src=\"https://ik.imagekit.io/ygtb3rzhz/selctor.png?updatedAt=1757615709766\" alt=\"В\" style=\"max-width: 100%;\"></p> ",
    "group": "CSS",
    "subGroup": "CSS Basic",
    "ignoreHtml": false,
    "order": 2,
    "imageUrls": "",
    "_created": "2025-09-11T18:22:29.367Z",
    "_changed": "2025-09-12T18:00:01.955Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "селектор",
      "дочерних",
      "элементов",
      "комбинатор",
      "разделяет",
      "селектора",
      "находит",
      "элементы",
      "заданные",
      "вторым",
      "селектором",
      "являющие",
      "прямыми",
      "потомками",
      "для",
      "отобранных",
      "первым",
      "напротив",
      "два",
      "селекторе",
      "потомков",
      "находят",
      "не",
      "обязательно",
      "являющиеся",
      "несмотря",
      "на",
      "количество",
      "\"прыжков\"",
      "до",
      "них",
      "dom",
      "синтаксис",
      "selector1",
      "selector2",
      "style",
      "properties",
      "css",
      "basic"
    ],
    "_tags": "api селектор дочерних элементов комбинатор разделяет селектора находит элементы заданные вторым селектором являющие прямыми потомками для отобранных первым напротив два селекторе потомков находят не обязательно являющиеся несмотря на количество \"прыжков\" до них dom синтаксис selector1 selector2 style properties css basic",
    "_version": 1
  },
  {
    "_id": "68b9e50af63b8048002680ea",
    "title": "Инкапсуляция",
    "content": "Инкапсуляция - это одна из основных концепций ООП. Она означает сокрытие внутренней реализации объекта и предоставление контролируемого доступа к его данным и функциональности через определенный интерфейс. В контексте Angular это означает, что компоненты Angular могут контролировать, какие части их HTML-шаблона, стилей и логики видны и доступны для других компонентов.\n<b>Зачем нужна инкапсуляция?</b>\n• Предотвращение конфликтов: Инкапсуляция стилей предотвращает случайные конфликты между стилями разных компонентов. Без инкапсуляции стили одного компонента могут неожиданно повлиять на отображение другого компонента.\n• Улучшение модульности и повторного использования: Инкапсулированные компоненты легче повторно использовать, поскольку они не зависят от стилей и внутренней логики других частей приложения.\n• Упрощение рефакторинга: Инкапсуляция позволяет изменять внутреннюю реализацию компонента без риска сломать другие части приложения, поскольку внешний интерфейс остается стабильным.\n• Улучшение поддерживаемости: Инкапсуляция делает код более понятным и легким в поддержке, поскольку каждый компонент несет ответственность только за свою часть функциональности.\n",
    "group": "ООП",
    "subGroup": "Принципы ООП",
    "ignoreHtml": false,
    "order": 2,
    "imageUrls": "",
    "_created": "2025-09-04T19:14:18.215Z",
    "_changed": "2025-09-04T19:14:18.215Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "инкапсуляция",
      "это",
      "одна",
      "из",
      "основных",
      "концепций",
      "ооп",
      "она",
      "означает",
      "сокрытие",
      "внутренней",
      "реализации",
      "объекта",
      "предоставление",
      "контролируемого",
      "доступа",
      "его",
      "данным",
      "функциональности",
      "через",
      "определенный",
      "интерфейс",
      "контексте",
      "angular",
      "что",
      "компоненты",
      "могут",
      "контролировать",
      "какие",
      "части",
      "их",
      "html-шаблона",
      "стилей",
      "логики",
      "видны",
      "доступны",
      "для",
      "других",
      "компонентов",
      "зачем",
      "нужна",
      "инкапсуляция?",
      "предотвращение",
      "конфликтов:",
      "предотвращает",
      "случайные",
      "конфликты",
      "между",
      "стилями",
      "разных",
      "без",
      "инкапсуляции",
      "стили",
      "одного",
      "компонента",
      "неожиданно",
      "повлиять",
      "на",
      "отображение",
      "другого",
      "улучшение",
      "модульности",
      "повторного",
      "использования:",
      "инкапсулированные",
      "легче",
      "повторно",
      "использовать",
      "поскольку",
      "они",
      "не",
      "зависят",
      "от",
      "частей",
      "приложения",
      "упрощение",
      "рефакторинга:",
      "позволяет",
      "изменять",
      "внутреннюю",
      "реализацию",
      "риска",
      "сломать",
      "другие",
      "внешний",
      "остается",
      "стабильным",
      "поддерживаемости:",
      "делает",
      "код",
      "более",
      "понятным",
      "легким",
      "поддержке",
      "каждый",
      "компонент",
      "несет",
      "ответственность",
      "только",
      "за",
      "свою",
      "часть",
      "принципы"
    ],
    "_tags": "api инкапсуляция это одна из основных концепций ооп она означает сокрытие внутренней реализации объекта предоставление контролируемого доступа его данным функциональности через определенный интерфейс контексте angular что компоненты могут контролировать какие части их html-шаблона стилей логики видны доступны для других компонентов зачем нужна инкапсуляция? предотвращение конфликтов: предотвращает случайные конфликты между стилями разных без инкапсуляции стили одного компонента неожиданно повлиять на отображение другого улучшение модульности повторного использования: инкапсулированные легче повторно использовать поскольку они не зависят от частей приложения упрощение рефакторинга: позволяет изменять внутреннюю реализацию риска сломать другие внешний остается стабильным поддерживаемости: делает код более понятным легким поддержке каждый компонент несет ответственность только за свою часть принципы",
    "_version": 0
  },
  {
    "_id": "68b0ca2af63b80480025ca9d",
    "title": "CDK VS Materials",
    "content": "Angular CDK — это набор инструментов для разработки компонентов пользовательского интерфейса, предоставляющий примитивы и абстракции, а Angular Material — это библиотека, использующая CDK для создания компонентов в стиле Material Design. Таким образом, CDK служит основой для Material, а Material предоставляет готовые, стилизованные компоненты, построенные на этой основе. \nAngular CDK (Component Dev Kit) \nЧто это:\nНабор инструментов и примитивов для создания пользовательских компонентов.\nНазначение:\nПредоставляет гибкие строительные блоки и абстракции, которые позволяют разработчикам создавать собственные компоненты, отвечающие специфическим требованиям приложения.\nПримеры:\nМожет включать в себя такие возможности, как управление фокусом, обработка событий клавиатуры, инструменты для создания перетаскиваемых элементов и другие полезные функции для разработчиков.\nКак использовать:\nВы можете использовать только CDK для создания полностью кастомных компонентов без стилей Material Design или использовать его как основу для своих собственных библиотек.\nAngular Material\nЧто это:\nБиблиотека готовых компонентов, соответствующих дизайну Google Material Design. \nНазначение:\nПредоставляет разработчикам готовые к использованию, стилизованные компоненты (например, кнопки, таблицы, меню, вкладки), которые легко интегрируются в Angular-приложения. \nЗависимость от CDK:\nAngular Material построен поверх Angular CDK. То есть, компоненты Material (например, mat-table) используют функциональность CDK (например, базовую таблицу данных) и добавляют к ней свою стилизацию и компонентные селекторы (например, mat-). \nКак использовать:\nЕсли вам нужны готовые компоненты, соответствующие стандартам Material Design, вы импортируете и используете компоненты из библиотеки Angular Material. \nКлючевая разница\nCDK — это основа:\nПредоставляет \"строительные блоки\" (примитивы) и абстракции. \nMaterial — это готовый продукт:\nИспользует эти \"строительные блоки\" и добавляет к ним стилизацию Material Design, предлагая готовые к использованию компоненты. \n",
    "group": "Angular",
    "imageUrls": [],
    "subGroup": "Angular CDK",
    "order": 2,
    "_created": "2025-08-28T21:29:14.332Z",
    "_changed": "2025-08-29T17:18:59.748Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "cdk",
      "vs",
      "materials",
      "angular",
      "это",
      "набор",
      "инструментов",
      "для",
      "разработки",
      "компонентов",
      "пользовательского",
      "интерфейса",
      "предоставляющий",
      "примитивы",
      "абстракции",
      "material",
      "библиотека",
      "использующая",
      "создания",
      "стиле",
      "design",
      "таким",
      "образом",
      "служит",
      "основой",
      "предоставляет",
      "готовые",
      "стилизованные",
      "компоненты",
      "построенные",
      "на",
      "этой",
      "основе",
      "(component",
      "dev",
      "kit)",
      "что",
      "это:",
      "примитивов",
      "пользовательских",
      "назначение:",
      "гибкие",
      "строительные",
      "блоки",
      "которые",
      "позволяют",
      "разработчикам",
      "создавать",
      "собственные",
      "отвечающие",
      "специфическим",
      "требованиям",
      "приложения",
      "примеры:",
      "может",
      "включать",
      "себя",
      "такие",
      "возможности",
      "как",
      "управление",
      "фокусом",
      "обработка",
      "событий",
      "клавиатуры",
      "инструменты",
      "перетаскиваемых",
      "элементов",
      "другие",
      "полезные",
      "функции",
      "разработчиков",
      "использовать:",
      "вы",
      "можете",
      "использовать",
      "только",
      "полностью",
      "кастомных",
      "без",
      "стилей",
      "или",
      "его",
      "основу",
      "своих",
      "собственных",
      "библиотек",
      "готовых",
      "соответствующих",
      "дизайну",
      "google",
      "использованию",
      "(например",
      "кнопки",
      "таблицы",
      "меню",
      "вкладки)",
      "легко",
      "интегрируются",
      "angular-приложения",
      "зависимость",
      "от",
      "cdk:",
      "построен",
      "поверх",
      "то",
      "есть",
      "mat-table)",
      "используют",
      "функциональность",
      "базовую",
      "таблицу",
      "данных)",
      "добавляют",
      "ней",
      "свою",
      "стилизацию",
      "компонентные",
      "селекторы",
      "mat-)",
      "если",
      "вам",
      "нужны",
      "соответствующие",
      "стандартам",
      "импортируете",
      "используете",
      "из",
      "библиотеки",
      "ключевая",
      "разница",
      "основа:",
      "\"строительные",
      "блоки\"",
      "(примитивы)",
      "готовый",
      "продукт:",
      "использует",
      "эти",
      "добавляет",
      "ним",
      "предлагая"
    ],
    "_tags": "api cdk vs materials angular это набор инструментов для разработки компонентов пользовательского интерфейса предоставляющий примитивы абстракции material библиотека использующая создания стиле design таким образом служит основой предоставляет готовые стилизованные компоненты построенные на этой основе (component dev kit) что это: примитивов пользовательских назначение: гибкие строительные блоки которые позволяют разработчикам создавать собственные отвечающие специфическим требованиям приложения примеры: может включать себя такие возможности как управление фокусом обработка событий клавиатуры инструменты перетаскиваемых элементов другие полезные функции разработчиков использовать: вы можете использовать только полностью кастомных без стилей или его основу своих собственных библиотек готовых соответствующих дизайну google использованию (например кнопки таблицы меню вкладки) легко интегрируются angular-приложения зависимость от cdk: построен поверх то есть mat-table) используют функциональность базовую таблицу данных) добавляют ней свою стилизацию компонентные селекторы mat-) если вам нужны соответствующие стандартам импортируете используете из библиотеки ключевая разница основа: \"строительные блоки\" (примитивы) готовый продукт: использует эти добавляет ним предлагая",
    "_version": 4
  },
  {
    "_id": "68b0ca50f63b80480025ca9e",
    "title": "Что такое Angular CDK",
    "content": "Angular CDK (Component Dev Kit) — это библиотека базовых инструментов и утилит, которые предоставляют готовые к использованию \"примитивы\" для создания пользовательских компонентов в приложениях на Angular. Она предоставляет функциональность без стилизации, позволяя разработчикам создавать собственные уникальные компоненты, а не полагаться только на готовые решения, как в Angular Material. \nДля чего нужен Angular CDK?\nГибкость и кастомизация:\nCDK позволяет разработчикам создавать собственные, полностью настраиваемые компоненты, используя готовые шаблоны и абстракции, которые обеспечивают нужную функциональность. \nПовторно используемые шаблоны:\nБиблиотека предоставляет набор утилит и функций, которые часто используются при создании компонентов, такие как:\nПеретаскивание (Drag and Drop): Для реализации интерактивных элементов. \nВсплывающие окна и меню: Для управления скрывающимися элементами интерфейса. \nСпециальные возможности (Accessibility): Утилиты, которые помогают сделать компоненты доступными для пользователей с ограниченными возможностями. \nУправление фокусом: Функциональность для корректного управления фокусом в сложных интерфейсах. \nОтделение логики от стилизации:\nCDK не включает в себя стилизацию компонентов, как это делает Angular Material. Вместо этого, он предоставляет чистую функциональность, на которую затем накладываются необходимые стили. \nОснова для Angular Material:\nAngular Material, библиотека компонентов для создания интерфейсов в стиле Material Design, использует утилиты из Angular CDK, чтобы добавить к ним стилизацию. \nКак использовать Angular CDK?\n1. Установка:\nДобавляете пакет @angular/cdk в свой Angular-проект. \n2. Импорт модулей:\nВыбираете и импортируете в свой модуль Angular нужные модули из CDK, например, модуль для перетаскивания (DragDropModule) или модуль для управления окнами (OverlayModule). \n3. Реализация функциональности:\nИспользуете предоставленные директивы, сервисы и компоненты для добавления нужного поведения в ваш компонент. \n4. Стилизация:\nДобавляете собственные CSS-стили или используете готовые стили из другой библиотеки, чтобы придать компоненту желаемый внешний вид. \nТаким образом, Angular CDK является важным набором инструментов, который упрощает разработку сложных, настраиваемых пользовательских интерфейсов на платформе Angular. ",
    "group": "Angular",
    "imageUrls": [],
    "subGroup": "Angular CDK",
    "order": 1,
    "_created": "2025-08-28T21:29:52.827Z",
    "_changed": "2025-08-28T21:29:59.726Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "что",
      "такое",
      "angular",
      "cdk",
      "(component",
      "dev",
      "kit)",
      "это",
      "библиотека",
      "базовых",
      "инструментов",
      "утилит",
      "которые",
      "предоставляют",
      "готовые",
      "использованию",
      "\"примитивы\"",
      "для",
      "создания",
      "пользовательских",
      "компонентов",
      "приложениях",
      "на",
      "она",
      "предоставляет",
      "функциональность",
      "без",
      "стилизации",
      "позволяя",
      "разработчикам",
      "создавать",
      "собственные",
      "уникальные",
      "компоненты",
      "не",
      "полагаться",
      "только",
      "решения",
      "как",
      "material",
      "чего",
      "нужен",
      "cdk?",
      "гибкость",
      "кастомизация:",
      "позволяет",
      "полностью",
      "настраиваемые",
      "используя",
      "шаблоны",
      "абстракции",
      "обеспечивают",
      "нужную",
      "повторно",
      "используемые",
      "шаблоны:",
      "набор",
      "функций",
      "часто",
      "используются",
      "при",
      "создании",
      "такие",
      "как:",
      "перетаскивание",
      "(drag",
      "and",
      "drop):",
      "реализации",
      "интерактивных",
      "элементов",
      "всплывающие",
      "окна",
      "меню:",
      "управления",
      "скрывающимися",
      "элементами",
      "интерфейса",
      "специальные",
      "возможности",
      "(accessibility):",
      "утилиты",
      "помогают",
      "сделать",
      "доступными",
      "пользователей",
      "ограниченными",
      "возможностями",
      "управление",
      "фокусом:",
      "корректного",
      "фокусом",
      "сложных",
      "интерфейсах",
      "отделение",
      "логики",
      "от",
      "стилизации:",
      "включает",
      "себя",
      "стилизацию",
      "делает",
      "вместо",
      "этого",
      "он",
      "чистую",
      "которую",
      "затем",
      "накладываются",
      "необходимые",
      "стили",
      "основа",
      "material:",
      "интерфейсов",
      "стиле",
      "design",
      "использует",
      "из",
      "чтобы",
      "добавить",
      "ним",
      "использовать",
      "установка:",
      "добавляете",
      "пакет",
      "angular/cdk",
      "свой",
      "angular-проект",
      "импорт",
      "модулей:",
      "выбираете",
      "импортируете",
      "модуль",
      "нужные",
      "модули",
      "например",
      "перетаскивания",
      "(dragdropmodule)",
      "или",
      "окнами",
      "(overlaymodule)",
      "реализация",
      "функциональности:",
      "используете",
      "предоставленные",
      "директивы",
      "сервисы",
      "добавления",
      "нужного",
      "поведения",
      "ваш",
      "компонент",
      "стилизация:",
      "css-стили",
      "другой",
      "библиотеки",
      "придать",
      "компоненту",
      "желаемый",
      "внешний",
      "вид",
      "таким",
      "образом",
      "является",
      "важным",
      "набором",
      "который",
      "упрощает",
      "разработку",
      "настраиваемых",
      "платформе"
    ],
    "_tags": "api что такое angular cdk (component dev kit) это библиотека базовых инструментов утилит которые предоставляют готовые использованию \"примитивы\" для создания пользовательских компонентов приложениях на она предоставляет функциональность без стилизации позволяя разработчикам создавать собственные уникальные компоненты не полагаться только решения как material чего нужен cdk? гибкость кастомизация: позволяет полностью настраиваемые используя шаблоны абстракции обеспечивают нужную повторно используемые шаблоны: набор функций часто используются при создании такие как: перетаскивание (drag and drop): реализации интерактивных элементов всплывающие окна меню: управления скрывающимися элементами интерфейса специальные возможности (accessibility): утилиты помогают сделать доступными пользователей ограниченными возможностями управление фокусом: корректного фокусом сложных интерфейсах отделение логики от стилизации: включает себя стилизацию делает вместо этого он чистую которую затем накладываются необходимые стили основа material: интерфейсов стиле design использует из чтобы добавить ним использовать установка: добавляете пакет angular/cdk свой angular-проект импорт модулей: выбираете импортируете модуль нужные модули например перетаскивания (dragdropmodule) или окнами (overlaymodule) реализация функциональности: используете предоставленные директивы сервисы добавления нужного поведения ваш компонент стилизация: css-стили другой библиотеки придать компоненту желаемый внешний вид таким образом является важным набором который упрощает разработку настраиваемых платформе",
    "_version": 1
  },
  {
    "_id": "68b85ce3f63b804800265ea3",
    "title": "f",
    "content": "ff",
    "group": "Группа1",
    "subGroup": "sdfsdfsdf",
    "ignoreHtml": false,
    "order": 8,
    "imageUrls": "",
    "_created": "2025-09-03T15:21:07.018Z",
    "_changed": "2025-09-18T19:19:15.800Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "ff",
      "группа1",
      "sdfsdfsdf"
    ],
    "_tags": "api ff группа1 sdfsdfsdf",
    "_version": 2
  },
  {
    "_id": "68b5fed6f63b804800263187",
    "title": "How to center div",
    "content": "Center Align Block Elements\n<p><img src=\" https://ik.imagekit.io/ygtb3rzhz/center1.png?updatedAt=1756758113518\" alt=\"В\" style=\"max-width: 100%;\"></p> \nCenter Align Text\n <p><img src=\"https://ik.imagekit.io/ygtb3rzhz/center2.png?updatedAt=1756758166002\" alt=\"В\" style=\"max-width: 100%;\"></p>\nCenter Align an Image\n <p><img src=\"https://ik.imagekit.io/ygtb3rzhz/center3.png?updatedAt=1756758238543\" alt=\"В\" style=\"max-width: 100%;\"></p> \nCenter Align with Flexbox\n <p><img src=\"https://ik.imagekit.io/ygtb3rzhz/center4.png?updatedAt=1756758253735\" alt=\"В\" style=\"max-width: 100%;\"></p> \nCenter Align with Grid\n <p><img src=\"https://ik.imagekit.io/ygtb3rzhz/center5.png?updatedAt=1756758274130\" alt=\"В\" style=\"max-width: 100%;\"></p> ",
    "group": "CSS",
    "subGroup": "How to...",
    "order": 1,
    "imageUrls": "",
    "_created": "2025-09-01T20:15:18.184Z",
    "_changed": "2025-09-01T20:15:18.184Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "how",
      "to",
      "center",
      "div",
      "align",
      "block",
      "elements",
      "text",
      "an",
      "image",
      "with",
      "flexbox",
      "grid",
      "css"
    ],
    "_tags": "api how to center div align block elements text an image with flexbox grid css",
    "_version": 0
  },
  {
    "_id": "68b738f4f63b80480026482d",
    "title": "D - Dependency Inversion Principle (Принцип инверсии зависимостей)",
    "content": "Описание:\n  •  Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба типа модулей должны зависеть от абстракций.\n  •  Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.\n•  Пример: Рассмотрим компонент, который должен отправлять данные в службу логирования.\n\n  Плохой пример (нарушение DIP): <p><img src=\"https://ik.imagekit.io/ygtb3rzhz/solid%20d%201.png?updatedAt=1756838811047\" alt=\"В\" style=\"max-width: 100%;\"></p> \nDataService напрямую зависит от LoggerService. Если мы захотим заменить службу логирования, придется изменять DataService.\n  Хороший пример (соблюдение DIP):\n <p><img src=\"https://ik.imagekit.io/ygtb3rzhz/solid%20d%202.png?updatedAt=1756838849696\" alt=\"В\" style=\"max-width: 100%;\"></p> ",
    "group": "ООП",
    "subGroup": "SOLID Принципы",
    "ignoreHtml": false,
    "order": 6,
    "imageUrls": "",
    "_created": "2025-09-02T18:35:32.579Z",
    "_changed": "2025-09-02T18:37:57.825Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "dependency",
      "inversion",
      "principle",
      "(принцип",
      "инверсии",
      "зависимостей)",
      "описание:",
      "модули",
      "верхнего",
      "уровня",
      "не",
      "должны",
      "зависеть",
      "от",
      "модулей",
      "нижнего",
      "оба",
      "типа",
      "абстракций",
      "абстракции",
      "деталей",
      "детали",
      "пример:",
      "рассмотрим",
      "компонент",
      "который",
      "должен",
      "отправлять",
      "данные",
      "службу",
      "логирования",
      "плохой",
      "пример",
      "(нарушение",
      "dip):",
      "dataservice",
      "напрямую",
      "зависит",
      "loggerservice",
      "если",
      "мы",
      "захотим",
      "заменить",
      "придется",
      "изменять",
      "хороший",
      "(соблюдение",
      "ооп",
      "solid",
      "принципы"
    ],
    "_tags": "api dependency inversion principle (принцип инверсии зависимостей) описание: модули верхнего уровня не должны зависеть от модулей нижнего оба типа абстракций абстракции деталей детали пример: рассмотрим компонент который должен отправлять данные службу логирования плохой пример (нарушение dip): dataservice напрямую зависит loggerservice если мы захотим заменить придется изменять хороший (соблюдение ооп solid принципы",
    "_version": 1
  },
  {
    "_id": "68b734aff63b8048002647df",
    "title": "S - Single Responsibility Principle (Принцип единственной обязанности)",
    "content": "S - Single Responsibility Principle (Принцип единственной обязанности):\n•  Описание: Компонент, сервис или любой другой модуль в Angular должен иметь только одну причину для изменения.\n•  Пример: Рассмотрим компонент, который отвечает за получение данных из API и отображение их в шаблоне. Это нарушает SRP. Лучше разделить его на два:\n  Плохой пример (нарушение SRP):\n      <b>users: any[];\n      constructor(private http: HttpClient) { }\n      ngOnInit() {\n        this.http.get<any[]>('https://api.example.com/users')\n          .subscribe(data => {\n            this.users = data;\n          });\n      }</b>\nХороший пример (соблюдение SRP):\n  <b> export class UserService {\n      constructor(private http: HttpClient) { }\n\n      getUsers(): Observable<any[]> {\n        return this.http.get<any[]>('https://api.example.com/users');\n      }\n    }\nexport class UserListComponent implements OnInit {\n      users: any[];\n\n      constructor(private userService: UserService) { }\n\n      ngOnInit() {\n        this.userService.getUsers().subscribe(data => {\n          this.users = data;\n        });\n      }\n    } </b>\nТеперь UserListComponent отвечает только за отображение данных, а UserService - за их получение. Это упрощает тестирование и поддержку каждого модуля.",
    "group": "ООП",
    "subGroup": "SOLID Принципы",
    "ignoreHtml": false,
    "order": 2,
    "imageUrls": "",
    "_created": "2025-09-02T18:17:19.586Z",
    "_changed": "2025-09-02T18:38:11.956Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "single",
      "responsibility",
      "principle",
      "(принцип",
      "единственной",
      "обязанности)",
      "обязанности):",
      "описание:",
      "компонент",
      "сервис",
      "или",
      "любой",
      "другой",
      "модуль",
      "angular",
      "должен",
      "иметь",
      "только",
      "одну",
      "причину",
      "для",
      "изменения",
      "пример:",
      "рассмотрим",
      "который",
      "отвечает",
      "за",
      "получение",
      "данных",
      "из",
      "отображение",
      "их",
      "шаблоне",
      "это",
      "нарушает",
      "srp",
      "лучше",
      "разделить",
      "его",
      "на",
      "два:",
      "плохой",
      "пример",
      "(нарушение",
      "srp):",
      "users:",
      "any[];",
      "constructor(private",
      "http:",
      "httpclient)",
      "ngoninit()",
      "this",
      "http",
      "get('https://api",
      "example",
      "com/users')",
      "subscribe(data",
      "=>",
      "users",
      "data;",
      "});",
      "хороший",
      "(соблюдение",
      "export",
      "class",
      "userservice",
      "getusers():",
      "observable",
      "return",
      "com/users');",
      "userlistcomponent",
      "implements",
      "oninit",
      "userservice:",
      "userservice)",
      "getusers()",
      "теперь",
      "упрощает",
      "тестирование",
      "поддержку",
      "каждого",
      "модуля",
      "ооп",
      "solid",
      "принципы"
    ],
    "_tags": "api single responsibility principle (принцип единственной обязанности) обязанности): описание: компонент сервис или любой другой модуль angular должен иметь только одну причину для изменения пример: рассмотрим который отвечает за получение данных из отображение их шаблоне это нарушает srp лучше разделить его на два: плохой пример (нарушение srp): users: any[]; constructor(private http: httpclient) ngoninit() this http get('https://api example com/users') subscribe(data => users data; }); хороший (соблюдение export class userservice getusers(): observable return com/users'); userlistcomponent implements oninit userservice: userservice) getusers() теперь упрощает тестирование поддержку каждого модуля ооп solid принципы",
    "_version": 3,
    "editing": false
  },
  {
    "_id": "68b5ff8ef63b804800263194",
    "title": "Lifecycle hooks",
    "content": "Angular application goes through an entire set of processes or has a lifecycle right from its initiation to the end of the application.\n <p><img src=\"https://github.com/sudheerj/angular-interview-questions/raw/master/images/lifecycle.png\" alt=\"В\" style=\"max-width: 100%;\"></p>\n1. ngOnChanges(changes: SimpleChanges):\n•   Когда вызывается:  Вызывается *перед* ngOnInit (при первом создании компонента) и *каждый раз*, когда изменяется значение одного или нескольких входных свойств (@Input) компонента.\n•   Что делает:  Позволяет реагировать на изменения входных свойств.  Объект changes содержит информацию о том, какие свойства изменились, их предыдущие и текущие значения.\n•   Использование:  Обновление внутренних переменных компонента на основе новых значений входных свойств, выполнение валидации данных, запуск каких-либо вычислений.\n\n2. ngOnInit():\n•   Когда вызывается:  Вызывается *один раз* после первого вызова ngOnChanges.  Вызывается после того, как Angular инициализировал все привязанные свойства компонента.\n•   Что делает:  Выполняет инициализацию компонента.\n•   Использование:  Загрузка данных с сервера, установка начальных значений переменных, подписка на Observables, выполнение любой логики, которая должна быть выполнена только один раз при создании компонента.  ngOnInit обычно является наиболее часто используемым lifecycle hook.\n\n3. ngDoCheck():\n•   Когда вызывается:  Вызывается *при каждой проверке изменений* в компоненте.  Вызывается после ngOnInit и ngAfterContentChecked, но *перед* ngAfterViewChecked.  Вызывается очень часто, поэтому его использование должно быть хорошо продумано.\n•   Что делает:  Позволяет реализовать *собственную* логику обнаружения изменений.  Angular использует стратегию обнаружения изменений, которая может не всегда подходить для всех случаев.  ngDoCheck позволяет вам вручную проверить, изменились ли какие-либо данные, которые Angular не отслеживает автоматически.\n•   Использование:  Обнаружение изменений в сложных объектах или массивах, где Angular не может определить изменения простым сравнением.  *Используйте осторожно!*  Чрезмерное использование ngDoCheck может негативно повлиять на производительность приложения.\n\n4. ngAfterContentInit():\n•   Когда вызывается:  Вызывается *один раз* после того, как Angular полностью инициализировал содержимое, проецированное в компонент извне (например, через <ng-content>).\n•   Что делает:  Позволяет выполнить логику после инициализации проецируемого контента.\n•   Использование:  Получение доступа к проецируемым элементам через @ContentChildren или @ContentChild и выполнение с ними каких-либо действий.\n\n5. ngAfterContentChecked():\n•   Когда вызывается:  Вызывается *после каждой проверки* содержимого, проецированного в компонент.  Вызывается после ngAfterContentInit и после каждого вызова ngDoCheck.\n•   Что делает:  Позволяет реагировать на изменения в проецируемом контенте.\n•   Использование:  Выполнение логики, которая должна быть выполнена после изменения проецируемого контента.  *Используйте осторожно!*  Как и ngDoCheck, ngAfterContentChecked вызывается часто, поэтому его использование должно быть продумано.\n\n6. ngAfterViewInit():\n•   Когда вызывается:  Вызывается *один раз* после того, как Angular полностью инициализировал представление компонента и представления всех его дочерних компонентов.\n•   Что делает:  Позволяет получить доступ к DOM-элементам, которые отображаются в представлении компонента.\n•   Использование:  Инициализация сторонних библиотек, которые работают с DOM, получение размеров элементов, выполнение анимаций.  Вы можете использовать @ViewChildren или @ViewChildдля получения доступа к дочерним компонентам или элементам DOM.\n\n7. ngAfterViewChecked():\n•   Когда вызывается:  Вызывается *после каждой проверки* представления компонента и представлений его дочерних компонентов.  Вызывается после ngAfterViewInit и после каждого вызова ngAfterContentChecked.\n•   Что делает:  Позволяет реагировать на изменения в представлении компонента.\n•   Использование:  Выполнение логики, которая должна быть выполнена после изменения представления компонента.  *Используйте осторожно!*  ngAfterViewChecked вызывается очень часто, поэтому его использование должно быть продумано, чтобы избежать проблем с производительностью.  Частая ошибка - попытка изменить данные, привязанные к представлению, в ngAfterViewChecked, что может привести к бесконечному циклу.\n\n8. ngOnDestroy():\n•   Когда вызывается:  Вызывается *непосредственно перед* уничтожением компонента или директивы.\n•   Что делает:  Выполняет очистку ресурсов.\n•   Использование:  Отписка от Observables, отмена подписок на события, освобождение памяти, удаление DOM-элементов, отмена таймеров.  *Крайне важно* правильно реализовать ngOnDestroy для предотвращения утечек памяти и других проблем.  Всегда отписывайтесь от Observables и отменяйте подписки на события в ngOnDestroy.\n\nПорядок вызова Lifecycle Hooks (упрощенно):\n1.  ngOnChanges() (если есть @Input свойства)\n2.  ngOnInit()\n3.  ngDoCheck()\n4.  ngAfterContentInit()\n5.  ngAfterContentChecked()\n6.  ngAfterViewInit()\n7.  ngAfterViewChecked()\n8.  ... (цикл ngDoCheck(), ngAfterContentChecked(), ngAfterViewChecked() повторяется при каждой проверке изменений)\n9.  ngOnDestroy()\n\n",
    "group": "Angular",
    "subGroup": "Angular basic",
    "order": 4,
    "imageUrls": "",
    "_created": "2025-09-01T20:18:22.567Z",
    "_changed": "2025-09-01T20:23:02.941Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "lifecycle",
      "hooks",
      "angular",
      "application",
      "goes",
      "through",
      "an",
      "entire",
      "set",
      "of",
      "processes",
      "or",
      "has",
      "right",
      "from",
      "its",
      "initiation",
      "to",
      "the",
      "end",
      "ngonchanges(changes:",
      "simplechanges):",
      "когда",
      "вызывается:",
      "вызывается",
      "*перед*",
      "ngoninit",
      "(при",
      "первом",
      "создании",
      "компонента)",
      "*каждый",
      "раз*",
      "изменяется",
      "значение",
      "одного",
      "или",
      "нескольких",
      "входных",
      "свойств",
      "input)",
      "компонента",
      "что",
      "делает:",
      "позволяет",
      "реагировать",
      "на",
      "изменения",
      "объект",
      "changes",
      "содержит",
      "информацию",
      "том",
      "какие",
      "свойства",
      "изменились",
      "их",
      "предыдущие",
      "текущие",
      "значения",
      "использование:",
      "обновление",
      "внутренних",
      "переменных",
      "основе",
      "новых",
      "значений",
      "выполнение",
      "валидации",
      "данных",
      "запуск",
      "каких-либо",
      "вычислений",
      "ngoninit():",
      "*один",
      "после",
      "первого",
      "вызова",
      "ngonchanges",
      "того",
      "как",
      "инициализировал",
      "все",
      "привязанные",
      "выполняет",
      "инициализацию",
      "загрузка",
      "сервера",
      "установка",
      "начальных",
      "подписка",
      "observables",
      "любой",
      "логики",
      "которая",
      "должна",
      "быть",
      "выполнена",
      "только",
      "один",
      "раз",
      "при",
      "обычно",
      "является",
      "наиболее",
      "часто",
      "используемым",
      "hook",
      "ngdocheck():",
      "*при",
      "каждой",
      "проверке",
      "изменений*",
      "компоненте",
      "ngaftercontentchecked",
      "но",
      "ngafterviewchecked",
      "очень",
      "поэтому",
      "его",
      "использование",
      "должно",
      "хорошо",
      "продумано",
      "реализовать",
      "*собственную*",
      "логику",
      "обнаружения",
      "изменений",
      "использует",
      "стратегию",
      "может",
      "не",
      "всегда",
      "подходить",
      "для",
      "всех",
      "случаев",
      "ngdocheck",
      "вам",
      "вручную",
      "проверить",
      "ли",
      "какие-либо",
      "данные",
      "которые",
      "отслеживает",
      "автоматически",
      "обнаружение",
      "сложных",
      "объектах",
      "массивах",
      "где",
      "определить",
      "простым",
      "сравнением",
      "*используйте",
      "осторожно!*",
      "чрезмерное",
      "негативно",
      "повлиять",
      "производительность",
      "приложения",
      "ngaftercontentinit():",
      "полностью",
      "содержимое",
      "проецированное",
      "компонент",
      "извне",
      "(например",
      "через",
      "выполнить",
      "инициализации",
      "проецируемого",
      "контента",
      "получение",
      "доступа",
      "проецируемым",
      "элементам",
      "contentchildren",
      "contentchild",
      "ними",
      "действий",
      "ngaftercontentchecked():",
      "*после",
      "проверки*",
      "содержимого",
      "проецированного",
      "ngaftercontentinit",
      "каждого",
      "проецируемом",
      "контенте",
      "ngafterviewinit():",
      "представление",
      "представления",
      "дочерних",
      "компонентов",
      "получить",
      "доступ",
      "dom-элементам",
      "отображаются",
      "представлении",
      "инициализация",
      "сторонних",
      "библиотек",
      "работают",
      "dom",
      "размеров",
      "элементов",
      "анимаций",
      "вы",
      "можете",
      "использовать",
      "viewchildren",
      "viewchildдля",
      "получения",
      "дочерним",
      "компонентам",
      "ngafterviewchecked():",
      "представлений",
      "ngafterviewinit",
      "чтобы",
      "избежать",
      "проблем",
      "производительностью",
      "частая",
      "ошибка",
      "попытка",
      "изменить",
      "представлению",
      "привести",
      "бесконечному",
      "циклу",
      "ngondestroy():",
      "*непосредственно",
      "перед*",
      "уничтожением",
      "директивы",
      "очистку",
      "ресурсов",
      "отписка",
      "от",
      "отмена",
      "подписок",
      "события",
      "освобождение",
      "памяти",
      "удаление",
      "dom-элементов",
      "таймеров",
      "*крайне",
      "важно*",
      "правильно",
      "ngondestroy",
      "предотвращения",
      "утечек",
      "других",
      "отписывайтесь",
      "отменяйте",
      "подписки",
      "порядок",
      "(упрощенно):",
      "ngonchanges()",
      "(если",
      "есть",
      "input",
      "свойства)",
      "ngoninit()",
      "ngdocheck()",
      "ngaftercontentinit()",
      "ngaftercontentchecked()",
      "ngafterviewinit()",
      "ngafterviewchecked()",
      "(цикл",
      "повторяется",
      "изменений)",
      "ngondestroy()",
      "basic"
    ],
    "_tags": "api lifecycle hooks angular application goes through an entire set of processes or has right from its initiation to the end ngonchanges(changes: simplechanges): когда вызывается: вызывается *перед* ngoninit (при первом создании компонента) *каждый раз* изменяется значение одного или нескольких входных свойств input) компонента что делает: позволяет реагировать на изменения объект changes содержит информацию том какие свойства изменились их предыдущие текущие значения использование: обновление внутренних переменных основе новых значений выполнение валидации данных запуск каких-либо вычислений ngoninit(): *один после первого вызова ngonchanges того как инициализировал все привязанные выполняет инициализацию загрузка сервера установка начальных подписка observables любой логики которая должна быть выполнена только один раз при обычно является наиболее часто используемым hook ngdocheck(): *при каждой проверке изменений* компоненте ngaftercontentchecked но ngafterviewchecked очень поэтому его использование должно хорошо продумано реализовать *собственную* логику обнаружения изменений использует стратегию может не всегда подходить для всех случаев ngdocheck вам вручную проверить ли какие-либо данные которые отслеживает автоматически обнаружение сложных объектах массивах где определить простым сравнением *используйте осторожно!* чрезмерное негативно повлиять производительность приложения ngaftercontentinit(): полностью содержимое проецированное компонент извне (например через выполнить инициализации проецируемого контента получение доступа проецируемым элементам contentchildren contentchild ними действий ngaftercontentchecked(): *после проверки* содержимого проецированного ngaftercontentinit каждого проецируемом контенте ngafterviewinit(): представление представления дочерних компонентов получить доступ dom-элементам отображаются представлении инициализация сторонних библиотек работают dom размеров элементов анимаций вы можете использовать viewchildren viewchildдля получения дочерним компонентам ngafterviewchecked(): представлений ngafterviewinit чтобы избежать проблем производительностью частая ошибка попытка изменить представлению привести бесконечному циклу ngondestroy(): *непосредственно перед* уничтожением директивы очистку ресурсов отписка от отмена подписок события освобождение памяти удаление dom-элементов таймеров *крайне важно* правильно ngondestroy предотвращения утечек других отписывайтесь отменяйте подписки порядок (упрощенно): ngonchanges() (если есть input свойства) ngoninit() ngdocheck() ngaftercontentinit() ngaftercontentchecked() ngafterviewinit() ngafterviewchecked() (цикл повторяется изменений) ngondestroy() basic",
    "_version": 9,
    "editing": false
  },
  {
    "_id": "68b6023ff63b8048002631c2",
    "title": "Конструктор VS ngOnInit",
    "content": "Основная разница между конструктором и ngOnInit в Angular заключается в их назначении, времени вызова и доступности данных.\nКонструктор (Constructor):\n•  Назначение: Конструктор класса (в данном случае, класса компонента или директивы) используется для инициализации объекта класса. Он в основном предназначен для:\n  •  Внедрения зависимостей: Внедрение сервисов и других зависимостей, необходимых для работы компонента, через Dependency Injection (DI).\n  •  Установки начальных значений свойств класса: Установка простых начальных значений для свойств класса, которые не зависят от входных свойств (@Input).\n•  Время вызова: Конструктор вызывается первым при создании экземпляра компонента или директивы. Он вызывается до того, как Angular свяжет входные свойства (@Input) с компонентом и до того, как представление компонента будет инициализировано.\n•  Доступность данных:\n  •  Входные свойства (@Input) еще не определены: В конструкторе входные свойства, переданные компоненту, недоступны. Angular еще не установил значения этих свойств. Попытка обратиться к ним в конструкторе приведет к ошибке или неопределенному значению.\n  •  DOM недоступен: DOM (Document Object Model) еще не создан, поэтому нельзя получить доступ к элементам DOM в конструкторе.\nngOnInit():\n•  Назначение: ngOnInit - это lifecycle hook, который вызывается Angular для инициализации компонента после того, как Angular инициализировал все привязанные свойства компонента. Он предназначен для:\n  •  Загрузки данных: Загрузка данных с сервера, использование сервисов для получения данных.\n  •  Выполнения логики инициализации: Выполнение любой логики, которая должна быть выполнена только один раз после создания компонента.\n  •  Подписки на Observables: Подписка на потоки данных (Observables) для получения обновлений.\n•  Время вызова: ngOnInit вызывается после конструктора и после первого вызова ngOnChanges (если есть входные свойства). Это гарантирует, что все входные свойства уже установлены, и компонент готов к инициализации.\n•  Доступность данных:\n  •  Входные свойства (@Input) доступны: В ngOnInit все входные свойства, переданные компоненту, доступны и содержат свои значения.\n  •  DOM еще не полностью готов: DOM еще не полностью инициализирован (особенно дочерние компоненты), поэтому осторожно с доступом к DOM-элементам в ngOnInit. Лучше использовать ngAfterViewInit для работы с DOM.\n <p><img src=\"https://ik.imagekit.io/ygtb3rzhz/constructorvsngoninit.png?updatedAt=1756759309417\" alt=\"В\" style=\"max-width: 100%;\"></p> \nКогда что использовать:\n•  Конструктор:\n  •  Для внедрения зависимостей (сервисов, и т.д.).\n  •  Для установки простых начальных значений свойств, которые не зависят от входных данных.\n•  ngOnInit():\n  •  Для загрузки данных, требуемых компоненту.\n  •  Для выполнения логики, зависящей от входных данных.\n  •  Для подписки на Observables.\n  •  Для выполнения инициализации, которая должна быть выполнена только один раз при создании компонента.",
    "group": "Angular",
    "subGroup": "Angular basic",
    "order": 5,
    "imageUrls": "",
    "_created": "2025-09-01T20:29:51.304Z",
    "_changed": "2025-09-01T20:30:11.778Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "конструктор",
      "vs",
      "ngoninit",
      "основная",
      "разница",
      "между",
      "конструктором",
      "angular",
      "заключается",
      "их",
      "назначении",
      "времени",
      "вызова",
      "доступности",
      "данных",
      "(constructor):",
      "назначение:",
      "класса",
      "(в",
      "данном",
      "случае",
      "компонента",
      "или",
      "директивы)",
      "используется",
      "для",
      "инициализации",
      "объекта",
      "он",
      "основном",
      "предназначен",
      "для:",
      "внедрения",
      "зависимостей:",
      "внедрение",
      "сервисов",
      "других",
      "зависимостей",
      "необходимых",
      "работы",
      "через",
      "dependency",
      "injection",
      "(di)",
      "установки",
      "начальных",
      "значений",
      "свойств",
      "класса:",
      "установка",
      "простых",
      "которые",
      "не",
      "зависят",
      "от",
      "входных",
      "input)",
      "время",
      "вызова:",
      "вызывается",
      "первым",
      "при",
      "создании",
      "экземпляра",
      "директивы",
      "до",
      "того",
      "как",
      "свяжет",
      "входные",
      "свойства",
      "компонентом",
      "представление",
      "будет",
      "инициализировано",
      "доступность",
      "данных:",
      "еще",
      "определены:",
      "конструкторе",
      "переданные",
      "компоненту",
      "недоступны",
      "установил",
      "значения",
      "этих",
      "попытка",
      "обратиться",
      "ним",
      "приведет",
      "ошибке",
      "неопределенному",
      "значению",
      "dom",
      "недоступен:",
      "(document",
      "object",
      "model)",
      "создан",
      "поэтому",
      "нельзя",
      "получить",
      "доступ",
      "элементам",
      "ngoninit():",
      "это",
      "lifecycle",
      "hook",
      "который",
      "после",
      "инициализировал",
      "все",
      "привязанные",
      "загрузки",
      "загрузка",
      "сервера",
      "использование",
      "получения",
      "выполнения",
      "логики",
      "инициализации:",
      "выполнение",
      "любой",
      "которая",
      "должна",
      "быть",
      "выполнена",
      "только",
      "один",
      "раз",
      "создания",
      "подписки",
      "на",
      "observables:",
      "подписка",
      "потоки",
      "(observables)",
      "обновлений",
      "конструктора",
      "первого",
      "ngonchanges",
      "(если",
      "есть",
      "свойства)",
      "гарантирует",
      "что",
      "уже",
      "установлены",
      "компонент",
      "готов",
      "доступны:",
      "доступны",
      "содержат",
      "свои",
      "полностью",
      "готов:",
      "инициализирован",
      "(особенно",
      "дочерние",
      "компоненты)",
      "осторожно",
      "доступом",
      "dom-элементам",
      "лучше",
      "использовать",
      "ngafterviewinit",
      "когда",
      "использовать:",
      "конструктор:",
      "(сервисов",
      "требуемых",
      "зависящей",
      "observables",
      "basic"
    ],
    "_tags": "api конструктор vs ngoninit основная разница между конструктором angular заключается их назначении времени вызова доступности данных (constructor): назначение: класса (в данном случае компонента или директивы) используется для инициализации объекта он основном предназначен для: внедрения зависимостей: внедрение сервисов других зависимостей необходимых работы через dependency injection (di) установки начальных значений свойств класса: установка простых которые не зависят от входных input) время вызова: вызывается первым при создании экземпляра директивы до того как свяжет входные свойства компонентом представление будет инициализировано доступность данных: еще определены: конструкторе переданные компоненту недоступны установил значения этих попытка обратиться ним приведет ошибке неопределенному значению dom недоступен: (document object model) создан поэтому нельзя получить доступ элементам ngoninit(): это lifecycle hook который после инициализировал все привязанные загрузки загрузка сервера использование получения выполнения логики инициализации: выполнение любой которая должна быть выполнена только один раз создания подписки на observables: подписка потоки (observables) обновлений конструктора первого ngonchanges (если есть свойства) гарантирует что уже установлены компонент готов доступны: доступны содержат свои полностью готов: инициализирован (особенно дочерние компоненты) осторожно доступом dom-элементам лучше использовать ngafterviewinit когда использовать: конструктор: (сервисов требуемых зависящей observables basic",
    "_version": 6
  },
  {
    "_id": "68b73690f63b804800264802",
    "title": "O - Open/Closed Principle (Принцип открытости/закрытости)",
    "content": "Компоненты и другие модули должны быть открыты для расширения, но закрыты для модификации. В Angular это часто достигается с использованием директив, пайпов и dependency injection.\n•  Пример: Допустим, у нас есть компонент, который отображает различные типы уведомлений (ошибки, предупреждения, информация).\n\n  Плохой пример (нарушение OCP):\n <p><img src=\"https://ik.imagekit.io/ygtb3rzhz/solid%20o%200.png?updatedAt=1756838182766\" alt=\"В\" style=\"max-width: 100%;\"></p> \nКаждый раз, когда нужно добавить новый тип уведомления, придется изменять этот компонент.\n\n  Хороший пример (соблюдение OCP): Используем стратегию <b>ngTemplateOutlet</b> и <b>ngTemplateOutletContext</b>\n <p><img src=\"https://ik.imagekit.io/ygtb3rzhz/solid%200%201.png?updatedAt=1756838161187\" alt=\"В\" style=\"max-width: 100%;\"></p> \nТеперь, чтобы добавить новый тип уведомления, просто создаем новый ng-template и передаем его в компонент NotificationComponent. Не нужно изменять сам компонент.",
    "group": "ООП",
    "subGroup": "SOLID Принципы",
    "ignoreHtml": false,
    "order": 3,
    "imageUrls": "",
    "_created": "2025-09-02T18:25:20.603Z",
    "_changed": "2025-09-02T18:38:09.951Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "open/closed",
      "principle",
      "(принцип",
      "открытости/закрытости)",
      "компоненты",
      "другие",
      "модули",
      "должны",
      "быть",
      "открыты",
      "для",
      "расширения",
      "но",
      "закрыты",
      "модификации",
      "angular",
      "это",
      "часто",
      "достигается",
      "использованием",
      "директив",
      "пайпов",
      "dependency",
      "injection",
      "пример:",
      "допустим",
      "нас",
      "есть",
      "компонент",
      "который",
      "отображает",
      "различные",
      "типы",
      "уведомлений",
      "(ошибки",
      "предупреждения",
      "информация)",
      "плохой",
      "пример",
      "(нарушение",
      "ocp):",
      "каждый",
      "раз",
      "когда",
      "нужно",
      "добавить",
      "новый",
      "тип",
      "уведомления",
      "придется",
      "изменять",
      "этот",
      "хороший",
      "(соблюдение",
      "используем",
      "стратегию",
      "ngtemplateoutlet",
      "ngtemplateoutletcontext",
      "теперь",
      "чтобы",
      "просто",
      "создаем",
      "ng-template",
      "передаем",
      "его",
      "notificationcomponent",
      "не",
      "сам",
      "ооп",
      "solid",
      "принципы"
    ],
    "_tags": "api open/closed principle (принцип открытости/закрытости) компоненты другие модули должны быть открыты для расширения но закрыты модификации angular это часто достигается использованием директив пайпов dependency injection пример: допустим нас есть компонент который отображает различные типы уведомлений (ошибки предупреждения информация) плохой пример (нарушение ocp): каждый раз когда нужно добавить новый тип уведомления придется изменять этот хороший (соблюдение используем стратегию ngtemplateoutlet ngtemplateoutletcontext теперь чтобы просто создаем ng-template передаем его notificationcomponent не сам ооп solid принципы",
    "_version": 1
  },
  {
    "_id": "68b73734f63b80480026480f",
    "title": "L - Liskov Substitution Principle (Принцип подстановки Лисков)",
    "content": "Подклассы должны быть подставляемыми вместо своих базовых классов без изменения корректности программы. В Angular это означает, что компонент, реализующий интерфейс, должен корректно работать везде, где используется этот интерфейс.\n•  Пример: Рассмотрим интерфейс PaymentProcessor и несколько его реализаций:\n <p><img src=\"https://ik.imagekit.io/ygtb3rzhz/solid%20l%201.png?updatedAt=1756838375158\" alt=\"В\" style=\"max-width: 100%;\"></p> \nТеперь мы можем использовать любой из этих сервисов в компоненте, и компонент будет работать корректно, не зная, какой именно сервис используется: <p><img src=\"https://ik.imagekit.io/ygtb3rzhz/solid%20l%202.png?updatedAt=1756838397848\" alt=\"В\" style=\"max-width: 100%;\"></p> \nМы можем легко заменить CreditCardPaymentService на PayPalPaymentService в providers без изменения кода PaymentComponent.",
    "group": "ООП",
    "subGroup": "SOLID Принципы",
    "ignoreHtml": false,
    "order": 4,
    "imageUrls": "",
    "_created": "2025-09-02T18:28:04.692Z",
    "_changed": "2025-09-02T18:38:08.948Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "liskov",
      "substitution",
      "principle",
      "(принцип",
      "подстановки",
      "лисков)",
      "подклассы",
      "должны",
      "быть",
      "подставляемыми",
      "вместо",
      "своих",
      "базовых",
      "классов",
      "без",
      "изменения",
      "корректности",
      "программы",
      "angular",
      "это",
      "означает",
      "что",
      "компонент",
      "реализующий",
      "интерфейс",
      "должен",
      "корректно",
      "работать",
      "везде",
      "где",
      "используется",
      "этот",
      "пример:",
      "рассмотрим",
      "paymentprocessor",
      "несколько",
      "его",
      "реализаций:",
      "теперь",
      "мы",
      "можем",
      "использовать",
      "любой",
      "из",
      "этих",
      "сервисов",
      "компоненте",
      "будет",
      "не",
      "зная",
      "какой",
      "именно",
      "сервис",
      "используется:",
      "легко",
      "заменить",
      "creditcardpaymentservice",
      "на",
      "paypalpaymentservice",
      "providers",
      "кода",
      "paymentcomponent",
      "ооп",
      "solid",
      "принципы"
    ],
    "_tags": "api liskov substitution principle (принцип подстановки лисков) подклассы должны быть подставляемыми вместо своих базовых классов без изменения корректности программы angular это означает что компонент реализующий интерфейс должен корректно работать везде где используется этот пример: рассмотрим paymentprocessor несколько его реализаций: теперь мы можем использовать любой из этих сервисов компоненте будет не зная какой именно сервис используется: легко заменить creditcardpaymentservice на paypalpaymentservice providers кода paymentcomponent ооп solid принципы",
    "_version": 1
  },
  {
    "_id": "68b737cdf63b804800264818",
    "title": "I - Interface Segregation Principle (Принцип разделения интерфейсов)",
    "content": "Описание: Клиенты не должны быть вынуждены зависеть от методов, которые они не используют. Вместо одного большого интерфейса лучше иметь несколько маленьких, специализированных. В Angular это относится к созданию интерфейсов для сервисов и компонентов.\n•  Пример: Рассмотрим интерфейс для сервиса, который работает с данными пользователя.\n  Плохой пример (нарушение ISP):\n // user.service.interface.ts\n    export interface UserService {\n      getUser(id: number): any;\n      createUser(user: any): void;\n      updateUser(user: any): void;\n      deleteUser(id: number): void;\n      // ... много других методов\n    }\nЕсли компонент использует только getUser, но вынужден реализовать все методы интерфейса, это нарушает ISP.\n  Хороший пример (соблюдение ISP):\n <p><img src=\"https://ik.imagekit.io/ygtb3rzhz/solid%20i%201.png?updatedAt=1756838571111\" alt=\"В\" style=\"max-width: 100%;\"></p> \nТеперь UserProfileComponent зависит только от UserReader, что делает его более гибким и менее подверженным изменениям.",
    "group": "ООП",
    "subGroup": "SOLID Принципы",
    "ignoreHtml": false,
    "order": 5,
    "imageUrls": "",
    "_created": "2025-09-02T18:30:37.291Z",
    "_changed": "2025-09-02T18:38:05.946Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "interface",
      "segregation",
      "principle",
      "(принцип",
      "разделения",
      "интерфейсов)",
      "описание:",
      "клиенты",
      "не",
      "должны",
      "быть",
      "вынуждены",
      "зависеть",
      "от",
      "методов",
      "которые",
      "они",
      "используют",
      "вместо",
      "одного",
      "большого",
      "интерфейса",
      "лучше",
      "иметь",
      "несколько",
      "маленьких",
      "специализированных",
      "angular",
      "это",
      "относится",
      "созданию",
      "интерфейсов",
      "для",
      "сервисов",
      "компонентов",
      "пример:",
      "рассмотрим",
      "интерфейс",
      "сервиса",
      "который",
      "работает",
      "данными",
      "пользователя",
      "плохой",
      "пример",
      "(нарушение",
      "isp):",
      "//",
      "user",
      "service",
      "ts",
      "export",
      "userservice",
      "getuser(id:",
      "number):",
      "any;",
      "createuser(user:",
      "any):",
      "void;",
      "updateuser(user:",
      "deleteuser(id:",
      "много",
      "других",
      "если",
      "компонент",
      "использует",
      "только",
      "getuser",
      "но",
      "вынужден",
      "реализовать",
      "все",
      "методы",
      "нарушает",
      "isp",
      "хороший",
      "(соблюдение",
      "теперь",
      "userprofilecomponent",
      "зависит",
      "userreader",
      "что",
      "делает",
      "его",
      "более",
      "гибким",
      "менее",
      "подверженным",
      "изменениям",
      "ооп",
      "solid",
      "принципы"
    ],
    "_tags": "api interface segregation principle (принцип разделения интерфейсов) описание: клиенты не должны быть вынуждены зависеть от методов которые они используют вместо одного большого интерфейса лучше иметь несколько маленьких специализированных angular это относится созданию интерфейсов для сервисов компонентов пример: рассмотрим интерфейс сервиса который работает данными пользователя плохой пример (нарушение isp): // user service ts export userservice getuser(id: number): any; createuser(user: any): void; updateuser(user: deleteuser(id: много других если компонент использует только getuser но вынужден реализовать все методы нарушает isp хороший (соблюдение теперь userprofilecomponent зависит userreader что делает его более гибким менее подверженным изменениям ооп solid принципы",
    "_version": 1
  },
  {
    "_id": "68b73976f63b804800264836",
    "title": "SOLID кратко",
    "content": "SOLID - это 5 принципов ООП, направленных на создание гибкого и поддерживаемого кода:\n•  S - Single Responsibility Principle (Принцип единственной обязанности): Класс должен иметь только одну причину для изменения. (Одна задача = Один класс)\n•  O - Open/Closed Principle (Принцип открытости/закрытости): Классы должны быть открыты для расширения, но закрыты для модификации. (Расширяем, а не меняем)\n•  L - Liskov Substitution Principle (Принцип подстановки Лисков): Подклассы должны быть подставляемыми вместо своих базовых классов без изменения корректности программы. (Наследник ведет себя как родитель)\n•  I - Interface Segregation Principle (Принцип разделения интерфейсов): Клиенты не должны быть вынуждены зависеть от методов, которые они не используют. (Меньше интерфейс - лучше)\n•  D - Dependency Inversion Principle (Принцип инверсии зависимостей): Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба должны зависеть от абстракций. (Зависим от абстракций, а не реализаций)",
    "group": "ООП",
    "subGroup": "SOLID Принципы",
    "ignoreHtml": false,
    "order": 1,
    "imageUrls": "",
    "_created": "2025-09-02T18:37:42.288Z",
    "_changed": "2025-09-02T18:38:12.956Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "solid",
      "кратко",
      "это",
      "принципов",
      "ооп",
      "направленных",
      "на",
      "создание",
      "гибкого",
      "поддерживаемого",
      "кода:",
      "single",
      "responsibility",
      "principle",
      "(принцип",
      "единственной",
      "обязанности):",
      "класс",
      "должен",
      "иметь",
      "только",
      "одну",
      "причину",
      "для",
      "изменения",
      "(одна",
      "задача",
      "один",
      "класс)",
      "open/closed",
      "открытости/закрытости):",
      "классы",
      "должны",
      "быть",
      "открыты",
      "расширения",
      "но",
      "закрыты",
      "модификации",
      "(расширяем",
      "не",
      "меняем)",
      "liskov",
      "substitution",
      "подстановки",
      "лисков):",
      "подклассы",
      "подставляемыми",
      "вместо",
      "своих",
      "базовых",
      "классов",
      "без",
      "корректности",
      "программы",
      "(наследник",
      "ведет",
      "себя",
      "как",
      "родитель)",
      "interface",
      "segregation",
      "разделения",
      "интерфейсов):",
      "клиенты",
      "вынуждены",
      "зависеть",
      "от",
      "методов",
      "которые",
      "они",
      "используют",
      "(меньше",
      "интерфейс",
      "лучше)",
      "dependency",
      "inversion",
      "инверсии",
      "зависимостей):",
      "модули",
      "верхнего",
      "уровня",
      "модулей",
      "нижнего",
      "оба",
      "абстракций",
      "(зависим",
      "реализаций)",
      "принципы"
    ],
    "_tags": "api solid кратко это принципов ооп направленных на создание гибкого поддерживаемого кода: single responsibility principle (принцип единственной обязанности): класс должен иметь только одну причину для изменения (одна задача один класс) open/closed открытости/закрытости): классы должны быть открыты расширения но закрыты модификации (расширяем не меняем) liskov substitution подстановки лисков): подклассы подставляемыми вместо своих базовых классов без корректности программы (наследник ведет себя как родитель) interface segregation разделения интерфейсов): клиенты вынуждены зависеть от методов которые они используют (меньше интерфейс лучше) dependency inversion инверсии зависимостей): модули верхнего уровня модулей нижнего оба абстракций (зависим реализаций) принципы",
    "_version": 6,
    "editing": false
  },
  {
    "_id": "68b72ba9f63b80480026473c",
    "title": "Основные теги кратко",
    "content": "Структура документа:\n•   <!DOCTYPE html>: Объявляет тип документа как HTML5.\n•   <html>: Корневой элемент, охватывающий весь HTML-контент.\n•   <head>: Содержит метаданные о документе (заголовок, стили, скрипты и т.д.).\n•   <title>: Задает заголовок страницы, отображаемый в заголовке окна браузера или вкладке.\n•   <meta>: Предоставляет метаданные, такие как кодировка, описание, ключевые слова.\n•   <link>: Связывает внешние ресурсы, такие как таблицы стилей (CSS).\n•   <body>: Содержит основной контент страницы, отображаемый пользователю.\n\nЗаголовки и параграфы:\n•   <h1> - <h6>: Определяют заголовки разных уровней (от самого важного <h1> до наименее важного <h6>).\n•   <p>: Определяет абзац текста.\n\nФорматирование текста:\n•   <b>: Делает текст жирным (bold).  *Лучше использовать <strong>.*\n•   <strong>: Обозначает важный текст (браузеры обычно отображают его жирным).\n•   <i>: Делает текст курсивом (italic). *Лучше использовать <em>.*\n•   <em>: Подчеркивает текст (браузеры обычно отображают его курсивом).\n•   <br>: Вставляет одиночный разрыв строки.\n•   <hr>: Создает горизонтальную линию.\n•   <span>:  Контейнер для текста, не имеющий семантического значения. Используется для стилизации части текста.\n•   <pre>: Отображает предварительно отформатированный текст (сохраняет пробелы и переносы строк).\n•   <code>: Отображает фрагмент компьютерного кода.\n\nСписки:\n•   <ul>: Неупорядоченный список (unordered list) - элементы списка отображаются с маркерами (например, точками).\n•   <ol>: Упорядоченный список (ordered list) - элементы списка отображаются с нумерацией.\n•   <li>: Элемент списка (list item) - используется внутри <ul> или <ol>.\n•   <dl>: Список определений (definition list).\n•   <dt>: Термин в списке определений (definition term).\n•   <dd>: Определение термина в списке определений (definition description).\n\nСсылки и изображения:\n•   <a>: Создает гиперссылку (anchor).\n    *   href: Атрибут, указывающий URL, на который ведет ссылка.\n    *   target: Атрибут, определяющий, где открыть ссылку (например, _blank для открытия в новой вкладке).\n•   <img>: Вставляет изображение (image).\n    *   src: Атрибут, указывающий URL изображения.\n    *   alt: Атрибут, предоставляющий альтернативный текст для изображения (важен для доступности и SEO).\n    *   width: Атрибут, задающий ширину изображения (в пикселях).\n    *   height: Атрибут, задающий высоту изображения (в пикселях).\n\nТаблицы:\n•   <table>: Определяет таблицу.\n•   <tr>: Определяет строку таблицы (table row).\n•   <th>: Определяет заголовочную ячейку таблицы (table header cell).\n•   <td>: Определяет ячейку данных таблицы (table data cell).\n•   <caption>: Определяет заголовок таблицы.\n\nФормы:\n•   <form>: Определяет HTML-форму для ввода данных пользователем.\n    *   action: Атрибут, указывающий URL, на который будут отправлены данные формы.\n    *   method: Атрибут, определяющий HTTP-метод отправки формы (например, GET или POST).\n•   <input>: Определяет поле ввода (input field).\n    *   type: Атрибут, определяющий тип поля ввода (например, text, password, email, number, checkbox, radio, submit).\n    *   name: Атрибут, задающий имя поля, которое используется для отправки данных на сервер.\n    *   value: Атрибут, задающий начальное значение поля.\n    *   placeholder: Атрибут, задающий текст-подсказку в поле.\n•   <textarea>: Определяет многострочное поле ввода текста.\n•   <button>: Определяет кнопку.\n•   <select>: Определяет выпадающий список (dropdown list).\n•   <option>: Определяет опцию в выпадающем списке.\n•   <label>: Определяет подпись (label) для элемента формы.\n    *   for: Атрибут, связывающий подпись с элементом формы (по id).\n•   <fieldset>: Группирует элементы формы.\n•   <legend>: Определяет заголовок для <fieldset>.\n\nРазделы и структура:\n•   <header>: Определяет верхнюю часть страницы или раздела.\n•   <nav>: Определяет навигационную панель.\n•   <main>: Определяет основное содержание страницы.\n•   <article>: Определяет независимую статью или запись.\n•   <section>: Определяет раздел документа.\n•   <aside>: Определяет дополнительный контент (например, боковую панель).\n•   <footer>: Определяет нижнюю часть страницы или раздела.\n•   <div>: Определяет раздел (division) или контейнер для HTML-элементов.  Не имеет семантического значения.  Используется для стилизации и компоновки элементов.\n\nМедиа:\n•   <video>: Встраивает видео.\n•   <audio>: Встраивает аудио.\n•   <source>: Задает медиа-ресурсы для элементов <video> и <audio>.\n•   <track>: Задает текстовые дорожки (субтитры, captions) для элементов <video>.\n\nВстраивание контента:\n•   <iframe>: Встраивает другое HTML-документ в текущий документ.\n\nСкрипты:\n•   <script>: Вставляет или ссылается на JavaScript-код.\n    *   src: Атрибут, указывающий URL внешнего JavaScript-файла.\n\nСемантические теги:\nHTML5 представил ряд семантических тегов, которые помогают описывать структуру и смысл контента:\n•   <article>, <aside>, <details>, <figcaption>, <figure>, <footer>, <header>, <main>, <mark>, <nav>, <section>, <summary>, <time>\n\nВажные атрибуты (общие для многих тегов):\n•   class: Задает имя класса для элемента (используется для стилизации CSS).\n•   id: Задает уникальный идентификатор для элемента (используется для стилизации CSS и для доступа к элементу из JavaScript).\n•   style: Встраивает CSS-стили непосредственно в элемент (не рекомендуется для больших проектов).\n•   title: Задает текст всплывающей подсказки, которая отображается при наведении курсора на элемент.\n\nЭтот список охватывает наиболее часто используемые HTML-теги.  Для получения более подробной информации о каждом теге, атрибутах и их использовании, рекомендуется обращаться к документации MDN Web Docs: [https://developer.mozilla.org/en-US/docs/Web/HTML/Element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element)",
    "group": "HTML",
    "subGroup": "HTML теги",
    "order": 1,
    "imageUrls": "",
    "_created": "2025-09-02T17:38:49.007Z",
    "_changed": "2025-09-02T17:45:46.263Z",
    "_createdby": "api",
    "_changedby": "osokinkostyan12@gmail.com",
    "_keywords": [
      "api",
      "osokinkostyan12",
      "gmail",
      "com",
      "основные",
      "теги",
      "кратко",
      "структура",
      "документа:",
      "объявляет",
      "тип",
      "документа",
      "как",
      "html5",
      "корневой",
      "элемент",
      "охватывающий",
      "весь",
      "html-контент",
      "содержит",
      "метаданные",
      "документе",
      "(заголовок",
      "стили",
      "скрипты",
      "задает",
      "заголовок",
      "страницы",
      "отображаемый",
      "заголовке",
      "окна",
      "браузера",
      "или",
      "вкладке",
      "предоставляет",
      "такие",
      "кодировка",
      "описание",
      "ключевые",
      "слова",
      "связывает",
      "внешние",
      "ресурсы",
      "таблицы",
      "стилей",
      "(css)",
      "основной",
      "контент",
      "пользователю",
      "заголовки",
      "параграфы:",
      "определяют",
      "разных",
      "уровней",
      "(от",
      "самого",
      "важного",
      "до",
      "наименее",
      "определяет",
      "абзац",
      "текста",
      "форматирование",
      "текста:",
      "делает",
      "текст",
      "жирным",
      "(bold)",
      "*лучше",
      "использовать",
      "обозначает",
      "важный",
      "(браузеры",
      "обычно",
      "отображают",
      "его",
      "жирным)",
      "курсивом",
      "(italic)",
      "подчеркивает",
      "курсивом)",
      "вставляет",
      "одиночный",
      "разрыв",
      "строки",
      "создает",
      "горизонтальную",
      "линию",
      "контейнер",
      "для",
      "не",
      "имеющий",
      "семантического",
      "значения",
      "используется",
      "стилизации",
      "части",
      "отображает",
      "предварительно",
      "отформатированный",
      "(сохраняет",
      "пробелы",
      "переносы",
      "строк)",
      "фрагмент",
      "компьютерного",
      "кода",
      "списки:",
      "неупорядоченный",
      "список",
      "(unordered",
      "list)",
      "элементы",
      "списка",
      "отображаются",
      "маркерами",
      "(например",
      "точками)",
      "упорядоченный",
      "(ordered",
      "нумерацией",
      "(list",
      "item)",
      "внутри",
      "определений",
      "(definition",
      "термин",
      "списке",
      "term)",
      "определение",
      "термина",
      "description)",
      "ссылки",
      "изображения:",
      "гиперссылку",
      "(anchor)",
      "href:",
      "атрибут",
      "указывающий",
      "url",
      "на",
      "который",
      "ведет",
      "ссылка",
      "target:",
      "определяющий",
      "где",
      "открыть",
      "ссылку",
      "_blank",
      "открытия",
      "новой",
      "вкладке)",
      "изображение",
      "(image)",
      "src:",
      "изображения",
      "alt:",
      "предоставляющий",
      "альтернативный",
      "(важен",
      "доступности",
      "seo)",
      "width:",
      "задающий",
      "ширину",
      "(в",
      "пикселях)",
      "height:",
      "высоту",
      "таблицы:",
      "таблицу",
      "строку",
      "(table",
      "row)",
      "заголовочную",
      "ячейку",
      "header",
      "cell)",
      "данных",
      "data",
      "формы:",
      "html-форму",
      "ввода",
      "пользователем",
      "action:",
      "будут",
      "отправлены",
      "данные",
      "формы",
      "method:",
      "http-метод",
      "отправки",
      "get",
      "post)",
      "поле",
      "(input",
      "field)",
      "type:",
      "поля",
      "text",
      "password",
      "email",
      "number",
      "checkbox",
      "radio",
      "submit)",
      "name:",
      "имя",
      "которое",
      "сервер",
      "value:",
      "начальное",
      "значение",
      "placeholder:",
      "текст-подсказку",
      "многострочное",
      "кнопку",
      "выпадающий",
      "(dropdown",
      "опцию",
      "выпадающем",
      "подпись",
      "(label)",
      "элемента",
      "for:",
      "связывающий",
      "элементом",
      "(по",
      "id)",
      "группирует",
      "разделы",
      "структура:",
      "верхнюю",
      "часть",
      "раздела",
      "навигационную",
      "панель",
      "основное",
      "содержание",
      "независимую",
      "статью",
      "запись",
      "раздел",
      "дополнительный",
      "боковую",
      "панель)",
      "нижнюю",
      "(division)",
      "html-элементов",
      "имеет",
      "компоновки",
      "элементов",
      "медиа:",
      "встраивает",
      "видео",
      "аудио",
      "медиа-ресурсы",
      "текстовые",
      "дорожки",
      "(субтитры",
      "captions)",
      "встраивание",
      "контента:",
      "другое",
      "html-документ",
      "текущий",
      "документ",
      "скрипты:",
      "ссылается",
      "javascript-код",
      "внешнего",
      "javascript-файла",
      "семантические",
      "теги:",
      "представил",
      "ряд",
      "семантических",
      "тегов",
      "которые",
      "помогают",
      "описывать",
      "структуру",
      "смысл",
      "<article>",
      "<aside>",
      "<details>",
      "<figcaption>",
      "<figure>",
      "<footer>",
      "<header>",
      "<main>",
      "<mark>",
      "<nav>",
      "<section>",
      "<summary>",
      "<time>",
      "важные",
      "атрибуты",
      "(общие",
      "многих",
      "тегов):",
      "class:",
      "класса",
      "(используется",
      "css)",
      "id:",
      "уникальный",
      "идентификатор",
      "css",
      "доступа",
      "элементу",
      "из",
      "javascript)",
      "style:",
      "css-стили",
      "непосредственно",
      "(не",
      "рекомендуется",
      "больших",
      "проектов)",
      "title:",
      "всплывающей",
      "подсказки",
      "которая",
      "отображается",
      "при",
      "наведении",
      "курсора",
      "этот",
      "охватывает",
      "наиболее",
      "часто",
      "используемые",
      "html-теги",
      "получения",
      "более",
      "подробной",
      "информации",
      "каждом",
      "теге",
      "атрибутах",
      "их",
      "использовании",
      "обращаться",
      "документации",
      "mdn",
      "web",
      "docs:",
      "[https://developer",
      "mozilla",
      "org/en-us/docs/web/html/element)",
      "html"
    ],
    "_tags": "api osokinkostyan12 gmail com основные теги кратко структура документа: объявляет тип документа как html5 корневой элемент охватывающий весь html-контент содержит метаданные документе (заголовок стили скрипты задает заголовок страницы отображаемый заголовке окна браузера или вкладке предоставляет такие кодировка описание ключевые слова связывает внешние ресурсы таблицы стилей (css) основной контент пользователю заголовки параграфы: определяют разных уровней (от самого важного до наименее определяет абзац текста форматирование текста: делает текст жирным (bold) *лучше использовать обозначает важный (браузеры обычно отображают его жирным) курсивом (italic) подчеркивает курсивом) вставляет одиночный разрыв строки создает горизонтальную линию контейнер для не имеющий семантического значения используется стилизации части отображает предварительно отформатированный (сохраняет пробелы переносы строк) фрагмент компьютерного кода списки: неупорядоченный список (unordered list) элементы списка отображаются маркерами (например точками) упорядоченный (ordered нумерацией (list item) внутри определений (definition термин списке term) определение термина description) ссылки изображения: гиперссылку (anchor) href: атрибут указывающий url на который ведет ссылка target: определяющий где открыть ссылку _blank открытия новой вкладке) изображение (image) src: изображения alt: предоставляющий альтернативный (важен доступности seo) width: задающий ширину (в пикселях) height: высоту таблицы: таблицу строку (table row) заголовочную ячейку header cell) данных data формы: html-форму ввода пользователем action: будут отправлены данные формы method: http-метод отправки get post) поле (input field) type: поля text password email number checkbox radio submit) name: имя которое сервер value: начальное значение placeholder: текст-подсказку многострочное кнопку выпадающий (dropdown опцию выпадающем подпись (label) элемента for: связывающий элементом (по id) группирует разделы структура: верхнюю часть раздела навигационную панель основное содержание независимую статью запись раздел дополнительный боковую панель) нижнюю (division) html-элементов имеет компоновки элементов медиа: встраивает видео аудио медиа-ресурсы текстовые дорожки (субтитры captions) встраивание контента: другое html-документ текущий документ скрипты: ссылается javascript-код внешнего javascript-файла семантические теги: представил ряд семантических тегов которые помогают описывать структуру смысл <article> <aside> <details> <figcaption> <figure> <footer> <header> <main> <mark> <nav> <section> <summary> <time> важные атрибуты (общие многих тегов): class: класса (используется css) id: уникальный идентификатор css доступа элементу из javascript) style: css-стили непосредственно (не рекомендуется больших проектов) title: всплывающей подсказки которая отображается при наведении курсора этот охватывает наиболее часто используемые html-теги получения более подробной информации каждом теге атрибутах их использовании обращаться документации mdn web docs: [https://developer mozilla org/en-us/docs/web/html/element) html",
    "_version": 1,
    "ignoreHtml": true
  },
  {
    "_id": "68b7325ef63b8048002647b6",
    "title": "Принципы ООП кратко",
    "content": "Объектно-ориентированное программирование (ООП) — это парадигма программирования, которая рассматривает программу как набор взаимодействующих объектов. ООП основана на нескольких ключевых принципах, которые позволяют создавать более модульные, гибкие и поддерживаемые программы. Вот основные принципы ООП:\n\n1. Инкапсуляция (Encapsulation):\n•  Определение: Инкапсуляция — это сокрытие внутренних деталей реализации объекта от внешнего мира. Объект предоставляет интерфейс (набор методов) для взаимодействия с ним, а внутренние данные (атрибуты) и логика работы (методы) скрыты.\n•  Цель:\n  •  Защита данных от несанкционированного доступа и изменения.\n  •  Упрощение использования объекта: пользователю не нужно знать, как объект работает внутри, достаточно знать, как вызвать его методы.\n  •  Гибкость: изменение внутренней реализации объекта не повлияет на код, использующий этот объект, если интерфейс остается прежним.\n•  Реализация: В большинстве языков программирования инкапсуляция реализуется с помощью модификаторов доступа (private, protected, public), которые определяют, какие атрибуты и методы объекта доступны извне.\n\n2. Наследование (Inheritance):\n•  Определение: Наследование — это механизм, позволяющий одному классу (подклассу или дочернему классу) наследовать атрибуты и методы другого класса (суперкласса или родительского класса).\n•  Цель:\n  •  Повторное использование кода: подкласс наследует код суперкласса, что позволяет избежать дублирования.\n  •  Создание иерархии классов: это позволяет организовать классы в логическую структуру, отражающую взаимосвязи между ними.\n  •  Расширяемость: подкласс может добавлять новые атрибуты и методы, а также переопределять унаследованные методы, чтобы адаптировать поведение под свои нужды.\n•  Реализация: В языках программирования используются ключевые слова (например, extends, :) для указания наследования.\n\n3. Полиморфизм (Polymorphism):\n•  Определение: Полиморфизм (многоформенность) — это способность объектов разных классов реагировать на один и тот же метод по-разному.\n•  Типы полиморфизма:\n  •  Полиморфизм времени компиляции (статический полиморфизм, перегрузка методов): Возможность определения нескольких методов с одним и тем же именем, но разными параметрами (типами или количеством). Компилятор определяет, какой метод нужно вызвать, на основе типов аргументов.\n  •  Полиморфизм времени выполнения (динамический полиморфизм, переопределение методов): Подкласс переопределяет метод суперкласса, и во время выполнения программы вызывается метод, соответствующий фактическому типу объекта.\n•  Цель:\n  •  Гибкость: позволяет создавать код, который может работать с объектами разных типов, не зная их конкретных классов.\n  •  Расширяемость: можно легко добавлять новые классы, не изменяя существующий код.\n•  Реализация: Полиморфизм времени выполнения реализуется с помощью виртуальных функций (в C++) или интерфейсов (в Java, C#).\n\n4. Абстракция (Abstraction):\n•  Определение: Абстракция — это выделение существенных характеристик объекта и игнорирование несущественных. Это позволяет упростить представление объекта и сделать его более понятным.\n•  Цель:\n  •  Упрощение: позволяет сфокусироваться на важных аспектах объекта, игнорируя детали реализации.\n  •  Управление сложностью: позволяет разбить сложную систему на более простые и управляемые компоненты.\n  •  Гибкость: можно изменить внутреннюю реализацию объекта без изменения его абстракции.\n•  Реализация: Абстракция реализуется с помощью абстрактных классов и интерфейсов. Абстрактный класс не может быть инстанциирован (нельзя создать его экземпляр) и содержит абстрактные методы (методы без реализации). Интерфейс определяет набор методов, которые должны быть реализованы в любом классе, реализующем этот интерфейс.\n\nДополнительные концепции, связанные с ООП:\n•  Класс (Class): Шаблон или blueprint для создания объектов. Он определяет атрибуты (данные) и методы (поведение) объекта.\n•  Объект (Object): Экземпляр класса.\n•  Метод (Method): Функция, связанная с классом и определяющая поведение объекта.\n•  Атрибут (Attribute): Переменная, связанная с классом и хранящая данные объекта.\n•  Композиция (Composition): Отношение \"has-a\" (имеет) между классами. Объект одного класса содержит объекты других классов как свои части.\n•  Ассоциация (Association): Отношение \"uses-a\" (использует) между классами. Объекты классов связаны между собой, но не являются частями друг друга.\n•  Агрегация (Aggregation): Частный случай ассоциации, когда объекты связаны отношением \"часть-целое\", но целое не владеет частью. Часть может существовать независимо от целого.\n\nПреимущества использования принципов ООП:\n•  Модульность: Программа состоит из независимых объектов, что упрощает разработку, тестирование и отладку.\n•  Переиспользуемость кода: Наследование позволяет повторно использовать код, что сокращает время разработки и уменьшает вероятность ошибок.\n•  Расширяемость: Полиморфизм и абстракция позволяют легко добавлять новые функции и классы, не изменяя существующий код.\n•  Поддерживаемость: ООП делает код более читаемым и понятным, что упрощает его поддержку и изменение.\n•  Реальное моделирование мира: ООП позволяет моделировать реальные объекты и процессы в программном коде.\n\nВ заключение, принципы ООП представляют собой мощный набор инструментов для создания сложных и гибких программных систем. Их понимание и применение является ключевым навыком для любого современного программиста.",
    "group": "ООП",
    "subGroup": "Принципы ООП",
    "ignoreHtml": false,
    "order": 1,
    "imageUrls": "",
    "_created": "2025-09-02T18:07:25.997Z",
    "_changed": "2025-09-04T19:05:32.958Z",
    "_createdby": "api",
    "_changedby": "osokinkostyan12@gmail.com",
    "_keywords": [
      "api",
      "osokinkostyan12",
      "gmail",
      "com",
      "принципы",
      "ооп",
      "кратко",
      "объектно-ориентированное",
      "программирование",
      "(ооп)",
      "это",
      "парадигма",
      "программирования",
      "которая",
      "рассматривает",
      "программу",
      "как",
      "набор",
      "взаимодействующих",
      "объектов",
      "основана",
      "на",
      "нескольких",
      "ключевых",
      "принципах",
      "которые",
      "позволяют",
      "создавать",
      "более",
      "модульные",
      "гибкие",
      "поддерживаемые",
      "программы",
      "вот",
      "основные",
      "ооп:",
      "инкапсуляция",
      "(encapsulation):",
      "определение:",
      "сокрытие",
      "внутренних",
      "деталей",
      "реализации",
      "объекта",
      "от",
      "внешнего",
      "мира",
      "объект",
      "предоставляет",
      "интерфейс",
      "(набор",
      "методов)",
      "для",
      "взаимодействия",
      "ним",
      "внутренние",
      "данные",
      "(атрибуты)",
      "логика",
      "работы",
      "(методы)",
      "скрыты",
      "цель:",
      "защита",
      "данных",
      "несанкционированного",
      "доступа",
      "изменения",
      "упрощение",
      "использования",
      "объекта:",
      "пользователю",
      "не",
      "нужно",
      "знать",
      "работает",
      "внутри",
      "достаточно",
      "вызвать",
      "его",
      "методы",
      "гибкость:",
      "изменение",
      "внутренней",
      "повлияет",
      "код",
      "использующий",
      "этот",
      "если",
      "остается",
      "прежним",
      "реализация:",
      "большинстве",
      "языков",
      "реализуется",
      "помощью",
      "модификаторов",
      "(private",
      "protected",
      "public)",
      "определяют",
      "какие",
      "атрибуты",
      "доступны",
      "извне",
      "наследование",
      "(inheritance):",
      "механизм",
      "позволяющий",
      "одному",
      "классу",
      "(подклассу",
      "или",
      "дочернему",
      "классу)",
      "наследовать",
      "другого",
      "класса",
      "(суперкласса",
      "родительского",
      "класса)",
      "повторное",
      "использование",
      "кода:",
      "подкласс",
      "наследует",
      "суперкласса",
      "что",
      "позволяет",
      "избежать",
      "дублирования",
      "создание",
      "иерархии",
      "классов:",
      "организовать",
      "классы",
      "логическую",
      "структуру",
      "отражающую",
      "взаимосвязи",
      "между",
      "ними",
      "расширяемость:",
      "может",
      "добавлять",
      "новые",
      "также",
      "переопределять",
      "унаследованные",
      "чтобы",
      "адаптировать",
      "поведение",
      "под",
      "свои",
      "нужды",
      "языках",
      "используются",
      "ключевые",
      "слова",
      "(например",
      "extends",
      ":)",
      "указания",
      "наследования",
      "полиморфизм",
      "(polymorphism):",
      "(многоформенность)",
      "способность",
      "разных",
      "классов",
      "реагировать",
      "один",
      "тот",
      "же",
      "метод",
      "по-разному",
      "типы",
      "полиморфизма:",
      "времени",
      "компиляции",
      "(статический",
      "перегрузка",
      "методов):",
      "возможность",
      "определения",
      "методов",
      "одним",
      "тем",
      "именем",
      "но",
      "разными",
      "параметрами",
      "(типами",
      "количеством)",
      "компилятор",
      "определяет",
      "какой",
      "основе",
      "типов",
      "аргументов",
      "выполнения",
      "(динамический",
      "переопределение",
      "переопределяет",
      "во",
      "время",
      "вызывается",
      "соответствующий",
      "фактическому",
      "типу",
      "который",
      "работать",
      "объектами",
      "зная",
      "их",
      "конкретных",
      "можно",
      "легко",
      "изменяя",
      "существующий",
      "виртуальных",
      "функций",
      "(в",
      "c++)",
      "интерфейсов",
      "java",
      "c#)",
      "абстракция",
      "(abstraction):",
      "выделение",
      "существенных",
      "характеристик",
      "игнорирование",
      "несущественных",
      "упростить",
      "представление",
      "сделать",
      "понятным",
      "упрощение:",
      "сфокусироваться",
      "важных",
      "аспектах",
      "игнорируя",
      "детали",
      "управление",
      "сложностью:",
      "разбить",
      "сложную",
      "систему",
      "простые",
      "управляемые",
      "компоненты",
      "изменить",
      "внутреннюю",
      "реализацию",
      "без",
      "абстракции",
      "абстрактных",
      "абстрактный",
      "класс",
      "быть",
      "инстанциирован",
      "(нельзя",
      "создать",
      "экземпляр)",
      "содержит",
      "абстрактные",
      "(методы",
      "реализации)",
      "должны",
      "реализованы",
      "любом",
      "классе",
      "реализующем",
      "дополнительные",
      "концепции",
      "связанные",
      "(class):",
      "шаблон",
      "blueprint",
      "создания",
      "он",
      "(данные)",
      "(поведение)",
      "(object):",
      "экземпляр",
      "(method):",
      "функция",
      "связанная",
      "классом",
      "определяющая",
      "атрибут",
      "(attribute):",
      "переменная",
      "хранящая",
      "композиция",
      "(composition):",
      "отношение",
      "\"has-a\"",
      "(имеет)",
      "классами",
      "одного",
      "объекты",
      "других",
      "части",
      "ассоциация",
      "(association):",
      "\"uses-a\"",
      "(использует)",
      "связаны",
      "собой",
      "являются",
      "частями",
      "друг",
      "друга",
      "агрегация",
      "(aggregation):",
      "частный",
      "случай",
      "ассоциации",
      "когда",
      "отношением",
      "\"часть-целое\"",
      "целое",
      "владеет",
      "частью",
      "часть",
      "существовать",
      "независимо",
      "целого",
      "преимущества",
      "принципов",
      "модульность:",
      "программа",
      "состоит",
      "из",
      "независимых",
      "упрощает",
      "разработку",
      "тестирование",
      "отладку",
      "переиспользуемость",
      "повторно",
      "использовать",
      "сокращает",
      "разработки",
      "уменьшает",
      "вероятность",
      "ошибок",
      "функции",
      "поддерживаемость:",
      "делает",
      "читаемым",
      "поддержку",
      "реальное",
      "моделирование",
      "мира:",
      "моделировать",
      "реальные",
      "процессы",
      "программном",
      "коде",
      "заключение",
      "представляют",
      "мощный",
      "инструментов",
      "сложных",
      "гибких",
      "программных",
      "систем",
      "понимание",
      "применение",
      "является",
      "ключевым",
      "навыком",
      "любого",
      "современного",
      "программиста"
    ],
    "_tags": "api osokinkostyan12 gmail com принципы ооп кратко объектно-ориентированное программирование (ооп) это парадигма программирования которая рассматривает программу как набор взаимодействующих объектов основана на нескольких ключевых принципах которые позволяют создавать более модульные гибкие поддерживаемые программы вот основные ооп: инкапсуляция (encapsulation): определение: сокрытие внутренних деталей реализации объекта от внешнего мира объект предоставляет интерфейс (набор методов) для взаимодействия ним внутренние данные (атрибуты) логика работы (методы) скрыты цель: защита данных несанкционированного доступа изменения упрощение использования объекта: пользователю не нужно знать работает внутри достаточно вызвать его методы гибкость: изменение внутренней повлияет код использующий этот если остается прежним реализация: большинстве языков реализуется помощью модификаторов (private protected public) определяют какие атрибуты доступны извне наследование (inheritance): механизм позволяющий одному классу (подклассу или дочернему классу) наследовать другого класса (суперкласса родительского класса) повторное использование кода: подкласс наследует суперкласса что позволяет избежать дублирования создание иерархии классов: организовать классы логическую структуру отражающую взаимосвязи между ними расширяемость: может добавлять новые также переопределять унаследованные чтобы адаптировать поведение под свои нужды языках используются ключевые слова (например extends :) указания наследования полиморфизм (polymorphism): (многоформенность) способность разных классов реагировать один тот же метод по-разному типы полиморфизма: времени компиляции (статический перегрузка методов): возможность определения методов одним тем именем но разными параметрами (типами количеством) компилятор определяет какой основе типов аргументов выполнения (динамический переопределение переопределяет во время вызывается соответствующий фактическому типу который работать объектами зная их конкретных можно легко изменяя существующий виртуальных функций (в c++) интерфейсов java c#) абстракция (abstraction): выделение существенных характеристик игнорирование несущественных упростить представление сделать понятным упрощение: сфокусироваться важных аспектах игнорируя детали управление сложностью: разбить сложную систему простые управляемые компоненты изменить внутреннюю реализацию без абстракции абстрактных абстрактный класс быть инстанциирован (нельзя создать экземпляр) содержит абстрактные (методы реализации) должны реализованы любом классе реализующем дополнительные концепции связанные (class): шаблон blueprint создания он (данные) (поведение) (object): экземпляр (method): функция связанная классом определяющая атрибут (attribute): переменная хранящая композиция (composition): отношение \"has-a\" (имеет) классами одного объекты других части ассоциация (association): \"uses-a\" (использует) связаны собой являются частями друг друга агрегация (aggregation): частный случай ассоциации когда отношением \"часть-целое\" целое владеет частью часть существовать независимо целого преимущества принципов модульность: программа состоит из независимых упрощает разработку тестирование отладку переиспользуемость повторно использовать сокращает разработки уменьшает вероятность ошибок функции поддерживаемость: делает читаемым поддержку реальное моделирование мира: моделировать реальные процессы программном коде заключение представляют мощный инструментов сложных гибких программных систем понимание применение является ключевым навыком любого современного программиста",
    "_version": 2,
    "editing": false
  },
  {
    "_id": "68e4f4810d20f72500025327",
    "title": "Change detection стратегии",
    "content": "Стратегии Change Detection в Angular: OnPush vs. Default\n\nВ Angular, механизм обнаружения изменений (Change Detection) играет важную роль в обновлении DOM, когда данные в компоненте меняются. Angular предоставляет две основные стратегии change detection: Default и OnPush. Понимание разницы между ними критично для оптимизации производительности вашего приложения.\n\n1. Default Change Detection Strategy (по умолчанию)\n• Как работает: Angular запускает процесс change detection для каждого компонента в дереве компонентов каждый раз, когда происходит какое-либо событие. Эти события могут быть:\n  * Действия пользователя (клики, нажатия клавиш и т.д.)\n  * HTTP-запросы\n  * Таймеры ( setTimeout, setInterval )\n  * Асинхронные операции (Observables, Promises)\n• Что происходит: Angular проверяет, изменились ли какие-либо свойства компонента. Если изменение обнаружено, шаблон компонента (DOM) обновляется. Этот процесс проходит по всему дереву компонентов, начиная с корневого компонента.\n• Преимущества:\n  * Простота: Это стратегия по умолчанию, и она работает \"из коробки\" без дополнительной настройки.\n  * Гибкость: Подходит для большинства сценариев, особенно когда компоненты часто изменяются.\n• Недостатки:\n  * Производительность: Change detection запускается очень часто, даже если данные не изменились. Это может привести к значительным затратам ресурсов, особенно в больших и сложных приложениях.\n  * Ненужные обновления DOM: Компоненты могут перерисовываться, даже если их данные не изменились, что влияет на производительность.\n\n2. OnPush Change Detection Strategy\n• Как работает: OnPush change detection значительно оптимизирует процесс обновления. Angular будет проверять компонент только в следующих случаях:\n  * Изменился входной параметр (@Input): Свойство, помеченное декоратором @Input(), получило новое значение. Важно: изменение должно быть ссылочным (новый объект), а не мутацией существующего объекта.\n  * Сработал event handler: В шаблоне компонента произошло событие (клик, изменение значения и т.д.), которое вызвало метод компонента.\n  * Сработал Observable: Компонент подписан на Observable, который эмитировал новое значение. При этом важно использовать async pipe в шаблоне или явно вызывать detectChanges() в компоненте.\n  * Сработал ChangeDetectorRef.detectChanges(): Вызван метод detectChanges() в компоненте вручную. Это позволяет вам явно запускать change detection для конкретного компонента.\n• Преимущества:\n  * Производительность: Значительно снижает количество запусков change detection, что приводит к повышению производительности приложения.\n  * Контроль: Дает больше контроля над процессом обновления.\n• Недостатки:\n  * Сложность: Требует более внимательного управления данными и понимания, когда и как происходят изменения.\n  * Необходимость использовать immutability: Для эффективной работы OnPush необходимо использовать immutable data structures (например, объекты, которые нельзя изменять после создания). Вместо изменения объекта создается его новая копия с измененными данными.\n  * Необходимость использовать async pipe или detectChanges(): При работе с Observables необходимо либо использовать async pipe в шаблоне, либо вызывать detectChanges() вручную, чтобы компонент перерисовывался при получении нового значения от Observable.\n\nКак использовать OnPush:\nВ компоненте, который вы хотите оптимизировать, добавьте свойство changeDetection в декоратор @Component:\n<pre><code>\nimport { Component, Input, ChangeDetectionStrategy } from '@angular/core';\n\n@Component({\n  selector: 'app-my-component',\n  templateUrl: './my-component.component.html',\n  styleUrls: ['./my-component.component.css'],\n  changeDetection: ChangeDetectionStrategy.OnPush // Включаем OnPush\n})\nexport class MyComponentComponent {\n  @Input() data: any; // Входной параметр\n}\n</pre></code>\nПримеры и сценарии:\n\n• Компонент отображает статические данные: Если компонент просто отображает данные, которые не меняются после инициализации, OnPush - отличный выбор.\n• Компонент получает данные от родительского компонента через @Input: Если родительский компонент передает новые значения в компонент через @Input, OnPush будет проверять компонент только тогда, когда ссылка на входной объект изменится. Важно, чтобы родительский компонент передавал новый объект, а не мутировал существующий.\n• Компонент подписывается на Observable: Необходимо использовать async pipe в шаблоне:\n   <pre><code><p>{{ myObservable$ | async }}</p>\nИли вызвать ChangeDetectorRef.detectChanges() вручную в компоненте:\n\n   import { Component, ChangeDetectionStrategy, ChangeDetectorRef } from '@angular/core';\n   import { MyService } from './my.service';\n\n   @Component({\n     selector: 'app-my-component',\n     templateUrl: './my-component.component.html',\n     styleUrls: ['./my-component.component.css'],\n     changeDetection: ChangeDetectionStrategy.OnPush\n   })\n   export class MyComponentComponent {\n     data: any;\n\n     constructor(private myService: MyService, private cdr: ChangeDetectorRef) {\n       this.myService.getData().subscribe(data => {\n         this.data = data;\n         this.cdr.detectChanges(); // Запускаем change detection вручную\n       });\n     }\n   }\n</pre></code>\n\nBest Practices для OnPush:\n\n• Используйте Immutable Data Structures: Объекты должны быть неизменяемыми. Используйте библиотеки, такие как Immutable.js или Immer.js, чтобы упростить работу с immutable данными. Вместо изменения объекта, создавайте его копию с новыми значениями.\n• Observable Streams: Используйте RxJS Observables для работы с асинхронными данными и событиями. Используйте async pipe в шаблоне или явно вызывайте detectChanges().\n• Чистые функции (Pure Functions): Используйте чистые функции, которые всегда возвращают один и тот же результат для одних и тех же входных данных и не имеют побочных эффектов. Это упрощает отладку и понимание поведения компонента.\n• Оптимизируйте родительские компоненты: OnPush эффективен, только если родительские компоненты также оптимизированы и не запускают ненужный change detection.\n\nВывод:\n\nВыбор стратегии change detection зависит от конкретной ситуации. Default подходит для небольших и простых приложений, где производительность не является критичным фактором. OnPush необходим для больших и сложных приложений, где требуется оптимизировать производительность. В большинстве случаев, рекомендуется начинать с Default и переходить на OnPush для компонентов, которые оказывают наибольшее влияние на производительность приложения. Анализируйте performance приложения с помощью Angular DevTools и принимайте решения на основе данных.",
    "group": "Вопросы с собеседований",
    "subGroup": "Selectel",
    "ignoreHtml": false,
    "order": 1,
    "_created": "2025-10-07T11:07:45.539Z",
    "_changed": "2025-10-07T11:07:45.539Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "change",
      "detection",
      "стратегии",
      "angular:",
      "onpush",
      "vs",
      "default",
      "angular",
      "механизм",
      "обнаружения",
      "изменений",
      "(change",
      "detection)",
      "играет",
      "важную",
      "роль",
      "обновлении",
      "dom",
      "когда",
      "данные",
      "компоненте",
      "меняются",
      "предоставляет",
      "две",
      "основные",
      "detection:",
      "понимание",
      "разницы",
      "между",
      "ними",
      "критично",
      "для",
      "оптимизации",
      "производительности",
      "вашего",
      "приложения",
      "strategy",
      "(по",
      "умолчанию)",
      "как",
      "работает:",
      "запускает",
      "процесс",
      "каждого",
      "компонента",
      "дереве",
      "компонентов",
      "каждый",
      "раз",
      "происходит",
      "какое-либо",
      "событие",
      "эти",
      "события",
      "могут",
      "быть:",
      "действия",
      "пользователя",
      "(клики",
      "нажатия",
      "клавиш",
      "http-запросы",
      "таймеры",
      "settimeout",
      "setinterval",
      "асинхронные",
      "операции",
      "(observables",
      "promises)",
      "что",
      "происходит:",
      "проверяет",
      "изменились",
      "ли",
      "какие-либо",
      "свойства",
      "если",
      "изменение",
      "обнаружено",
      "шаблон",
      "(dom)",
      "обновляется",
      "этот",
      "проходит",
      "по",
      "всему",
      "дереву",
      "начиная",
      "корневого",
      "преимущества:",
      "простота:",
      "это",
      "стратегия",
      "умолчанию",
      "она",
      "работает",
      "\"из",
      "коробки\"",
      "без",
      "дополнительной",
      "настройки",
      "гибкость:",
      "подходит",
      "большинства",
      "сценариев",
      "особенно",
      "компоненты",
      "часто",
      "изменяются",
      "недостатки:",
      "производительность:",
      "запускается",
      "очень",
      "даже",
      "не",
      "может",
      "привести",
      "значительным",
      "затратам",
      "ресурсов",
      "больших",
      "сложных",
      "приложениях",
      "ненужные",
      "обновления",
      "dom:",
      "перерисовываться",
      "их",
      "влияет",
      "на",
      "производительность",
      "значительно",
      "оптимизирует",
      "будет",
      "проверять",
      "компонент",
      "только",
      "следующих",
      "случаях:",
      "изменился",
      "входной",
      "параметр",
      "input):",
      "свойство",
      "помеченное",
      "декоратором",
      "input()",
      "получило",
      "новое",
      "значение",
      "важно:",
      "должно",
      "быть",
      "ссылочным",
      "(новый",
      "объект)",
      "мутацией",
      "существующего",
      "объекта",
      "сработал",
      "event",
      "handler:",
      "шаблоне",
      "произошло",
      "(клик",
      "значения",
      "которое",
      "вызвало",
      "метод",
      "observable:",
      "подписан",
      "observable",
      "который",
      "эмитировал",
      "при",
      "этом",
      "важно",
      "использовать",
      "async",
      "pipe",
      "или",
      "явно",
      "вызывать",
      "detectchanges()",
      "changedetectorref",
      "detectchanges():",
      "вызван",
      "вручную",
      "позволяет",
      "вам",
      "запускать",
      "конкретного",
      "снижает",
      "количество",
      "запусков",
      "приводит",
      "повышению",
      "контроль:",
      "дает",
      "больше",
      "контроля",
      "над",
      "процессом",
      "сложность:",
      "требует",
      "более",
      "внимательного",
      "управления",
      "данными",
      "понимания",
      "происходят",
      "изменения",
      "необходимость",
      "immutability:",
      "эффективной",
      "работы",
      "необходимо",
      "immutable",
      "data",
      "structures",
      "(например",
      "объекты",
      "которые",
      "нельзя",
      "изменять",
      "после",
      "создания)",
      "вместо",
      "создается",
      "его",
      "новая",
      "копия",
      "измененными",
      "работе",
      "observables",
      "либо",
      "чтобы",
      "перерисовывался",
      "получении",
      "нового",
      "от",
      "onpush:",
      "вы",
      "хотите",
      "оптимизировать",
      "добавьте",
      "changedetection",
      "декоратор",
      "component:",
      "import",
      "component",
      "input",
      "changedetectionstrategy",
      "from",
      "angular/core';",
      "component({",
      "selector:",
      "'app-my-component'",
      "templateurl:",
      "/my-component",
      "html'",
      "styleurls:",
      "['",
      "css']",
      "changedetection:",
      "//",
      "включаем",
      "})",
      "export",
      "class",
      "mycomponentcomponent",
      "data:",
      "any;",
      "примеры",
      "сценарии:",
      "отображает",
      "статические",
      "данные:",
      "просто",
      "инициализации",
      "отличный",
      "выбор",
      "получает",
      "родительского",
      "через",
      "input:",
      "родительский",
      "передает",
      "новые",
      "тогда",
      "ссылка",
      "объект",
      "изменится",
      "передавал",
      "новый",
      "мутировал",
      "существующий",
      "подписывается",
      "шаблоне:",
      "{{",
      "myobservable$",
      "}}",
      "вызвать",
      "компоненте:",
      "myservice",
      "/my",
      "service';",
      "constructor(private",
      "myservice:",
      "private",
      "cdr:",
      "changedetectorref)",
      "this",
      "getdata()",
      "subscribe(data",
      "=>",
      "data;",
      "cdr",
      "detectchanges();",
      "запускаем",
      "});",
      "best",
      "practices",
      "используйте",
      "structures:",
      "должны",
      "неизменяемыми",
      "библиотеки",
      "такие",
      "js",
      "immer",
      "упростить",
      "работу",
      "создавайте",
      "копию",
      "новыми",
      "значениями",
      "streams:",
      "rxjs",
      "асинхронными",
      "событиями",
      "вызывайте",
      "чистые",
      "функции",
      "(pure",
      "functions):",
      "всегда",
      "возвращают",
      "один",
      "тот",
      "же",
      "результат",
      "одних",
      "тех",
      "входных",
      "данных",
      "имеют",
      "побочных",
      "эффектов",
      "упрощает",
      "отладку",
      "поведения",
      "оптимизируйте",
      "родительские",
      "компоненты:",
      "эффективен",
      "также",
      "оптимизированы",
      "запускают",
      "ненужный",
      "вывод:",
      "зависит",
      "конкретной",
      "ситуации",
      "небольших",
      "простых",
      "приложений",
      "где",
      "является",
      "критичным",
      "фактором",
      "необходим",
      "требуется",
      "большинстве",
      "случаев",
      "рекомендуется",
      "начинать",
      "переходить",
      "оказывают",
      "наибольшее",
      "влияние",
      "анализируйте",
      "performance",
      "помощью",
      "devtools",
      "принимайте",
      "решения",
      "основе",
      "вопросы",
      "собеседований",
      "selectel"
    ],
    "_tags": "api change detection стратегии angular: onpush vs default angular механизм обнаружения изменений (change detection) играет важную роль обновлении dom когда данные компоненте меняются предоставляет две основные detection: понимание разницы между ними критично для оптимизации производительности вашего приложения strategy (по умолчанию) как работает: запускает процесс каждого компонента дереве компонентов каждый раз происходит какое-либо событие эти события могут быть: действия пользователя (клики нажатия клавиш http-запросы таймеры settimeout setinterval асинхронные операции (observables promises) что происходит: проверяет изменились ли какие-либо свойства если изменение обнаружено шаблон (dom) обновляется этот проходит по всему дереву начиная корневого преимущества: простота: это стратегия умолчанию она работает \"из коробки\" без дополнительной настройки гибкость: подходит большинства сценариев особенно компоненты часто изменяются недостатки: производительность: запускается очень даже не может привести значительным затратам ресурсов больших сложных приложениях ненужные обновления dom: перерисовываться их влияет на производительность значительно оптимизирует будет проверять компонент только следующих случаях: изменился входной параметр input): свойство помеченное декоратором input() получило новое значение важно: должно быть ссылочным (новый объект) мутацией существующего объекта сработал event handler: шаблоне произошло (клик значения которое вызвало метод observable: подписан observable который эмитировал при этом важно использовать async pipe или явно вызывать detectchanges() changedetectorref detectchanges(): вызван вручную позволяет вам запускать конкретного снижает количество запусков приводит повышению контроль: дает больше контроля над процессом сложность: требует более внимательного управления данными понимания происходят изменения необходимость immutability: эффективной работы необходимо immutable data structures (например объекты которые нельзя изменять после создания) вместо создается его новая копия измененными работе observables либо чтобы перерисовывался получении нового от onpush: вы хотите оптимизировать добавьте changedetection декоратор component: import component input changedetectionstrategy from angular/core'; component({ selector: 'app-my-component' templateurl: /my-component html' styleurls: [' css'] changedetection: // включаем }) export class mycomponentcomponent data: any; примеры сценарии: отображает статические данные: просто инициализации отличный выбор получает родительского через input: родительский передает новые тогда ссылка объект изменится передавал новый мутировал существующий подписывается шаблоне: {{ myobservable$ }} вызвать компоненте: myservice /my service'; constructor(private myservice: private cdr: changedetectorref) this getdata() subscribe(data => data; cdr detectchanges(); запускаем }); best practices используйте structures: должны неизменяемыми библиотеки такие js immer упростить работу создавайте копию новыми значениями streams: rxjs асинхронными событиями вызывайте чистые функции (pure functions): всегда возвращают один тот же результат одних тех входных данных имеют побочных эффектов упрощает отладку поведения оптимизируйте родительские компоненты: эффективен также оптимизированы запускают ненужный вывод: зависит конкретной ситуации небольших простых приложений где является критичным фактором необходим требуется большинстве случаев рекомендуется начинать переходить оказывают наибольшее влияние анализируйте performance помощью devtools принимайте решения основе вопросы собеседований selectel",
    "_version": 0
  },
  {
    "_id": "68b89b0ef63b8048002664c1",
    "title": "Интерсепторы в Angular: Мощный Инструмент для Управления HTTP-Запросами",
    "content": "<b>Интерсепторы (Interceptors) в Angular</b> – это мощный механизм, который позволяет перехватывать и модифицировать HTTP-запросы и ответы, прежде чем они будут отправлены или обработаны. Они действуют как middleware для HTTP-коммуникаций, предоставляя вам централизованный способ для добавления логики, такой как:\n•   Добавление заголовков авторизации\n•   Логирование запросов и ответов\n•   Обработка ошибок\n•   Преобразование данных\n•   Кэширование\n\nКак работают интерсепторы:\n1.  Когда компонент или сервис Angular делает HTTP-запрос, этот запрос проходит через цепочку интерсепторов.\n2.  Каждый интерсептор в цепочке имеет возможность:\n    *   Перехватить запрос и выполнить какие-либо действия (например, добавить заголовок).\n    *   Передать запрос следующему интерсептору в цепочке.\n    *   Заблокировать запрос (например, если пользователь не авторизован).\n3.  После того как запрос прошел через все интерсепторы, он отправляется на сервер.\n4.  Когда сервер возвращает ответ, ответ снова проходит через цепочку интерсепторов, но уже в обратном порядке.\n5.  Каждый интерсептор может перехватить ответ и выполнить какие-либо действия (например, обработать ошибку или преобразовать данные).\n6.  После того как ответ прошел через все интерсепторы, он возвращается компоненту или сервису, который сделал запрос.\n\nСоздание интерсептора:\nЧтобы создать интерсептор в Angular, вам нужно:\n1.  Создать класс, который реализует интерфейс HttpInterceptor из пакета @angular/common/http.\n2.  Реализовать метод intercept(), который принимает два аргумента:\n    *   request: HttpRequest<any>: Объект HTTP-запроса.\n    *   next: HttpHandler: Объект, представляющий следующий интерсептор в цепочке.  Вы должны вызвать next.handle(modifiedRequest) чтобы продолжить обработку запроса.\n3.  Зарегистрировать интерсептор в качестве провайдера в модуле Angular.\n\nПример интерсептора для добавления заголовка авторизации:\n <p><img src=\"https://ik.imagekit.io/ygtb3rzhz/interceptor%20ex.png?updatedAt=1756929439031\" alt=\"В\" style=\"max-width: 100%;\"></p> \nРегистрация интерсептора в AppModule (или другом модуле):\nimport { AuthInterceptor } from './auth.interceptor';\n******\nproviders: [\n    {\n      provide: HTTP_INTERCEPTORS,\n      useClass: AuthInterceptor,\n      multi: true // Важно указать multi: true, чтобы можно было зарегистрировать несколько интерсепторов\n    }\n  ],\nОбъяснение:\n•   @Injectable(): Декоратор, указывающий, что класс AuthInterceptor может принимать зависимости через конструктор (в данном случае AuthService).\n•   implements HttpInterceptor:  Класс должен реализовать интерфейс HttpInterceptor.\n•   intercept(request: HttpRequest<any>, next: HttpHandler): Observable<any>: Основной метод, который перехватывает HTTP-запросы.\n    *   request:  Объект HttpRequest, представляющий перехваченный запрос.  Он неизменяем, поэтому для добавления заголовков нужно клонировать его с помощью request.clone().\n    *   next:  Объект HttpHandler, представляющий следующий интерсептор в цепочке.  Вызов next.handle(request) или next.handle(clonedRequest) передает управление следующему интерсептору (или, если это последний интерсептор, отправляет запрос на сервер).  handle() возвращает Observable, который испускает ответ.\n•   providers: [...]: В массиве providers модуля мы регистрируем AuthInterceptor как HTTP-интерсептор.\n    *   provide: HTTP_INTERCEPTORS:  Ключ, указывающий, что мы предоставляем интерсептор.\n    *   useClass: AuthInterceptor: Класс интерсептора, который нужно использовать.\n    *   multi: true:  Очень важно указать multi: true, чтобы Angular знал, что это один из нескольких интерсепторов, которые должны быть применены. Если не указать multi: true, ваш интерсептор перезапишет все предыдущие интерсепторы.\n•   Клонирование запроса:  Объект HttpRequest является *неизменяемым*.  Чтобы изменить запрос (например, добавить заголовок), необходимо клонировать его с помощью request.clone().  Это создает новый объект HttpRequest с внесенными изменениями.\n\nПреимущества использования интерсепторов:\n•   Централизованная логика: Вы можете реализовать общие задачи (например, добавление заголовков авторизации, обработку ошибок) в одном месте, а не повторять код в каждом компоненте или сервисе.\n•   Уменьшение дублирования кода: Интерсепторы позволяют избежать дублирования кода, что упрощает поддержку и изменение приложения.\n•   Улучшенная тестируемость: Интерсепторы можно легко протестировать изолированно, что повышает надежность приложения.\n•   Модульность: Интерсепторы позволяют создавать модульные и переиспользуемые компоненты, которые можно легко подключать и отключать.\n•   Глобальное управление:  Они дают возможность глобально управлять HTTP-запросами и ответами, что полезно для таких задач, как логирование, кэширование и обработка ошибок.\n\nПримеры использования интерсепторов:\n•   Авторизация: Добавление заголовков авторизации (например, Authorization: Bearer <token>) ко всем исходящим запросам.\n•   Логирование: Логирование времени выполнения запросов, URL, заголовков и содержимого ответов.\n•   Обработка ошибок: Перехват ошибок HTTP и отображение пользовательских сообщений об ошибках.\n•   Преобразование данных: Преобразование данных запроса перед отправкой на сервер (например, сериализация объектов в JSON) или преобразование данных ответа перед использованием в компоненте.\n•   Кэширование: Кэширование ответов от сервера для повышения производительности.\n•   Добавление заголовков: Добавление общих заголовков, таких как Content-Type или Accept-Language.\n•   Обработка токенов: Обновление устаревших токенов авторизации.\n\nКогда использовать интерсепторы:\n•   Когда вам нужно применить общую логику ко всем или нескольким HTTP-запросам.\n•   Когда вам нужно изменить запросы или ответы до их отправки или обработки.\n•   Когда вам нужно централизовать управление HTTP-коммуникациями.\n\nКогда *не* использовать интерсепторы:\n•   Для задач, которые относятся только к одному конкретному компоненту или сервису. В этом случае лучше использовать локальные методы и функции.\n•   Для сложной бизнес-логики, которая не связана с HTTP-коммуникациями.\n\nЗаключение:\nИнтерсепторы – это мощный и гибкий инструмент, который позволяет улучшить структуру, поддерживаемость и расширяемость Angular-приложений. Понимание и использование интерсепторов является важным навыком для любого Angular-разработчика. Правильное применение интерсепторов позволяет значительно упростить разработку и поддержку сложных веб-приложений.",
    "group": "Angular",
    "subGroup": "Angular Deep",
    "ignoreHtml": false,
    "order": 1,
    "imageUrls": "",
    "_created": "2025-09-03T19:46:22.064Z",
    "_changed": "2025-09-03T19:46:22.064Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "интерсепторы",
      "angular:",
      "мощный",
      "инструмент",
      "для",
      "управления",
      "http-запросами",
      "(interceptors)",
      "angular",
      "это",
      "механизм",
      "который",
      "позволяет",
      "перехватывать",
      "модифицировать",
      "http-запросы",
      "ответы",
      "прежде",
      "чем",
      "они",
      "будут",
      "отправлены",
      "или",
      "обработаны",
      "действуют",
      "как",
      "middleware",
      "http-коммуникаций",
      "предоставляя",
      "вам",
      "централизованный",
      "способ",
      "добавления",
      "логики",
      "такой",
      "как:",
      "добавление",
      "заголовков",
      "авторизации",
      "логирование",
      "запросов",
      "ответов",
      "обработка",
      "ошибок",
      "преобразование",
      "данных",
      "кэширование",
      "работают",
      "интерсепторы:",
      "когда",
      "компонент",
      "сервис",
      "делает",
      "http-запрос",
      "этот",
      "запрос",
      "проходит",
      "через",
      "цепочку",
      "интерсепторов",
      "каждый",
      "интерсептор",
      "цепочке",
      "имеет",
      "возможность:",
      "перехватить",
      "выполнить",
      "какие-либо",
      "действия",
      "(например",
      "добавить",
      "заголовок)",
      "передать",
      "следующему",
      "интерсептору",
      "заблокировать",
      "если",
      "пользователь",
      "не",
      "авторизован)",
      "после",
      "того",
      "прошел",
      "все",
      "он",
      "отправляется",
      "на",
      "сервер",
      "возвращает",
      "ответ",
      "снова",
      "но",
      "уже",
      "обратном",
      "порядке",
      "может",
      "обработать",
      "ошибку",
      "преобразовать",
      "данные)",
      "возвращается",
      "компоненту",
      "сервису",
      "сделал",
      "создание",
      "интерсептора:",
      "чтобы",
      "создать",
      "нужно:",
      "класс",
      "реализует",
      "интерфейс",
      "httpinterceptor",
      "из",
      "пакета",
      "angular/common/http",
      "реализовать",
      "метод",
      "intercept()",
      "принимает",
      "два",
      "аргумента:",
      "request:",
      "httprequest:",
      "объект",
      "http-запроса",
      "next:",
      "httphandler:",
      "представляющий",
      "следующий",
      "вы",
      "должны",
      "вызвать",
      "next",
      "handle(modifiedrequest)",
      "продолжить",
      "обработку",
      "запроса",
      "зарегистрировать",
      "качестве",
      "провайдера",
      "модуле",
      "пример",
      "интерсептора",
      "заголовка",
      "авторизации:",
      "регистрация",
      "appmodule",
      "(или",
      "другом",
      "модуле):",
      "import",
      "authinterceptor",
      "from",
      "/auth",
      "interceptor';",
      "******",
      "providers:",
      "provide:",
      "http_interceptors",
      "useclass:",
      "multi:",
      "true",
      "//",
      "важно",
      "указать",
      "можно",
      "было",
      "несколько",
      "объяснение:",
      "injectable():",
      "декоратор",
      "указывающий",
      "что",
      "принимать",
      "зависимости",
      "конструктор",
      "(в",
      "данном",
      "случае",
      "authservice)",
      "implements",
      "httpinterceptor:",
      "должен",
      "intercept(request:",
      "httprequest",
      "httphandler):",
      "observable:",
      "основной",
      "перехватывает",
      "перехваченный",
      "неизменяем",
      "поэтому",
      "нужно",
      "клонировать",
      "его",
      "помощью",
      "request",
      "clone()",
      "httphandler",
      "вызов",
      "handle(request)",
      "handle(clonedrequest)",
      "передает",
      "управление",
      "последний",
      "отправляет",
      "сервер)",
      "handle()",
      "observable",
      "испускает",
      "]:",
      "массиве",
      "providers",
      "модуля",
      "мы",
      "регистрируем",
      "http-интерсептор",
      "http_interceptors:",
      "ключ",
      "предоставляем",
      "authinterceptor:",
      "использовать",
      "true:",
      "очень",
      "знал",
      "один",
      "нескольких",
      "которые",
      "быть",
      "применены",
      "ваш",
      "перезапишет",
      "предыдущие",
      "клонирование",
      "запроса:",
      "является",
      "*неизменяемым*",
      "изменить",
      "необходимо",
      "создает",
      "новый",
      "внесенными",
      "изменениями",
      "преимущества",
      "использования",
      "интерсепторов:",
      "централизованная",
      "логика:",
      "можете",
      "общие",
      "задачи",
      "ошибок)",
      "одном",
      "месте",
      "повторять",
      "код",
      "каждом",
      "компоненте",
      "сервисе",
      "уменьшение",
      "дублирования",
      "кода:",
      "позволяют",
      "избежать",
      "кода",
      "упрощает",
      "поддержку",
      "изменение",
      "приложения",
      "улучшенная",
      "тестируемость:",
      "легко",
      "протестировать",
      "изолированно",
      "повышает",
      "надежность",
      "модульность:",
      "создавать",
      "модульные",
      "переиспользуемые",
      "компоненты",
      "подключать",
      "отключать",
      "глобальное",
      "управление:",
      "дают",
      "возможность",
      "глобально",
      "управлять",
      "ответами",
      "полезно",
      "таких",
      "задач",
      "примеры",
      "авторизация:",
      "authorization:",
      "bearer",
      "ко",
      "всем",
      "исходящим",
      "запросам",
      "логирование:",
      "времени",
      "выполнения",
      "url",
      "содержимого",
      "ошибок:",
      "перехват",
      "http",
      "отображение",
      "пользовательских",
      "сообщений",
      "об",
      "ошибках",
      "данных:",
      "перед",
      "отправкой",
      "сериализация",
      "объектов",
      "json)",
      "ответа",
      "использованием",
      "кэширование:",
      "от",
      "сервера",
      "повышения",
      "производительности",
      "заголовков:",
      "общих",
      "content-type",
      "accept-language",
      "токенов:",
      "обновление",
      "устаревших",
      "токенов",
      "применить",
      "общую",
      "логику",
      "нескольким",
      "http-запросам",
      "запросы",
      "до",
      "их",
      "отправки",
      "обработки",
      "централизовать",
      "http-коммуникациями",
      "*не*",
      "относятся",
      "только",
      "одному",
      "конкретному",
      "этом",
      "лучше",
      "локальные",
      "методы",
      "функции",
      "сложной",
      "бизнес-логики",
      "которая",
      "связана",
      "заключение:",
      "гибкий",
      "улучшить",
      "структуру",
      "поддерживаемость",
      "расширяемость",
      "angular-приложений",
      "понимание",
      "использование",
      "важным",
      "навыком",
      "любого",
      "angular-разработчика",
      "правильное",
      "применение",
      "значительно",
      "упростить",
      "разработку",
      "сложных",
      "веб-приложений",
      "deep"
    ],
    "_tags": "api интерсепторы angular: мощный инструмент для управления http-запросами (interceptors) angular это механизм который позволяет перехватывать модифицировать http-запросы ответы прежде чем они будут отправлены или обработаны действуют как middleware http-коммуникаций предоставляя вам централизованный способ добавления логики такой как: добавление заголовков авторизации логирование запросов ответов обработка ошибок преобразование данных кэширование работают интерсепторы: когда компонент сервис делает http-запрос этот запрос проходит через цепочку интерсепторов каждый интерсептор цепочке имеет возможность: перехватить выполнить какие-либо действия (например добавить заголовок) передать следующему интерсептору заблокировать если пользователь не авторизован) после того прошел все он отправляется на сервер возвращает ответ снова но уже обратном порядке может обработать ошибку преобразовать данные) возвращается компоненту сервису сделал создание интерсептора: чтобы создать нужно: класс реализует интерфейс httpinterceptor из пакета angular/common/http реализовать метод intercept() принимает два аргумента: request: httprequest: объект http-запроса next: httphandler: представляющий следующий вы должны вызвать next handle(modifiedrequest) продолжить обработку запроса зарегистрировать качестве провайдера модуле пример интерсептора заголовка авторизации: регистрация appmodule (или другом модуле): import authinterceptor from /auth interceptor'; ****** providers: provide: http_interceptors useclass: multi: true // важно указать можно было несколько объяснение: injectable(): декоратор указывающий что принимать зависимости конструктор (в данном случае authservice) implements httpinterceptor: должен intercept(request: httprequest httphandler): observable: основной перехватывает перехваченный неизменяем поэтому нужно клонировать его помощью request clone() httphandler вызов handle(request) handle(clonedrequest) передает управление последний отправляет сервер) handle() observable испускает ]: массиве providers модуля мы регистрируем http-интерсептор http_interceptors: ключ предоставляем authinterceptor: использовать true: очень знал один нескольких которые быть применены ваш перезапишет предыдущие клонирование запроса: является *неизменяемым* изменить необходимо создает новый внесенными изменениями преимущества использования интерсепторов: централизованная логика: можете общие задачи ошибок) одном месте повторять код каждом компоненте сервисе уменьшение дублирования кода: позволяют избежать кода упрощает поддержку изменение приложения улучшенная тестируемость: легко протестировать изолированно повышает надежность модульность: создавать модульные переиспользуемые компоненты подключать отключать глобальное управление: дают возможность глобально управлять ответами полезно таких задач примеры авторизация: authorization: bearer ко всем исходящим запросам логирование: времени выполнения url содержимого ошибок: перехват http отображение пользовательских сообщений об ошибках данных: перед отправкой сериализация объектов json) ответа использованием кэширование: от сервера повышения производительности заголовков: общих content-type accept-language токенов: обновление устаревших токенов применить общую логику нескольким http-запросам запросы до их отправки обработки централизовать http-коммуникациями *не* относятся только одному конкретному этом лучше локальные методы функции сложной бизнес-логики которая связана заключение: гибкий улучшить структуру поддерживаемость расширяемость angular-приложений понимание использование важным навыком любого angular-разработчика правильное применение значительно упростить разработку сложных веб-приложений deep",
    "_version": 0
  },
  {
    "_id": "68b89da5f63b8048002664f3",
    "title": "Дергается скролл",
    "content": "Проверить почему дёргается скролл при нажатии enter delete и тд когда в текстареа много текста и на экране видна нижняя часть текстареа\n\n",
    "group": "ToDo",
    "subGroup": "empty",
    "ignoreHtml": false,
    "order": 2,
    "imageUrls": "",
    "_created": "2025-09-03T19:57:25.033Z",
    "_changed": "2025-09-03T19:57:25.033Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "дергается",
      "скролл",
      "проверить",
      "почему",
      "дёргается",
      "при",
      "нажатии",
      "enter",
      "delete",
      "тд",
      "когда",
      "текстареа",
      "много",
      "текста",
      "на",
      "экране",
      "видна",
      "нижняя",
      "часть",
      "todo",
      "empty"
    ],
    "_tags": "api дергается скролл проверить почему дёргается при нажатии enter delete тд когда текстареа много текста на экране видна нижняя часть todo empty",
    "_version": 0
  },
  {
    "_id": "68b89de3f63b8048002664f8",
    "title": "Fixed кнопки",
    "content": "Добавить кнопки с position fixed для навигации вверх и для сворачивания всех статей и групп",
    "group": "ToDo",
    "subGroup": "empty",
    "ignoreHtml": false,
    "order": 3,
    "imageUrls": "",
    "_created": "2025-09-03T19:58:27.759Z",
    "_changed": "2025-09-04T19:02:45.376Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "fixed",
      "кнопки",
      "добавить",
      "position",
      "для",
      "навигации",
      "вверх",
      "сворачивания",
      "всех",
      "статей",
      "групп",
      "todo",
      "empty"
    ],
    "_tags": "api fixed кнопки добавить position для навигации вверх сворачивания всех статей групп todo empty",
    "_version": 1,
    "done": true
  },
  {
    "_id": "68b89e22f63b8048002664fd",
    "title": "Нумерация списков",
    "content": "Попробовать сделать нумерацию списков при их выделении",
    "group": "ToDo",
    "subGroup": "empty",
    "ignoreHtml": false,
    "order": 4,
    "imageUrls": "",
    "_created": "2025-09-03T19:59:30.869Z",
    "_changed": "2025-09-03T19:59:30.869Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "нумерация",
      "списков",
      "попробовать",
      "сделать",
      "нумерацию",
      "при",
      "их",
      "выделении",
      "todo",
      "empty"
    ],
    "_tags": "api нумерация списков попробовать сделать нумерацию при их выделении todo empty",
    "_version": 0
  },
  {
    "_id": "68b8a054f63b804800266526",
    "title": "HTML теги в textarea",
    "content": "Попробовать сделать чтобы вставленные в textarea теги через контрольную панель парсились, а теги вставленные в текст нет",
    "group": "ToDo",
    "subGroup": "empty",
    "ignoreHtml": false,
    "order": 8,
    "imageUrls": "",
    "_created": "2025-09-03T20:08:52.666Z",
    "_changed": "2025-09-04T17:33:45.010Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "html",
      "теги",
      "textarea",
      "попробовать",
      "сделать",
      "чтобы",
      "вставленные",
      "через",
      "контрольную",
      "панель",
      "парсились",
      "текст",
      "нет",
      "todo",
      "empty"
    ],
    "_tags": "api html теги textarea попробовать сделать чтобы вставленные через контрольную панель парсились текст нет todo empty",
    "_version": 4,
    "done": false
  },
  {
    "_id": "68acbb45f63b804800257939",
    "title": "Единицы измерения: px, em, rem и другие",
    "content": "Пиксель px – это самая базовая, абсолютная и окончательная единица измерения.\nКоличество пикселей задаётся в настройках разрешения экрана, один px – это как раз один такой пиксель на экране. Все значения браузер в итоге пересчитает в пиксели.\nПиксели могут быть дробными, например размер можно задать в 16.5px. Это совершенно нормально, браузер сам использует дробные пиксели для внутренних вычислений. К примеру, есть элемент шириной в 100px, его нужно разделить на три части – волей-неволей появляются 33.333...px. При окончательном отображении дробные пиксели, конечно же, округляются и становятся целыми.\n\nem - Относительно шрифта\n1em – текущий размер шрифта.\nМожно брать любые пропорции от текущего шрифта: 2em, 0.5em и т.п.\nРазмеры в em – относительные, они определяются по текущему контексту.\n\nПроценты %, как и em – относительные единицы.\nКак правило, процент будет от значения свойства родителя с тем же названием, но не всегда.\nmargin-left\nПри установке свойства margin-left в %, процент берётся от ширины родительского блока, а вовсе не от его margin-left.\nline-height\nПри установке свойства line-height в %, процент берётся от текущего размера шрифта, а вовсе не от line-height родителя. Детали по line-height и размеру шрифта вы также можете найти в статье Свойства font-size и line-height.\nwidth/height\nДля width/height обычно процент от ширины/высоты родителя, но при position:fixed, процент берётся от ширины/высоты окна (а не родителя и не документа).\n\nЕдиница rem: смесь px и em\nЕдиница rem задаёт размер относительно размера шрифта элемента <html>.\nКак правило, браузеры ставят этому элементу некоторый «разумный» (reasonable) размер по умолчанию, который мы, конечно, можем переопределить и использовать rem для задания шрифтов внутри относительно него\nЭлементы, размер которых задан в rem, не зависят друг от друга и от контекста – и этим похожи на px, а с другой стороны они все заданы относительно размера шрифта <html>.\nЕдиница rem не поддерживается в IE8-.\n",
    "group": "CSS",
    "imageUrls": "",
    "_created": "2025-08-25T19:36:37.620Z",
    "_changed": "2025-09-03T20:03:54.828Z",
    "_createdby": "api",
    "_changedby": "osokinkostyan12@gmail.com",
    "_keywords": [
      "api",
      "osokinkostyan12",
      "gmail",
      "com",
      "единицы",
      "измерения:",
      "px",
      "em",
      "rem",
      "другие",
      "пиксель",
      "это",
      "самая",
      "базовая",
      "абсолютная",
      "окончательная",
      "единица",
      "измерения",
      "количество",
      "пикселей",
      "задаётся",
      "настройках",
      "разрешения",
      "экрана",
      "один",
      "как",
      "раз",
      "такой",
      "на",
      "экране",
      "все",
      "значения",
      "браузер",
      "итоге",
      "пересчитает",
      "пиксели",
      "могут",
      "быть",
      "дробными",
      "например",
      "размер",
      "можно",
      "задать",
      "16",
      "5px",
      "совершенно",
      "нормально",
      "сам",
      "использует",
      "дробные",
      "для",
      "внутренних",
      "вычислений",
      "примеру",
      "есть",
      "элемент",
      "шириной",
      "100px",
      "его",
      "нужно",
      "разделить",
      "три",
      "части",
      "волей-неволей",
      "появляются",
      "33",
      "333",
      "при",
      "окончательном",
      "отображении",
      "конечно",
      "же",
      "округляются",
      "становятся",
      "целыми",
      "относительно",
      "шрифта",
      "1em",
      "текущий",
      "брать",
      "любые",
      "пропорции",
      "от",
      "текущего",
      "шрифта:",
      "2em",
      "5em",
      "размеры",
      "относительные",
      "они",
      "определяются",
      "по",
      "текущему",
      "контексту",
      "проценты",
      "правило",
      "процент",
      "будет",
      "свойства",
      "родителя",
      "тем",
      "названием",
      "но",
      "не",
      "всегда",
      "margin-left",
      "установке",
      "берётся",
      "ширины",
      "родительского",
      "блока",
      "вовсе",
      "line-height",
      "размера",
      "детали",
      "размеру",
      "вы",
      "также",
      "можете",
      "найти",
      "статье",
      "font-size",
      "width/height",
      "обычно",
      "ширины/высоты",
      "position:fixed",
      "окна",
      "(а",
      "документа)",
      "rem:",
      "смесь",
      "задаёт",
      "элемента",
      "браузеры",
      "ставят",
      "этому",
      "элементу",
      "некоторый",
      "«разумный»",
      "(reasonable)",
      "умолчанию",
      "который",
      "мы",
      "можем",
      "переопределить",
      "использовать",
      "задания",
      "шрифтов",
      "внутри",
      "него",
      "элементы",
      "которых",
      "задан",
      "зависят",
      "друг",
      "друга",
      "контекста",
      "этим",
      "похожи",
      "другой",
      "стороны",
      "заданы",
      "поддерживается",
      "ie8-",
      "css",
      "random"
    ],
    "_tags": "api osokinkostyan12 gmail com единицы измерения: px em rem другие пиксель это самая базовая абсолютная окончательная единица измерения количество пикселей задаётся настройках разрешения экрана один как раз такой на экране все значения браузер итоге пересчитает пиксели могут быть дробными например размер можно задать 16 5px совершенно нормально сам использует дробные для внутренних вычислений примеру есть элемент шириной 100px его нужно разделить три части волей-неволей появляются 33 333 при окончательном отображении конечно же округляются становятся целыми относительно шрифта 1em текущий брать любые пропорции от текущего шрифта: 2em 5em размеры относительные они определяются по текущему контексту проценты правило процент будет свойства родителя тем названием но не всегда margin-left установке берётся ширины родительского блока вовсе line-height размера детали размеру вы также можете найти статье font-size width/height обычно ширины/высоты position:fixed окна (а документа) rem: смесь задаёт элемента браузеры ставят этому элементу некоторый «разумный» (reasonable) умолчанию который мы можем переопределить использовать задания шрифтов внутри него элементы которых задан зависят друг друга контекста этим похожи другой стороны заданы поддерживается ie8- css random",
    "_version": 2,
    "subGroup": "Random",
    "order": 1
  },
  {
    "_id": "68ae1e21f63b80480025943a",
    "title": "Position",
    "content": "Свойство position задаёт способ позиционирования элемента в документе. Совместно со свойствами left, right, top, bottom или inset элементу задаётся его местоположение на странице.\nЗначения position:\nstatic — является значением по умолчанию для всех элементов и будет отображаться на странице в соответствии с порядком элемента в документе. Это значение используется редко и, как правило, не требует дополнительных параметров.\nrelative — определяет позиционирование элемента относительно его стандартного местоположения на странице. При использовании этого значения можно задать дополнительные параметры, такие как top, bottom, left и right, которые указывают на смещение элемента относительно его стандартного местоположения.\nabsolute — Absolute задаёт точное местоположение элемента на странице, независимо от других элементов на странице. При использовании значения можно задать параметры top, bottom, left и right, чтобы определить точное местоположение элемента.\nfixed —Fixed задаёт элемент на фиксированном месте на странице, независимо от прокрутки страницы. При использовании этого значения также можно задать параметры top, bottom, left и right, чтобы определить точное местоположение элемента.\nsticky — начинает себя вести как обычный элемент до тех пор, пока не достигнет определенной позиции на странице, которую вы зададите с помощью свойства **top, right, bottom или left. Как только элемент достигнет этой позиции при прокрутке страницы, он зафиксируется на месте и будет оставаться там до тех пор, пока пользователь не доскроллит страницу обратно.\nНюансы использования\n- Если у элемента значение свойства position установлено в absolute или fixed, то такой элемент будет выведен из обычного потока документа и может перекрыть другие элементы. Если это не предполагается, то нужно следить за порядком элементов на странице и настройками z-index.\n- Если у элемента значение свойства position установлено в relative, то это не влияет на позиции других элементов на странице.\n- Значение свойства position может также влиять на поведение других свойств, например, на позиционирование через top, left, bottom и right.\n- Использование свойства position вместе с другими свойствами, например, transform или display, может дать неожиданные результаты и требует более тщательного тестирования на разных браузерах и устройствах.\n- Значение sticky может привести к проблемам с доступностью. Если элемент со значением sticky перекрывает другие элементы на странице, это может затруднить доступ к этим элементам для людей, использующих скринридеры.",
    "group": "CSS",
    "imageUrls": [
      "https://ik.imagekit.io/ygtb3rzhz/imag4.png?updatedAt=1756242129540",
      "https://ik.imagekit.io/ygtb3rzhz/imag3e.png?updatedAt=1756242102753",
      "https://ik.imagekit.io/ygtb3rzhz/image2.png?updatedAt=1756242074095",
      "https://ik.imagekit.io/ygtb3rzhz/image.png?updatedAt=1756242016091"
    ],
    "subGroup": "CSS Basic",
    "_created": "2025-08-26T20:50:41.166Z",
    "_changed": "2025-09-03T20:04:04.168Z",
    "_createdby": "api",
    "_changedby": "osokinkostyan12@gmail.com",
    "_keywords": [
      "api",
      "osokinkostyan12",
      "gmail",
      "com",
      "position",
      "свойство",
      "задаёт",
      "способ",
      "позиционирования",
      "элемента",
      "документе",
      "совместно",
      "со",
      "свойствами",
      "left",
      "right",
      "top",
      "bottom",
      "или",
      "inset",
      "элементу",
      "задаётся",
      "его",
      "местоположение",
      "на",
      "странице",
      "значения",
      "position:",
      "static",
      "является",
      "значением",
      "по",
      "умолчанию",
      "для",
      "всех",
      "элементов",
      "будет",
      "отображаться",
      "соответствии",
      "порядком",
      "это",
      "значение",
      "используется",
      "редко",
      "как",
      "правило",
      "не",
      "требует",
      "дополнительных",
      "параметров",
      "relative",
      "определяет",
      "позиционирование",
      "относительно",
      "стандартного",
      "местоположения",
      "при",
      "использовании",
      "этого",
      "можно",
      "задать",
      "дополнительные",
      "параметры",
      "такие",
      "которые",
      "указывают",
      "смещение",
      "absolute",
      "точное",
      "независимо",
      "от",
      "других",
      "чтобы",
      "определить",
      "fixed",
      "—fixed",
      "элемент",
      "фиксированном",
      "месте",
      "прокрутки",
      "страницы",
      "также",
      "sticky",
      "начинает",
      "себя",
      "вести",
      "обычный",
      "до",
      "тех",
      "пор",
      "пока",
      "достигнет",
      "определенной",
      "позиции",
      "которую",
      "вы",
      "зададите",
      "помощью",
      "свойства",
      "**top",
      "только",
      "этой",
      "прокрутке",
      "он",
      "зафиксируется",
      "оставаться",
      "там",
      "пользователь",
      "доскроллит",
      "страницу",
      "обратно",
      "нюансы",
      "использования",
      "если",
      "установлено",
      "то",
      "такой",
      "выведен",
      "из",
      "обычного",
      "потока",
      "документа",
      "может",
      "перекрыть",
      "другие",
      "элементы",
      "предполагается",
      "нужно",
      "следить",
      "за",
      "настройками",
      "z-index",
      "влияет",
      "влиять",
      "поведение",
      "свойств",
      "например",
      "через",
      "использование",
      "вместе",
      "другими",
      "transform",
      "display",
      "дать",
      "неожиданные",
      "результаты",
      "более",
      "тщательного",
      "тестирования",
      "разных",
      "браузерах",
      "устройствах",
      "привести",
      "проблемам",
      "доступностью",
      "перекрывает",
      "затруднить",
      "доступ",
      "этим",
      "элементам",
      "людей",
      "использующих",
      "скринридеры",
      "css",
      "https://ik",
      "imagekit",
      "io/ygtb3rzhz/imag4",
      "png?updatedat=1756242129540",
      "io/ygtb3rzhz/imag3e",
      "png?updatedat=1756242102753",
      "io/ygtb3rzhz/image2",
      "png?updatedat=1756242074095",
      "io/ygtb3rzhz/image",
      "png?updatedat=1756242016091",
      "basic"
    ],
    "_tags": "api osokinkostyan12 gmail com position свойство задаёт способ позиционирования элемента документе совместно со свойствами left right top bottom или inset элементу задаётся его местоположение на странице значения position: static является значением по умолчанию для всех элементов будет отображаться соответствии порядком это значение используется редко как правило не требует дополнительных параметров relative определяет позиционирование относительно стандартного местоположения при использовании этого можно задать дополнительные параметры такие которые указывают смещение absolute точное независимо от других чтобы определить fixed —fixed элемент фиксированном месте прокрутки страницы также sticky начинает себя вести обычный до тех пор пока достигнет определенной позиции которую вы зададите помощью свойства **top только этой прокрутке он зафиксируется оставаться там пользователь доскроллит страницу обратно нюансы использования если установлено то такой выведен из обычного потока документа может перекрыть другие элементы предполагается нужно следить за настройками z-index влияет влиять поведение свойств например через использование вместе другими transform display дать неожиданные результаты более тщательного тестирования разных браузерах устройствах привести проблемам доступностью перекрывает затруднить доступ этим элементам людей использующих скринридеры css https://ik imagekit io/ygtb3rzhz/imag4 png?updatedat=1756242129540 io/ygtb3rzhz/imag3e png?updatedat=1756242102753 io/ygtb3rzhz/image2 png?updatedat=1756242074095 io/ygtb3rzhz/image png?updatedat=1756242016091 basic",
    "_version": 1,
    "order": 1
  },
  {
    "_id": "68b9e6b3f63b804800268107",
    "title": "Наследование ",
    "content": "Наследование – это еще одна ключевая концепция ООП, которая позволяет создавать новые классы (дочерние классы) на основе существующих классов (родительские классы). Дочерний класс наследует свойства и методы родительского класса и может добавлять новые свойства и методы или переопределять существующие.\n\nЗачем нужно наследование?\n• Повторное использование кода: Наследование позволяет избежать дублирования кода, повторно используя логику, определенную в родительском классе.\n• Расширяемость: Наследование позволяет добавлять новую функциональность к существующим классам без изменения их исходного кода.\n• Полиморфизм: Наследование позволяет обрабатывать объекты разных классов единообразно, если они унаследованы от общего родительского класса.\n• Организация кода: Наследование помогает структурировать код, создавая иерархию классов, отражающую отношения \"является\" (is-a relationship) между объектами.\n\nНаследование в Angular компонентах:\nХотя Angular поощряет композицию компонентов (то есть, создание более сложных компонентов из меньших, более простых компонентов) как основной способ повторного использования кода, наследование все еще может быть полезным в определенных сценариях. В частности, наследование может быть полезным для:\n• Общей логики: Если несколько компонентов разделяют общую логику, такую как обработка ошибок, валидация данных или взаимодействие с сервисами, можно создать базовый класс, содержащий эту логику, и унаследовать от него другие компоненты.\n• Представления данных: Если несколько компонентов отображают данные в похожем формате, но с некоторыми отличиями, можно создать базовый класс, определяющий структуру данных и общую логику отображения, а затем унаследовать от него компоненты, которые реализуют специфичные детали отображения.\n• Хуков жизненного цикла: Когда требуется выполнить определенные действия в одних и тех же хуках жизненного цикла для нескольких компонентов, базовый класс может предоставить реализацию по умолчанию.\n\nПримеры:\n1. Базовый класс для обработки ошибок: <p><img src=\"https://ik.imagekit.io/ygtb3rzhz/oop1.png?updatedAt=1757014236928\" alt=\"В\" style=\"max-width: 100%;\"></p> \nВ этом примере мы создали базовый класс BaseComponent, который определяет:\n•  destroy$: RxJS Subject для управления отписками от Observable, предотвращая утечки памяти.\n•  errorMessage: Свойство для хранения сообщения об ошибке.\n•  handleError(): Метод для обработки ошибок, который выводит ошибку в консоль и устанавливает значение errorMessage.\n•  ngOnDestroy(): Метод жизненного цикла, который вызывает next() и complete() для destroy$, чтобы отписаться от всех подписок.\n\n2. Наследуемый компонент, использующий базовый класс: <p><img src=\"https://ik.imagekit.io/ygtb3rzhz/oop2.png?updatedAt=1757014283844\" alt=\"В\" style=\"max-width: 100%;\"></p> \nВ этом примере DataComponent наследуется от BaseComponent. Он использует методы handleError() и destroy$, определенные в базовом классе. Он также вызывает super() в конструкторе, что необходимо для инициализации базового класса. takeUntil(this.destroy$) гарантирует, что подписка на dataService.getData() будет отменена при уничтожении компонента, предотвращая утечки памяти.\n3. Другой наследуемый компонент, использующий базовый класс: <p><img src=\"https://ik.imagekit.io/ygtb3rzhz/oop3.png?updatedAt=1757014396806\" alt=\"В\" style=\"max-width: 100%;\"></p> \nЭтот компонент также наследуется от BaseComponent и использует ту же логику обработки ошибок и управления подписками. Он получает данные из другого сервиса (AnotherDataService), но использует те же механизмы для обработки ошибок и отмены подписок.\n\nВажные моменты при использовании наследования в Angular:\n•  Вызов super() в конструкторе: Обязательно вызывайте super() в конструкторе дочернего класса, чтобы инициализировать базовый класс. Если этого не сделать, возникнет ошибка.\n•  @Component({ template: '' }) для базовых компонентов: Чтобы предотвратить ошибки рендеринга, базовые компоненты, которые не предназначены для непосредственного использования в шаблонах, должны иметь либо пустой шаблон (template: ''), либо использовать @Directive().\n•  Использовать protected вместо private: Свойства и методы, предназначенные для использования в дочерних классах, должны быть объявлены как protected. Свойства и методы, объявленные как private, не доступны в дочерних классах.\n•  Ограниченное использование: Наследование следует использовать осторожно и только тогда, когда оно действительно необходимо. Композиция компонентов часто является более гибким и мощным подходом.\n•  Глубокие иерархии: Избегайте создания глубоких иерархий наследования, так как это может привести к сложному и трудно поддерживаемому коду.\n\nКогда лучше избегать наследования и использовать композицию:\n•  Если дочерний класс \"использует\" родительский класс, а не \"является\" им. Например, компонент, который использует сервис для получения данных, должен использовать композицию (внедрение зависимости), а не наследование.\n•  Если функциональность, которую вы хотите повторно использовать, не является фундаментальной для поведения компонента. В этом случае можно создать отдельный сервис или утилитарную функцию и использовать ее в нескольких компонентах.\n•  Если существует вероятность того, что родительский класс будет изменен в будущем, и эти изменения могут сломать дочерние классы. Композиция менее подвержена таким проблемам.\n\nВ заключение:\nНаследование может быть полезным инструментом для повторного использования кода и организации Angular-приложений, особенно в случаях, когда несколько компонентов разделяют общую логику или структуру. Однако важно использовать наследование осторожно и обдуманно, и отдавать предпочтение композиции компонентов, когда это возможно. Хорошо продуманное использование наследования может привести к созданию более чистого и эффективного кода, в то время как злоупотребление им может привести к созданию сложного и трудно поддерживаемого приложения.",
    "group": "ООП",
    "subGroup": "Принципы ООП",
    "ignoreHtml": false,
    "order": 3,
    "imageUrls": "",
    "_created": "2025-09-04T19:21:23.043Z",
    "_changed": "2025-09-04T19:21:23.043Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "наследование",
      "это",
      "еще",
      "одна",
      "ключевая",
      "концепция",
      "ооп",
      "которая",
      "позволяет",
      "создавать",
      "новые",
      "классы",
      "(дочерние",
      "классы)",
      "на",
      "основе",
      "существующих",
      "классов",
      "(родительские",
      "дочерний",
      "класс",
      "наследует",
      "свойства",
      "методы",
      "родительского",
      "класса",
      "может",
      "добавлять",
      "или",
      "переопределять",
      "существующие",
      "зачем",
      "нужно",
      "наследование?",
      "повторное",
      "использование",
      "кода:",
      "избежать",
      "дублирования",
      "кода",
      "повторно",
      "используя",
      "логику",
      "определенную",
      "родительском",
      "классе",
      "расширяемость:",
      "новую",
      "функциональность",
      "существующим",
      "классам",
      "без",
      "изменения",
      "их",
      "исходного",
      "полиморфизм:",
      "обрабатывать",
      "объекты",
      "разных",
      "единообразно",
      "если",
      "они",
      "унаследованы",
      "от",
      "общего",
      "организация",
      "помогает",
      "структурировать",
      "код",
      "создавая",
      "иерархию",
      "отражающую",
      "отношения",
      "\"является\"",
      "(is-a",
      "relationship)",
      "между",
      "объектами",
      "angular",
      "компонентах:",
      "хотя",
      "поощряет",
      "композицию",
      "компонентов",
      "(то",
      "есть",
      "создание",
      "более",
      "сложных",
      "из",
      "меньших",
      "простых",
      "компонентов)",
      "как",
      "основной",
      "способ",
      "повторного",
      "использования",
      "все",
      "быть",
      "полезным",
      "определенных",
      "сценариях",
      "частности",
      "для:",
      "общей",
      "логики:",
      "несколько",
      "разделяют",
      "общую",
      "такую",
      "обработка",
      "ошибок",
      "валидация",
      "данных",
      "взаимодействие",
      "сервисами",
      "можно",
      "создать",
      "базовый",
      "содержащий",
      "эту",
      "унаследовать",
      "него",
      "другие",
      "компоненты",
      "представления",
      "данных:",
      "отображают",
      "данные",
      "похожем",
      "формате",
      "но",
      "некоторыми",
      "отличиями",
      "определяющий",
      "структуру",
      "отображения",
      "затем",
      "которые",
      "реализуют",
      "специфичные",
      "детали",
      "хуков",
      "жизненного",
      "цикла:",
      "когда",
      "требуется",
      "выполнить",
      "определенные",
      "действия",
      "одних",
      "тех",
      "же",
      "хуках",
      "цикла",
      "для",
      "нескольких",
      "предоставить",
      "реализацию",
      "по",
      "умолчанию",
      "примеры:",
      "обработки",
      "ошибок:",
      "этом",
      "примере",
      "мы",
      "создали",
      "basecomponent",
      "который",
      "определяет:",
      "destroy$:",
      "rxjs",
      "subject",
      "управления",
      "отписками",
      "observable",
      "предотвращая",
      "утечки",
      "памяти",
      "errormessage:",
      "свойство",
      "хранения",
      "сообщения",
      "об",
      "ошибке",
      "handleerror():",
      "метод",
      "выводит",
      "ошибку",
      "консоль",
      "устанавливает",
      "значение",
      "errormessage",
      "ngondestroy():",
      "вызывает",
      "next()",
      "complete()",
      "destroy$",
      "чтобы",
      "отписаться",
      "всех",
      "подписок",
      "наследуемый",
      "компонент",
      "использующий",
      "класс:",
      "datacomponent",
      "наследуется",
      "он",
      "использует",
      "handleerror()",
      "базовом",
      "также",
      "super()",
      "конструкторе",
      "что",
      "необходимо",
      "инициализации",
      "базового",
      "takeuntil(this",
      "destroy$)",
      "гарантирует",
      "подписка",
      "dataservice",
      "getdata()",
      "будет",
      "отменена",
      "при",
      "уничтожении",
      "компонента",
      "другой",
      "этот",
      "ту",
      "подписками",
      "получает",
      "другого",
      "сервиса",
      "(anotherdataservice)",
      "те",
      "механизмы",
      "отмены",
      "важные",
      "моменты",
      "использовании",
      "наследования",
      "angular:",
      "вызов",
      "конструкторе:",
      "обязательно",
      "вызывайте",
      "дочернего",
      "инициализировать",
      "этого",
      "не",
      "сделать",
      "возникнет",
      "ошибка",
      "component({",
      "template:",
      "''",
      "})",
      "базовых",
      "компонентов:",
      "предотвратить",
      "ошибки",
      "рендеринга",
      "базовые",
      "предназначены",
      "непосредственного",
      "шаблонах",
      "должны",
      "иметь",
      "либо",
      "пустой",
      "шаблон",
      "(template:",
      "'')",
      "использовать",
      "directive()",
      "protected",
      "вместо",
      "private:",
      "предназначенные",
      "дочерних",
      "классах",
      "объявлены",
      "объявленные",
      "private",
      "доступны",
      "ограниченное",
      "использование:",
      "следует",
      "осторожно",
      "только",
      "тогда",
      "оно",
      "действительно",
      "композиция",
      "часто",
      "является",
      "гибким",
      "мощным",
      "подходом",
      "глубокие",
      "иерархии:",
      "избегайте",
      "создания",
      "глубоких",
      "иерархий",
      "так",
      "привести",
      "сложному",
      "трудно",
      "поддерживаемому",
      "коду",
      "лучше",
      "избегать",
      "композицию:",
      "\"использует\"",
      "родительский",
      "им",
      "например",
      "сервис",
      "получения",
      "должен",
      "(внедрение",
      "зависимости)",
      "которую",
      "вы",
      "хотите",
      "фундаментальной",
      "поведения",
      "случае",
      "отдельный",
      "утилитарную",
      "функцию",
      "ее",
      "компонентах",
      "существует",
      "вероятность",
      "того",
      "изменен",
      "будущем",
      "эти",
      "могут",
      "сломать",
      "дочерние",
      "менее",
      "подвержена",
      "таким",
      "проблемам",
      "заключение:",
      "инструментом",
      "организации",
      "angular-приложений",
      "особенно",
      "случаях",
      "однако",
      "важно",
      "обдуманно",
      "отдавать",
      "предпочтение",
      "композиции",
      "возможно",
      "хорошо",
      "продуманное",
      "созданию",
      "чистого",
      "эффективного",
      "то",
      "время",
      "злоупотребление",
      "сложного",
      "поддерживаемого",
      "приложения",
      "принципы"
    ],
    "_tags": "api наследование это еще одна ключевая концепция ооп которая позволяет создавать новые классы (дочерние классы) на основе существующих классов (родительские дочерний класс наследует свойства методы родительского класса может добавлять или переопределять существующие зачем нужно наследование? повторное использование кода: избежать дублирования кода повторно используя логику определенную родительском классе расширяемость: новую функциональность существующим классам без изменения их исходного полиморфизм: обрабатывать объекты разных единообразно если они унаследованы от общего организация помогает структурировать код создавая иерархию отражающую отношения \"является\" (is-a relationship) между объектами angular компонентах: хотя поощряет композицию компонентов (то есть создание более сложных из меньших простых компонентов) как основной способ повторного использования все быть полезным определенных сценариях частности для: общей логики: несколько разделяют общую такую обработка ошибок валидация данных взаимодействие сервисами можно создать базовый содержащий эту унаследовать него другие компоненты представления данных: отображают данные похожем формате но некоторыми отличиями определяющий структуру отображения затем которые реализуют специфичные детали хуков жизненного цикла: когда требуется выполнить определенные действия одних тех же хуках цикла для нескольких предоставить реализацию по умолчанию примеры: обработки ошибок: этом примере мы создали basecomponent который определяет: destroy$: rxjs subject управления отписками observable предотвращая утечки памяти errormessage: свойство хранения сообщения об ошибке handleerror(): метод выводит ошибку консоль устанавливает значение errormessage ngondestroy(): вызывает next() complete() destroy$ чтобы отписаться всех подписок наследуемый компонент использующий класс: datacomponent наследуется он использует handleerror() базовом также super() конструкторе что необходимо инициализации базового takeuntil(this destroy$) гарантирует подписка dataservice getdata() будет отменена при уничтожении компонента другой этот ту подписками получает другого сервиса (anotherdataservice) те механизмы отмены важные моменты использовании наследования angular: вызов конструкторе: обязательно вызывайте дочернего инициализировать этого не сделать возникнет ошибка component({ template: '' }) базовых компонентов: предотвратить ошибки рендеринга базовые предназначены непосредственного шаблонах должны иметь либо пустой шаблон (template: '') использовать directive() protected вместо private: предназначенные дочерних классах объявлены объявленные private доступны ограниченное использование: следует осторожно только тогда оно действительно композиция часто является гибким мощным подходом глубокие иерархии: избегайте создания глубоких иерархий так привести сложному трудно поддерживаемому коду лучше избегать композицию: \"использует\" родительский им например сервис получения должен (внедрение зависимости) которую вы хотите фундаментальной поведения случае отдельный утилитарную функцию ее компонентах существует вероятность того изменен будущем эти могут сломать дочерние менее подвержена таким проблемам заключение: инструментом организации angular-приложений особенно случаях однако важно обдуманно отдавать предпочтение композиции возможно хорошо продуманное созданию чистого эффективного то время злоупотребление сложного поддерживаемого приложения принципы",
    "_version": 0
  },
  {
    "_id": "68b9e908f63b804800268130",
    "title": "Композиция компонентов",
    "content": "Композиция компонентов – это мощный шаблон проектирования в Angular, который подразумевает создание сложных пользовательских интерфейсов путем объединения небольших, независимых и переиспользуемых компонентов.  Вместо того чтобы строить огромные монолитные компоненты, композиция позволяет разбивать приложение на множество маленьких кирпичиков, каждый из которых выполняет свою конкретную задачу.\n\nПочему Композиция Предпочтительнее Наследованию (в большинстве случаев)?\nХотя наследование имеет свои применения (как обсуждалось ранее), композиция в Angular обычно считается более гибким, мощным и поддерживаемым подходом для повторного использования кода и построения сложных UI.  Вот почему:\n\n• Слабая Связанность: Компоненты, созданные с использованием композиции, имеют слабую связанность (loose coupling).  Они не зависят от внутренней реализации других компонентов, что упрощает изменение и переиспользование компонентов независимо друг от друга.\n• Более Гибкое Переиспользование: Компоненты можно легко переиспользовать в разных частях приложения, даже если их требуется слегка изменить.  С наследованием это может быть сложнее, так как требует создания новых подклассов.\n• Тестируемость:  Маленькие, независимые компоненты намного легче тестировать, чем большие и сложные.\n• Избежание \"Проблемы хрупкого базового класса\":  Наследование может привести к проблемам, когда изменения в базовом классе неожиданно ломают дочерние классы.  Композиция, благодаря слабой связанности, снижает этот риск.\n• Соблюдение принципа единственной ответственности: Композиция способствует принципу единственной ответственности (Single Responsibility Principle), согласно которому каждый компонент должен отвечать только за одну конкретную задачу.\n\nКак работает Композиция в Angular?\nВ Angular композиция достигается с помощью нескольких техник:\n1.  Внедрение зависимостей (Dependency Injection - DI): Компоненты могут получать доступ к сервисам, компонентам и другим ресурсам, предоставляемым через систему DI Angular.\n2.  Взаимодействие через @Input() и @Output(): Родительские компоненты передают данные дочерним компонентам через @Input() и получают события от дочерних компонентов через @Output().\n3.  Использование <ng-content> (Content Projection): Родительские компоненты могут вставлять HTML-содержимое в дочерние компоненты, определяя места для проекции с помощью <ng-content>.\n4.  Использование директив: Директивы позволяют добавлять или изменять поведение элементов DOM, не создавая отдельные компоненты.\n\nПримеры Композиции в Angular:\n1. Использование @Input() и @Output():\n•   Дочерний компонент (ProductComponent): Отображает информацию о продукте и позволяет пользователю добавить его в корзину. <p><img src=\"https://ik.imagekit.io/ygtb3rzhz/composition.png?updatedAt=1757014871724\" alt=\"В\" style=\"max-width: 100%;\"></p> \nВ этом примере ProductListComponent *состоит* из нескольких ProductComponent.  Родитель передает данные о продукте каждому дочернему компоненту через @Input() и слушает событие addToCart с помощью @Output().\n\n2. Использование <ng-content> (Content Projection):\n•   Дочерний компонент (CardComponent):  Обобщенный компонент для отображения контента в карточке с заголовком и телом.\n <p><img src=\"https://ik.imagekit.io/ygtb3rzhz/composition.png?updatedAt=1757014871724\" alt=\"В\" style=\"max-width: 100%;\"></p> \nВ этом примере MyPageComponent использует <ng-content select=\".card-title\"></ng-content> в CardComponent, чтобы определить, куда будет вставлен элемент с классом .card-title.  Все остальное содержимое вставляется в тело карточки с помощью <ng-content></ng-content>.\n\n3. Использование сервисов:\nСервисы играют важную роль в композиции компонентов, поскольку позволяют компонентам делиться логикой и данными, не завися от внутренней реализации друг друга. Компоненты взаимодействуют с сервисами через внедрение зависимостей (DI).\n <p><img src=\"https://ik.imagekit.io/ygtb3rzhz/composition3.png?updatedAt=1757014987503\" alt=\"В\" style=\"max-width: 100%;\"></p> \nВ этом примере ProductListComponent использует ProductService для получения данных о продуктах. Сервис является независимым от компонента и может быть использован другими компонентами для получения тех же данных.\n\nПреимущества использования композиции компонентов:\n•   Более легкая поддержка: Разделение на маленькие компоненты облегчает понимание кода и локализацию проблем.\n•   Меньше дублирования кода: Переиспользуемые компоненты уменьшают необходимость дублирования кода.\n•   Повышенная гибкость:  Компоненты можно легко комбинировать и перекомбинировать для создания новых UI.\n•   Лучшая тестируемость: Маленькие, независимые компоненты легче тестировать.\n•   Улучшенная масштабируемость:  Композиция позволяет легко добавлять новые функции и компоненты в приложение.\n\nКогда все-таки может быть полезно наследование (очень редко):\n•   Визуальные компоненты ( UI-Kit/Frameworks ): Когда создаете фреймворк визуальных компонентов, где компоненты наследуют базовые визуальные стили или поведение.  Однако, даже здесь, предпочтительнее использовать композицию или декораторы.\n•   Абстрактные классы: Создание базовых абстрактных компонентов, которые требуют реализации определенных методов в дочерних классах.\n\nВ заключение:\nКомпозиция компонентов – это ключевой шаблон проектирования в Angular, который позволяет создавать гибкие, переиспользуемые и поддерживаемые приложения. Использование @Input(), @Output(), <ng-content>, директив и сервисов позволяет создавать сложные пользовательские интерфейсы путем объединения небольших, независимых компонентов. В большинстве случаев композиция является более предпочтительным подходом, чем наследование, благодаря своей гибкости, слабой связанности и простоте тестирования. Всегда старайтесь проектировать свои Angular-приложения, основываясь на принципе композиции компонентов.",
    "group": "Angular",
    "subGroup": "Angular Deep",
    "ignoreHtml": false,
    "order": 2,
    "imageUrls": "",
    "_created": "2025-09-04T19:31:20.627Z",
    "_changed": "2025-09-04T19:31:20.627Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "композиция",
      "компонентов",
      "это",
      "мощный",
      "шаблон",
      "проектирования",
      "angular",
      "который",
      "подразумевает",
      "создание",
      "сложных",
      "пользовательских",
      "интерфейсов",
      "путем",
      "объединения",
      "небольших",
      "независимых",
      "переиспользуемых",
      "вместо",
      "того",
      "чтобы",
      "строить",
      "огромные",
      "монолитные",
      "компоненты",
      "позволяет",
      "разбивать",
      "приложение",
      "на",
      "множество",
      "маленьких",
      "кирпичиков",
      "каждый",
      "из",
      "которых",
      "выполняет",
      "свою",
      "конкретную",
      "задачу",
      "почему",
      "предпочтительнее",
      "наследованию",
      "(в",
      "большинстве",
      "случаев)?",
      "хотя",
      "наследование",
      "имеет",
      "свои",
      "применения",
      "(как",
      "обсуждалось",
      "ранее)",
      "обычно",
      "считается",
      "более",
      "гибким",
      "мощным",
      "поддерживаемым",
      "подходом",
      "для",
      "повторного",
      "использования",
      "кода",
      "построения",
      "ui",
      "вот",
      "почему:",
      "слабая",
      "связанность:",
      "созданные",
      "использованием",
      "композиции",
      "имеют",
      "слабую",
      "связанность",
      "(loose",
      "coupling)",
      "они",
      "не",
      "зависят",
      "от",
      "внутренней",
      "реализации",
      "других",
      "что",
      "упрощает",
      "изменение",
      "переиспользование",
      "независимо",
      "друг",
      "друга",
      "гибкое",
      "переиспользование:",
      "можно",
      "легко",
      "переиспользовать",
      "разных",
      "частях",
      "приложения",
      "даже",
      "если",
      "их",
      "требуется",
      "слегка",
      "изменить",
      "наследованием",
      "может",
      "быть",
      "сложнее",
      "так",
      "как",
      "требует",
      "создания",
      "новых",
      "подклассов",
      "тестируемость:",
      "маленькие",
      "независимые",
      "намного",
      "легче",
      "тестировать",
      "чем",
      "большие",
      "сложные",
      "избежание",
      "\"проблемы",
      "хрупкого",
      "базового",
      "класса\":",
      "привести",
      "проблемам",
      "когда",
      "изменения",
      "базовом",
      "классе",
      "неожиданно",
      "ломают",
      "дочерние",
      "классы",
      "благодаря",
      "слабой",
      "связанности",
      "снижает",
      "этот",
      "риск",
      "соблюдение",
      "принципа",
      "единственной",
      "ответственности:",
      "способствует",
      "принципу",
      "ответственности",
      "(single",
      "responsibility",
      "principle)",
      "согласно",
      "которому",
      "компонент",
      "должен",
      "отвечать",
      "только",
      "за",
      "одну",
      "работает",
      "angular?",
      "достигается",
      "помощью",
      "нескольких",
      "техник:",
      "внедрение",
      "зависимостей",
      "(dependency",
      "injection",
      "di):",
      "могут",
      "получать",
      "доступ",
      "сервисам",
      "компонентам",
      "другим",
      "ресурсам",
      "предоставляемым",
      "через",
      "систему",
      "di",
      "взаимодействие",
      "input()",
      "output():",
      "родительские",
      "передают",
      "данные",
      "дочерним",
      "получают",
      "события",
      "дочерних",
      "output()",
      "использование",
      "(content",
      "projection):",
      "вставлять",
      "html-содержимое",
      "определяя",
      "места",
      "проекции",
      "директив:",
      "директивы",
      "позволяют",
      "добавлять",
      "или",
      "изменять",
      "поведение",
      "элементов",
      "dom",
      "создавая",
      "отдельные",
      "примеры",
      "angular:",
      "дочерний",
      "(productcomponent):",
      "отображает",
      "информацию",
      "продукте",
      "пользователю",
      "добавить",
      "его",
      "корзину",
      "этом",
      "примере",
      "productlistcomponent",
      "*состоит*",
      "productcomponent",
      "родитель",
      "передает",
      "каждому",
      "дочернему",
      "компоненту",
      "слушает",
      "событие",
      "addtocart",
      "(cardcomponent):",
      "обобщенный",
      "отображения",
      "контента",
      "карточке",
      "заголовком",
      "телом",
      "mypagecomponent",
      "использует",
      "cardcomponent",
      "определить",
      "куда",
      "будет",
      "вставлен",
      "элемент",
      "классом",
      "card-title",
      "все",
      "остальное",
      "содержимое",
      "вставляется",
      "тело",
      "карточки",
      "сервисов:",
      "сервисы",
      "играют",
      "важную",
      "роль",
      "поскольку",
      "делиться",
      "логикой",
      "данными",
      "завися",
      "взаимодействуют",
      "сервисами",
      "(di)",
      "productservice",
      "получения",
      "данных",
      "продуктах",
      "сервис",
      "является",
      "независимым",
      "компонента",
      "использован",
      "другими",
      "компонентами",
      "тех",
      "же",
      "преимущества",
      "компонентов:",
      "легкая",
      "поддержка:",
      "разделение",
      "облегчает",
      "понимание",
      "локализацию",
      "проблем",
      "меньше",
      "дублирования",
      "кода:",
      "переиспользуемые",
      "уменьшают",
      "необходимость",
      "повышенная",
      "гибкость:",
      "комбинировать",
      "перекомбинировать",
      "лучшая",
      "улучшенная",
      "масштабируемость:",
      "новые",
      "функции",
      "все-таки",
      "полезно",
      "(очень",
      "редко):",
      "визуальные",
      "ui-kit/frameworks",
      "):",
      "создаете",
      "фреймворк",
      "визуальных",
      "где",
      "наследуют",
      "базовые",
      "стили",
      "однако",
      "здесь",
      "использовать",
      "композицию",
      "декораторы",
      "абстрактные",
      "классы:",
      "базовых",
      "абстрактных",
      "которые",
      "требуют",
      "определенных",
      "методов",
      "классах",
      "заключение:",
      "ключевой",
      "создавать",
      "гибкие",
      "поддерживаемые",
      "директив",
      "сервисов",
      "пользовательские",
      "интерфейсы",
      "случаев",
      "предпочтительным",
      "своей",
      "гибкости",
      "простоте",
      "тестирования",
      "всегда",
      "старайтесь",
      "проектировать",
      "angular-приложения",
      "основываясь",
      "принципе",
      "deep"
    ],
    "_tags": "api композиция компонентов это мощный шаблон проектирования angular который подразумевает создание сложных пользовательских интерфейсов путем объединения небольших независимых переиспользуемых вместо того чтобы строить огромные монолитные компоненты позволяет разбивать приложение на множество маленьких кирпичиков каждый из которых выполняет свою конкретную задачу почему предпочтительнее наследованию (в большинстве случаев)? хотя наследование имеет свои применения (как обсуждалось ранее) обычно считается более гибким мощным поддерживаемым подходом для повторного использования кода построения ui вот почему: слабая связанность: созданные использованием композиции имеют слабую связанность (loose coupling) они не зависят от внутренней реализации других что упрощает изменение переиспользование независимо друг друга гибкое переиспользование: можно легко переиспользовать разных частях приложения даже если их требуется слегка изменить наследованием может быть сложнее так как требует создания новых подклассов тестируемость: маленькие независимые намного легче тестировать чем большие сложные избежание \"проблемы хрупкого базового класса\": привести проблемам когда изменения базовом классе неожиданно ломают дочерние классы благодаря слабой связанности снижает этот риск соблюдение принципа единственной ответственности: способствует принципу ответственности (single responsibility principle) согласно которому компонент должен отвечать только за одну работает angular? достигается помощью нескольких техник: внедрение зависимостей (dependency injection di): могут получать доступ сервисам компонентам другим ресурсам предоставляемым через систему di взаимодействие input() output(): родительские передают данные дочерним получают события дочерних output() использование (content projection): вставлять html-содержимое определяя места проекции директив: директивы позволяют добавлять или изменять поведение элементов dom создавая отдельные примеры angular: дочерний (productcomponent): отображает информацию продукте пользователю добавить его корзину этом примере productlistcomponent *состоит* productcomponent родитель передает каждому дочернему компоненту слушает событие addtocart (cardcomponent): обобщенный отображения контента карточке заголовком телом mypagecomponent использует cardcomponent определить куда будет вставлен элемент классом card-title все остальное содержимое вставляется тело карточки сервисов: сервисы играют важную роль поскольку делиться логикой данными завися взаимодействуют сервисами (di) productservice получения данных продуктах сервис является независимым компонента использован другими компонентами тех же преимущества компонентов: легкая поддержка: разделение облегчает понимание локализацию проблем меньше дублирования кода: переиспользуемые уменьшают необходимость повышенная гибкость: комбинировать перекомбинировать лучшая улучшенная масштабируемость: новые функции все-таки полезно (очень редко): визуальные ui-kit/frameworks ): создаете фреймворк визуальных где наследуют базовые стили однако здесь использовать композицию декораторы абстрактные классы: базовых абстрактных которые требуют определенных методов классах заключение: ключевой создавать гибкие поддерживаемые директив сервисов пользовательские интерфейсы случаев предпочтительным своей гибкости простоте тестирования всегда старайтесь проектировать angular-приложения основываясь принципе deep",
    "_version": 0
  },
  {
    "_id": "68c31421f63b80480027399d",
    "title": "Селектор потомком (пробел)",
    "content": "Комбинатор \" \" (пробел) представляет собой 2 или более селекторов, найдёт элементы соответствующие обоим селекторам. Селекторы по потомкам похожи на селекторы дочерних элементов, но они не учитывают вложенность элементов и применяют свои свойства ко всем элементам данного типа, находящимся внутри родительского элемента, независимо от глубины вложенности.\nСинтаксис\nselector1 selector2   { style properties } <p><img src=\"https://ik.imagekit.io/ygtb3rzhz/selector2.png?updatedAt=1757615893203\" alt=\"В\" style=\"max-width: 100%;\"></p>\n",
    "group": "CSS",
    "subGroup": "CSS Basic",
    "ignoreHtml": false,
    "order": 3,
    "imageUrls": "",
    "_created": "2025-09-11T18:25:37.589Z",
    "_changed": "2025-09-12T18:00:02.375Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "селектор",
      "потомком",
      "(пробел)",
      "комбинатор",
      "представляет",
      "собой",
      "или",
      "более",
      "селекторов",
      "найдёт",
      "элементы",
      "соответствующие",
      "обоим",
      "селекторам",
      "селекторы",
      "по",
      "потомкам",
      "похожи",
      "на",
      "дочерних",
      "элементов",
      "но",
      "они",
      "не",
      "учитывают",
      "вложенность",
      "применяют",
      "свои",
      "свойства",
      "ко",
      "всем",
      "элементам",
      "данного",
      "типа",
      "находящимся",
      "внутри",
      "родительского",
      "элемента",
      "независимо",
      "от",
      "глубины",
      "вложенности",
      "синтаксис",
      "selector1",
      "selector2",
      "style",
      "properties",
      "css",
      "basic"
    ],
    "_tags": "api селектор потомком (пробел) комбинатор представляет собой или более селекторов найдёт элементы соответствующие обоим селекторам селекторы по потомкам похожи на дочерних элементов но они не учитывают вложенность применяют свои свойства ко всем элементам данного типа находящимся внутри родительского элемента независимо от глубины вложенности синтаксис selector1 selector2 style properties css basic",
    "_version": 1
  },
  {
    "_id": "68c32a4bf63b804800273b1a",
    "title": "Дженерики ",
    "content": "Дженерики в TypeScript (а значит, и в Angular) позволяют писать код, который может работать с разными типами данных, не указывая конкретный тип во время компиляции. Это обеспечивает типобезопасность и переиспользуемость кода. Дженерики - это мощный инструмент, позволяющий создавать компоненты, сервисы, функции и классы, которые могут адаптироваться к различным типам данных, не теряя при этом преимуществ статической типизации TypeScript.\nЗачем нужны дженерики?\n•   Переиспользуемость кода:  Дженерики позволяют создавать компоненты и функции, которые могут работать с разными типами данных, не требуя дублирования кода.\n•   Типобезопасность:  Дженерики позволяют компилятору проверять типы данных во время компиляции, что помогает предотвратить ошибки во время выполнения.\n•   Читаемость кода:  Дженерики делают код более понятным, поскольку явно указывают типы данных, с которыми работает компонент или функция.\n•   Избежание any:  Дженерики позволяют избежать использования типа any, который отключает проверку типов и может привести к ошибкам во время выполнения.\nКак работают дженерики?\nДженерики определяются с использованием угловых скобок < >. Внутри угловых скобок указывается имя типа-параметра (обычно T, но можно использовать любое допустимое имя типа).  Этот тип-параметр используется для обозначения типа данных, с которым будет работать компонент или функция.\nПримеры использования дженериков в Angular:\n1. Дженерик функция: <p><img src=\"https://ik.imagekit.io/ygtb3rzhz/generic1.png?updatedAt=1757621387836\" alt=\"В\" style=\"max-width: 100%;\"></p><img src=\"https://ik.imagekit.io/ygtb3rzhz/generic2.png?updatedAt=1757621426826\" alt=\"В\" style=\"max-width: 100%;\">\n  *   DataHolder<T> -  Объявляет дженерик класс DataHolder, который может хранить данные любого типа T.\n    *   new DataHolder<string>(\"Hello\") - Создает экземпляр DataHolder, который хранит string.\n4. Дженерик компонент в Angular:\nДженерики можно использовать в Angular компонентах для создания переиспользуемых компонентов, которые могут отображать данные разных типов.\n <p><img src=\"https://ik.imagekit.io/ygtb3rzhz/generic3.png?updatedAt=1757621511999\" alt=\"В\" style=\"max-width: 100%;\"></p> \n *   DataDisplayComponent<T> - Объявляет дженерик компонент DataDisplayComponent, который принимает входной параметр data типа T.\n    *   <app-data-display [data]=\"'Hello'\"> - Использует компонент для отображения строки.\n    *   Тип data определяется автоматически на основе переданного значения.\n5. Дженерик сервис в Angular:\nДженерики также можно использовать в сервисах для работы с разными типами данных, например, для выполнения HTTP-запросов. <p><img src=\"https://ik.imagekit.io/ygtb3rzhz/generic4.png?updatedAt=1757621570512\" alt=\"В\" style=\"max-width: 100%;\"></p> \n  *   ApiService - Дженерик сервис, который использует HttpClient для выполнения HTTP-запросов.\n    *   get<T>(url: string): Observable<T> -  Функция get принимает URL и возвращает Observable типа T.\n    *   this.apiService.get<User[]>('...') -  В UserListComponent мы указываем, что ожидаем получить данные типа User[] из API.",
    "group": "Typescript",
    "subGroup": "Typescript Basic",
    "ignoreHtml": false,
    "order": 1,
    "imageUrls": "",
    "_created": "2025-09-11T20:00:11.573Z",
    "_changed": "2025-09-11T20:00:11.573Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "дженерики",
      "typescript",
      "(а",
      "значит",
      "angular)",
      "позволяют",
      "писать",
      "код",
      "который",
      "может",
      "работать",
      "разными",
      "типами",
      "данных",
      "не",
      "указывая",
      "конкретный",
      "тип",
      "во",
      "время",
      "компиляции",
      "это",
      "обеспечивает",
      "типобезопасность",
      "переиспользуемость",
      "кода",
      "мощный",
      "инструмент",
      "позволяющий",
      "создавать",
      "компоненты",
      "сервисы",
      "функции",
      "классы",
      "которые",
      "могут",
      "адаптироваться",
      "различным",
      "типам",
      "теряя",
      "при",
      "этом",
      "преимуществ",
      "статической",
      "типизации",
      "зачем",
      "нужны",
      "дженерики?",
      "кода:",
      "требуя",
      "дублирования",
      "типобезопасность:",
      "компилятору",
      "проверять",
      "типы",
      "что",
      "помогает",
      "предотвратить",
      "ошибки",
      "выполнения",
      "читаемость",
      "делают",
      "более",
      "понятным",
      "поскольку",
      "явно",
      "указывают",
      "которыми",
      "работает",
      "компонент",
      "или",
      "функция",
      "избежание",
      "any:",
      "избежать",
      "использования",
      "типа",
      "any",
      "отключает",
      "проверку",
      "типов",
      "привести",
      "ошибкам",
      "как",
      "работают",
      "определяются",
      "использованием",
      "угловых",
      "скобок",
      "внутри",
      "указывается",
      "имя",
      "типа-параметра",
      "(обычно",
      "но",
      "можно",
      "использовать",
      "любое",
      "допустимое",
      "типа)",
      "этот",
      "тип-параметр",
      "используется",
      "для",
      "обозначения",
      "которым",
      "будет",
      "примеры",
      "дженериков",
      "angular:",
      "дженерик",
      "функция:",
      "dataholder",
      "объявляет",
      "класс",
      "хранить",
      "данные",
      "любого",
      "new",
      "dataholder(\"hello\")",
      "создает",
      "экземпляр",
      "хранит",
      "string",
      "angular",
      "компонентах",
      "создания",
      "переиспользуемых",
      "компонентов",
      "отображать",
      "разных",
      "datadisplaycomponent",
      "принимает",
      "входной",
      "параметр",
      "data",
      "использует",
      "отображения",
      "строки",
      "определяется",
      "автоматически",
      "на",
      "основе",
      "переданного",
      "значения",
      "сервис",
      "также",
      "сервисах",
      "работы",
      "например",
      "http-запросов",
      "apiservice",
      "httpclient",
      "get(url:",
      "string):",
      "observable",
      "get",
      "url",
      "возвращает",
      "this",
      "get('",
      "')",
      "userlistcomponent",
      "мы",
      "указываем",
      "ожидаем",
      "получить",
      "user[]",
      "из",
      "basic"
    ],
    "_tags": "api дженерики typescript (а значит angular) позволяют писать код который может работать разными типами данных не указывая конкретный тип во время компиляции это обеспечивает типобезопасность переиспользуемость кода мощный инструмент позволяющий создавать компоненты сервисы функции классы которые могут адаптироваться различным типам теряя при этом преимуществ статической типизации зачем нужны дженерики? кода: требуя дублирования типобезопасность: компилятору проверять типы что помогает предотвратить ошибки выполнения читаемость делают более понятным поскольку явно указывают которыми работает компонент или функция избежание any: избежать использования типа any отключает проверку типов привести ошибкам как работают определяются использованием угловых скобок внутри указывается имя типа-параметра (обычно но можно использовать любое допустимое типа) этот тип-параметр используется для обозначения которым будет примеры дженериков angular: дженерик функция: dataholder объявляет класс хранить данные любого new dataholder(\"hello\") создает экземпляр хранит string angular компонентах создания переиспользуемых компонентов отображать разных datadisplaycomponent принимает входной параметр data использует отображения строки определяется автоматически на основе переданного значения сервис также сервисах работы например http-запросов apiservice httpclient get(url: string): observable get url возвращает this get(' ') userlistcomponent мы указываем ожидаем получить user[] из basic",
    "_version": 0
  },
  {
    "_id": "68b9ec05f63b804800268165",
    "title": "Полиморфизм ",
    "content": "Полиморфизм – это еще одна фундаментальная концепция ООП, которая означает \"много форм\". В контексте программирования, полиморфизм позволяет объектам разных классов обрабатываться единообразно, если они реализуют общий интерфейс или унаследованы от общего базового класса.\n\nЗачем нужен полиморфизм?\n• Гибкость и расширяемость: Полиморфизм позволяет добавлять новые типы объектов в систему без изменения существующего кода, который их использует.\n• Упрощение кода: Полиморфизм позволяет писать более общий и переиспользуемый код, который может работать с разными типами объектов.\n• Улучшение читаемости кода: Полиморфизм делает код более понятным, поскольку он скрывает детали реализации конкретных типов объектов и предоставляет единый интерфейс для работы с ними.\n\nВиды полиморфизма:\n\nСуществует два основных вида полиморфизма:\n1. Полиморфизм подтипов (Subtype polymorphism) - осуществляется через  динамический полиморфизм, наиболее распространенный вид полиморфизма, который основан на наследовании или реализации интерфейсов. Объекты дочерних классов или классов, реализующих интерфейс, могут использоваться вместо объектов родительского класса или интерфейса.\n2. Параметрический полиморфизм (Parametric polymorphism): (статический полиморфизм, перегрузка методов) Также известен как \"дженерики\" (generics) или \"шаблоны\" (templates). Позволяет писать код, который работает с разными типами данных, не указывая конкретный тип во время компиляции. В Angular это часто используется с TypeScript.\n\nПолиморфизм в Angular компонентах:\n\nХотя Angular поощряет композицию, полиморфизм также может быть полезен, особенно в ситуациях, когда необходимо обрабатывать разные типы компонентов единообразно.\n\nПримеры:\n\n1. Полиморфизм подтипов (наследование):\n\n•  Базовый компонент (BaseDisplayComponent): Определяет общий интерфейс для отображения данных. <p><img src=\"https://ik.imagekit.io/ygtb3rzhz/oop12.png?updatedAt=1757015570418\" alt=\"В\" style=\"max-width: 100%;\"></p>\n*  Компонент, использующий полиморфизм (DataDisplayComponent): Отображает данные, используя разные компоненты на основе их типа. <p><img src=\"https://ik.imagekit.io/ygtb3rzhz/oop13.png?updatedAt=1757015617383\" alt=\"В\" style=\"max-width: 100%;\"></p>  \nВ этом примере DataDisplayComponent динамически создает экземпляры TextDisplayComponent или NumberDisplayComponent в зависимости от типа данных, которые он получает. Все компоненты, отображающие данные, имеют общий интерфейс (displayData()), определенный в BaseDisplayComponent, что позволяет DataDisplayComponent обрабатывать их единообразно.\n\n3. Параметрический полиморфизм (Generics):\n\nИспользование Generics (Дженериков) в Angular с TypeScript позволяет создавать компоненты, сервисы и функции, работающие с разными типами данных, сохраняя при этом типобезопасность.\n\n•  Сервис для работы с данными разных типов: <p><img src=\"https://ik.imagekit.io/ygtb3rzhz/oop14.png?updatedAt=1757015775517\" alt=\"В\" style=\"max-width: 100%;\"></p> \nВ этом примере DataService использует дженерик <T>, чтобы указать, что он будет возвращать данные типа T.  UserListComponent указывает, что он ожидает получить данные типа User[] из сервиса.  TypeScript обеспечивает типобезопасность, гарантируя, что users всегда будет массивом объектов типа User.\n\nКогда лучше использовать полиморфизм (осторожно):\n\n•   Когда необходимо обрабатывать разные типы объектов единообразно, используя общий интерфейс или базовый класс.\n•   Когда необходимо добавлять новые типы объектов в систему без изменения существующего кода.\n•   Когда необходимо уменьшить дублирование кода и повысить его переиспользуемость.\n\nПредостережения при использовании полиморфизма в Angular:\n\n•   Чрезмерное использование наследования:  Как и в случае с наследованием, чрезмерное использование полиморфизма может привести к созданию сложного и трудно поддерживаемого кода. Старайтесь использовать композицию, где это возможно.\n•   Проблемы с производительностью: Динамическое создание компонентов (как в примере с DataDisplayComponent) может быть затратным с точки зрения производительности. Используйте этот подход только в тех случаях, когда это действительно необходимо.\n\nАльтернативы полиморфизму (часто предпочтительнее):\n\n•   Композиция компонентов:  Вместо использования наследования, можно использовать композицию, чтобы создавать сложные компоненты из небольших, переиспользуемых компонентов.\n•   Стратегии и шаблоны проектирования:  Вместо использования полиморфизма, можно использовать другие шаблоны проектирования, такие как шаблон Strategy, чтобы выбирать алгоритм выполнения во время выполнения.\n\nВ заключение:\n\nПолиморфизм – это мощная концепция ООП, которая может быть полезна в Angular для создания гибких и расширяемых приложений.  Однако, как и в случае с другими концепциями ООП, важно использовать полиморфизм осторожно и обдуманно, и отдавать предпочтение композиции компонентов и другим альтернативным подходам, когда это возможно.  Понимание различных видов полиморфизма и их применений поможет вам создавать более чистый, эффективный и поддерживаемый код.",
    "group": "ООП",
    "subGroup": "Принципы ООП",
    "ignoreHtml": false,
    "order": 4,
    "imageUrls": "",
    "_created": "2025-09-04T19:44:05.805Z",
    "_changed": "2025-09-04T19:48:05.775Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "полиморфизм",
      "это",
      "еще",
      "одна",
      "фундаментальная",
      "концепция",
      "ооп",
      "которая",
      "означает",
      "\"много",
      "форм\"",
      "контексте",
      "программирования",
      "позволяет",
      "объектам",
      "разных",
      "классов",
      "обрабатываться",
      "единообразно",
      "если",
      "они",
      "реализуют",
      "общий",
      "интерфейс",
      "или",
      "унаследованы",
      "от",
      "общего",
      "базового",
      "класса",
      "зачем",
      "нужен",
      "полиморфизм?",
      "гибкость",
      "расширяемость:",
      "добавлять",
      "новые",
      "типы",
      "объектов",
      "систему",
      "без",
      "изменения",
      "существующего",
      "кода",
      "который",
      "их",
      "использует",
      "упрощение",
      "кода:",
      "писать",
      "более",
      "переиспользуемый",
      "код",
      "может",
      "работать",
      "разными",
      "типами",
      "улучшение",
      "читаемости",
      "делает",
      "понятным",
      "поскольку",
      "он",
      "скрывает",
      "детали",
      "реализации",
      "конкретных",
      "типов",
      "предоставляет",
      "единый",
      "для",
      "работы",
      "ними",
      "виды",
      "полиморфизма:",
      "существует",
      "два",
      "основных",
      "вида",
      "подтипов",
      "(subtype",
      "polymorphism)",
      "осуществляется",
      "через",
      "динамический",
      "наиболее",
      "распространенный",
      "вид",
      "полиморфизма",
      "основан",
      "на",
      "наследовании",
      "интерфейсов",
      "объекты",
      "дочерних",
      "реализующих",
      "могут",
      "использоваться",
      "вместо",
      "родительского",
      "интерфейса",
      "параметрический",
      "(parametric",
      "polymorphism):",
      "(статический",
      "перегрузка",
      "методов)",
      "также",
      "известен",
      "как",
      "\"дженерики\"",
      "(generics)",
      "\"шаблоны\"",
      "(templates)",
      "работает",
      "данных",
      "не",
      "указывая",
      "конкретный",
      "тип",
      "во",
      "время",
      "компиляции",
      "angular",
      "часто",
      "используется",
      "typescript",
      "компонентах:",
      "хотя",
      "поощряет",
      "композицию",
      "быть",
      "полезен",
      "особенно",
      "ситуациях",
      "когда",
      "необходимо",
      "обрабатывать",
      "разные",
      "компонентов",
      "примеры:",
      "(наследование):",
      "базовый",
      "компонент",
      "(basedisplaycomponent):",
      "определяет",
      "отображения",
      "использующий",
      "(datadisplaycomponent):",
      "отображает",
      "данные",
      "используя",
      "компоненты",
      "основе",
      "типа",
      "этом",
      "примере",
      "datadisplaycomponent",
      "динамически",
      "создает",
      "экземпляры",
      "textdisplaycomponent",
      "numberdisplaycomponent",
      "зависимости",
      "которые",
      "получает",
      "все",
      "отображающие",
      "имеют",
      "(displaydata())",
      "определенный",
      "basedisplaycomponent",
      "что",
      "(generics):",
      "использование",
      "generics",
      "(дженериков)",
      "создавать",
      "сервисы",
      "функции",
      "работающие",
      "сохраняя",
      "при",
      "типобезопасность",
      "сервис",
      "данными",
      "типов:",
      "dataservice",
      "дженерик",
      "чтобы",
      "указать",
      "будет",
      "возвращать",
      "userlistcomponent",
      "указывает",
      "ожидает",
      "получить",
      "user[]",
      "из",
      "сервиса",
      "обеспечивает",
      "гарантируя",
      "users",
      "всегда",
      "массивом",
      "user",
      "лучше",
      "использовать",
      "(осторожно):",
      "класс",
      "уменьшить",
      "дублирование",
      "повысить",
      "его",
      "переиспользуемость",
      "предостережения",
      "использовании",
      "angular:",
      "чрезмерное",
      "наследования:",
      "случае",
      "наследованием",
      "привести",
      "созданию",
      "сложного",
      "трудно",
      "поддерживаемого",
      "старайтесь",
      "где",
      "возможно",
      "проблемы",
      "производительностью:",
      "динамическое",
      "создание",
      "(как",
      "datadisplaycomponent)",
      "затратным",
      "точки",
      "зрения",
      "производительности",
      "используйте",
      "этот",
      "подход",
      "только",
      "тех",
      "случаях",
      "действительно",
      "альтернативы",
      "полиморфизму",
      "(часто",
      "предпочтительнее):",
      "композиция",
      "компонентов:",
      "использования",
      "наследования",
      "можно",
      "сложные",
      "небольших",
      "переиспользуемых",
      "стратегии",
      "шаблоны",
      "проектирования:",
      "другие",
      "проектирования",
      "такие",
      "шаблон",
      "strategy",
      "выбирать",
      "алгоритм",
      "выполнения",
      "заключение:",
      "мощная",
      "полезна",
      "создания",
      "гибких",
      "расширяемых",
      "приложений",
      "однако",
      "другими",
      "концепциями",
      "важно",
      "осторожно",
      "обдуманно",
      "отдавать",
      "предпочтение",
      "композиции",
      "другим",
      "альтернативным",
      "подходам",
      "понимание",
      "различных",
      "видов",
      "применений",
      "поможет",
      "вам",
      "чистый",
      "эффективный",
      "поддерживаемый",
      "принципы"
    ],
    "_tags": "api полиморфизм это еще одна фундаментальная концепция ооп которая означает \"много форм\" контексте программирования позволяет объектам разных классов обрабатываться единообразно если они реализуют общий интерфейс или унаследованы от общего базового класса зачем нужен полиморфизм? гибкость расширяемость: добавлять новые типы объектов систему без изменения существующего кода который их использует упрощение кода: писать более переиспользуемый код может работать разными типами улучшение читаемости делает понятным поскольку он скрывает детали реализации конкретных типов предоставляет единый для работы ними виды полиморфизма: существует два основных вида подтипов (subtype polymorphism) осуществляется через динамический наиболее распространенный вид полиморфизма основан на наследовании интерфейсов объекты дочерних реализующих могут использоваться вместо родительского интерфейса параметрический (parametric polymorphism): (статический перегрузка методов) также известен как \"дженерики\" (generics) \"шаблоны\" (templates) работает данных не указывая конкретный тип во время компиляции angular часто используется typescript компонентах: хотя поощряет композицию быть полезен особенно ситуациях когда необходимо обрабатывать разные компонентов примеры: (наследование): базовый компонент (basedisplaycomponent): определяет отображения использующий (datadisplaycomponent): отображает данные используя компоненты основе типа этом примере datadisplaycomponent динамически создает экземпляры textdisplaycomponent numberdisplaycomponent зависимости которые получает все отображающие имеют (displaydata()) определенный basedisplaycomponent что (generics): использование generics (дженериков) создавать сервисы функции работающие сохраняя при типобезопасность сервис данными типов: dataservice дженерик чтобы указать будет возвращать userlistcomponent указывает ожидает получить user[] из сервиса обеспечивает гарантируя users всегда массивом user лучше использовать (осторожно): класс уменьшить дублирование повысить его переиспользуемость предостережения использовании angular: чрезмерное наследования: случае наследованием привести созданию сложного трудно поддерживаемого старайтесь где возможно проблемы производительностью: динамическое создание (как datadisplaycomponent) затратным точки зрения производительности используйте этот подход только тех случаях действительно альтернативы полиморфизму (часто предпочтительнее): композиция компонентов: использования наследования можно сложные небольших переиспользуемых стратегии шаблоны проектирования: другие проектирования такие шаблон strategy выбирать алгоритм выполнения заключение: мощная полезна создания гибких расширяемых приложений однако другими концепциями важно осторожно обдуманно отдавать предпочтение композиции другим альтернативным подходам понимание различных видов применений поможет вам чистый эффективный поддерживаемый принципы",
    "_version": 1,
    "editing": false
  },
  {
    "_id": "68c32f58f63b804800273b6f",
    "title": "Module Federation",
    "content": "Module Federation (MF) - это продвинутая архитектурная концепция, которая позволяет разделить Angular (или другие JavaScript/TypeScript) приложения на отдельные, независимо развернутые и управляемые части (модули), которые могут динамически загружаться и использоваться другими приложениями во время выполнения. Это открывает возможности для создания микрофронтендов, построения масштабируемых и гибких архитектур и упрощения процесса разработки и развертывания больших приложений.\nЧто такое микрофронтенды?\nМикрофронтенды - это архитектурный подход, при котором фронтенд приложения разбивается на небольшие, независимые и автономные команды. Каждая команда отвечает за разработку, развертывание и обслуживание своего собственного микрофронтенда. Module Federation является одним из способов реализации микрофронтендов.\n\nОсновные концепции Module Federation:\n•  Host (Контейнер): Это основное приложение, которое динамически загружает и использует модули, предоставляемые другими приложениями. Host определяет точки, в которых он будет загружать удаленные модули.\n•  Remote (Удаленный модуль): Это отдельное приложение, которое предоставляет один или несколько модулей (компоненты, сервисы, модули Angular и т.д.) для использования другими приложениями. Remote публикует манифест, который описывает доступные модули и их местоположение.\n•  Module (Модуль): Это блок кода, который может быть загружен и использован другими приложениями. Модули могут содержать компоненты, сервисы, модули Angular и т.д.\n•  Shared Libraries (Общие библиотеки): Библиотеки (например, Angular, RxJS), которые используются как Host, так и Remote. Module Federation позволяет избежать дублирования этих библиотек, предоставляя возможность использовать общую копию.\n•  Manifest (Манифест): Файл (обычно remoteEntry.js), который публикуется Remote и содержит информацию о доступных модулях, их местоположении и версиях. Host использует манифест для определения, какие модули доступны для загрузки.\n\nПреимущества Module Federation:\n•  Независимое развертывание: Каждая команда может развертывать и обновлять свой микрофронтенд независимо от других команд, что ускоряет процесс разработки и развертывания.\n•  Различные технологии: Микрофронтенды могут быть разработаны с использованием разных технологий и фреймворков (например, Angular, React, Vue.js), что позволяет командам выбирать наиболее подходящие инструменты для своей задачи.\n•  Масштабируемость: Module Federation упрощает масштабирование больших приложений, поскольку позволяет разделить приложение на более мелкие и управляемые части.\n•  Переиспользуемость кода: Модули могут быть переиспользованы в разных приложениях, что уменьшает дублирование кода и повышает эффективность разработки.\n•  Изоляция: Микрофронтенды изолированы друг от друга, что уменьшает риск конфликтов и упрощает отладку.\n•  Постепенная миграция: Module Federation позволяет постепенно мигрировать устаревшие приложения на новые технологии, разрабатывая новые микрофронтенды и интегрируя их в существующее приложение.\n•  Автономные команды: Разделение приложения на микрофронтенды позволяет формировать небольшие, автономные команды, которые несут полную ответственность за свой участок работы.\n\nПример реализации Module Federation в Angular:\n <p><img src=\"https://ik.imagekit.io/ygtb3rzhz/MF.png?updatedAt=1757622702995\" alt=\"В\" style=\"max-width: 100%;\"></p> \napp.component\n <p><img src=\"https://ik.imagekit.io/ygtb3rzhz/mf2.png?updatedAt=1757622831199\" alt=\"В\" style=\"max-width: 100%;\"></p> \n",
    "group": "Прочее",
    "subGroup": "DevOps",
    "ignoreHtml": false,
    "order": 1,
    "imageUrls": "",
    "_created": "2025-09-11T20:21:44.881Z",
    "_changed": "2025-09-11T20:21:44.881Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "module",
      "federation",
      "(mf)",
      "это",
      "продвинутая",
      "архитектурная",
      "концепция",
      "которая",
      "позволяет",
      "разделить",
      "angular",
      "(или",
      "другие",
      "javascript/typescript)",
      "приложения",
      "на",
      "отдельные",
      "независимо",
      "развернутые",
      "управляемые",
      "части",
      "(модули)",
      "которые",
      "могут",
      "динамически",
      "загружаться",
      "использоваться",
      "другими",
      "приложениями",
      "во",
      "время",
      "выполнения",
      "открывает",
      "возможности",
      "для",
      "создания",
      "микрофронтендов",
      "построения",
      "масштабируемых",
      "гибких",
      "архитектур",
      "упрощения",
      "процесса",
      "разработки",
      "развертывания",
      "больших",
      "приложений",
      "что",
      "такое",
      "микрофронтенды?",
      "микрофронтенды",
      "архитектурный",
      "подход",
      "при",
      "котором",
      "фронтенд",
      "разбивается",
      "небольшие",
      "независимые",
      "автономные",
      "команды",
      "каждая",
      "команда",
      "отвечает",
      "за",
      "разработку",
      "развертывание",
      "обслуживание",
      "своего",
      "собственного",
      "микрофронтенда",
      "является",
      "одним",
      "из",
      "способов",
      "реализации",
      "основные",
      "концепции",
      "federation:",
      "host",
      "(контейнер):",
      "основное",
      "приложение",
      "которое",
      "загружает",
      "использует",
      "модули",
      "предоставляемые",
      "определяет",
      "точки",
      "которых",
      "он",
      "будет",
      "загружать",
      "удаленные",
      "remote",
      "(удаленный",
      "модуль):",
      "отдельное",
      "предоставляет",
      "один",
      "или",
      "несколько",
      "модулей",
      "(компоненты",
      "сервисы",
      "использования",
      "публикует",
      "манифест",
      "который",
      "описывает",
      "доступные",
      "их",
      "местоположение",
      "(модуль):",
      "блок",
      "кода",
      "может",
      "быть",
      "загружен",
      "использован",
      "содержать",
      "компоненты",
      "shared",
      "libraries",
      "(общие",
      "библиотеки):",
      "библиотеки",
      "(например",
      "rxjs)",
      "используются",
      "как",
      "так",
      "избежать",
      "дублирования",
      "этих",
      "библиотек",
      "предоставляя",
      "возможность",
      "использовать",
      "общую",
      "копию",
      "manifest",
      "(манифест):",
      "файл",
      "(обычно",
      "remoteentry",
      "js)",
      "публикуется",
      "содержит",
      "информацию",
      "доступных",
      "модулях",
      "местоположении",
      "версиях",
      "определения",
      "какие",
      "доступны",
      "загрузки",
      "преимущества",
      "независимое",
      "развертывание:",
      "развертывать",
      "обновлять",
      "свой",
      "микрофронтенд",
      "от",
      "других",
      "команд",
      "ускоряет",
      "процесс",
      "различные",
      "технологии:",
      "разработаны",
      "использованием",
      "разных",
      "технологий",
      "фреймворков",
      "react",
      "vue",
      "командам",
      "выбирать",
      "наиболее",
      "подходящие",
      "инструменты",
      "своей",
      "задачи",
      "масштабируемость:",
      "упрощает",
      "масштабирование",
      "поскольку",
      "более",
      "мелкие",
      "переиспользуемость",
      "кода:",
      "переиспользованы",
      "приложениях",
      "уменьшает",
      "дублирование",
      "повышает",
      "эффективность",
      "изоляция:",
      "изолированы",
      "друг",
      "друга",
      "риск",
      "конфликтов",
      "отладку",
      "постепенная",
      "миграция:",
      "постепенно",
      "мигрировать",
      "устаревшие",
      "новые",
      "технологии",
      "разрабатывая",
      "интегрируя",
      "существующее",
      "команды:",
      "разделение",
      "формировать",
      "несут",
      "полную",
      "ответственность",
      "участок",
      "работы",
      "пример",
      "angular:",
      "app",
      "component",
      "прочее",
      "devops"
    ],
    "_tags": "api module federation (mf) это продвинутая архитектурная концепция которая позволяет разделить angular (или другие javascript/typescript) приложения на отдельные независимо развернутые управляемые части (модули) которые могут динамически загружаться использоваться другими приложениями во время выполнения открывает возможности для создания микрофронтендов построения масштабируемых гибких архитектур упрощения процесса разработки развертывания больших приложений что такое микрофронтенды? микрофронтенды архитектурный подход при котором фронтенд разбивается небольшие независимые автономные команды каждая команда отвечает за разработку развертывание обслуживание своего собственного микрофронтенда является одним из способов реализации основные концепции federation: host (контейнер): основное приложение которое загружает использует модули предоставляемые определяет точки которых он будет загружать удаленные remote (удаленный модуль): отдельное предоставляет один или несколько модулей (компоненты сервисы использования публикует манифест который описывает доступные их местоположение (модуль): блок кода может быть загружен использован содержать компоненты shared libraries (общие библиотеки): библиотеки (например rxjs) используются как так избежать дублирования этих библиотек предоставляя возможность использовать общую копию manifest (манифест): файл (обычно remoteentry js) публикуется содержит информацию доступных модулях местоположении версиях определения какие доступны загрузки преимущества независимое развертывание: развертывать обновлять свой микрофронтенд от других команд ускоряет процесс различные технологии: разработаны использованием разных технологий фреймворков react vue командам выбирать наиболее подходящие инструменты своей задачи масштабируемость: упрощает масштабирование поскольку более мелкие переиспользуемость кода: переиспользованы приложениях уменьшает дублирование повышает эффективность изоляция: изолированы друг друга риск конфликтов отладку постепенная миграция: постепенно мигрировать устаревшие новые технологии разрабатывая интегрируя существующее команды: разделение формировать несут полную ответственность участок работы пример angular: app component прочее devops",
    "_version": 0
  },
  {
    "_id": "68c46dc8f63b8048002753be",
    "title": "Операторы Spread и Rest",
    "content": "\nОператоры Spread и Rest в JavaScript используют один и тот же синтаксис (три точки ...), но выполняют противоположные функции: Spread распаковывает элементы массива или объекта, а Rest собирает их в новый массив. Spread используется для копирования, объединения и передачи элементов, а Rest — для сбора оставшихся элементов в функции или при деструктуризации. \n<b>Оператор Spread (оператор расширения)</b>\nSpread используется для \"распаковки\" элементов массива или свойств объекта. \nПрименение:\nКопирование массивов: Создает поверхностную копию массива, не меняя оригинал.\nОбъединение массивов: Позволяет объединить несколько массивов в один.\nПередача аргументов: Может передавать элементы массива как отдельные аргументы в функцию.\nРабота с объектами: Позволяет расширять свойства одного объекта свойствами другого, создавая новый объект. \nПример:\n<pre><code>const arr1 = [1, 2];\nconst arr2 = [3, 4];\nconst combinedArr = [...arr1, ...arr2]; // combinedArr будет [1, 2, 3, 4]\n\nconst obj1 = { a: 1 };\nconst obj2 = { b: 2 };\nconst combinedObj = { ...obj1, ...obj2 }; // combinedObj будет { a: 1, b: 2 } </code></pre>\n<b>Оператор Rest (оператор сбора)</b>\nRest используется для \"сбора\" оставшихся элементов в массив или объект. \nПрименение:\nВ параметрах функций: Собирает все оставшиеся аргументы в массив.\nВ деструктуризации: Позволяет собрать оставшиеся элементы массива или свойства объекта в новый массив или объект. \nПример:\n<pre><code>javascript\nfunction sum(a, ...numbers) { // numbers будет массивом [3, 4, 5] [5]\n  return a + numbers.reduce((total, num) => total + num, 0);\n}\nsum(1, 2, 3, 4, 5); // 15\n\nconst [first, second, ...restOfItems] = ['apple', 'banana', 'orange', 'grape']\n</code></pre>",
    "group": "Typescript",
    "subGroup": "Typescript Basic",
    "ignoreHtml": false,
    "order": 5,
    "imageUrls": "",
    "_created": "2025-09-12T19:00:24.151Z",
    "_changed": "2025-10-13T17:26:58.351Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "операторы",
      "spread",
      "rest",
      "javascript",
      "используют",
      "один",
      "тот",
      "же",
      "синтаксис",
      "(три",
      "точки",
      "но",
      "выполняют",
      "противоположные",
      "функции:",
      "распаковывает",
      "элементы",
      "массива",
      "или",
      "объекта",
      "собирает",
      "их",
      "новый",
      "массив",
      "используется",
      "для",
      "копирования",
      "объединения",
      "передачи",
      "элементов",
      "сбора",
      "оставшихся",
      "функции",
      "при",
      "деструктуризации",
      "оператор",
      "(оператор",
      "расширения)",
      "\"распаковки\"",
      "свойств",
      "применение:",
      "копирование",
      "массивов:",
      "создает",
      "поверхностную",
      "копию",
      "не",
      "меняя",
      "оригинал",
      "объединение",
      "позволяет",
      "объединить",
      "несколько",
      "массивов",
      "передача",
      "аргументов:",
      "может",
      "передавать",
      "как",
      "отдельные",
      "аргументы",
      "функцию",
      "работа",
      "объектами:",
      "расширять",
      "свойства",
      "одного",
      "свойствами",
      "другого",
      "создавая",
      "объект",
      "пример:",
      "const",
      "arr1",
      "[1",
      "2];",
      "arr2",
      "[3",
      "4];",
      "combinedarr",
      "arr2];",
      "//",
      "будет",
      "4]",
      "obj1",
      "a:",
      "};",
      "obj2",
      "b:",
      "combinedobj",
      "сбора)",
      "\"сбора\"",
      "параметрах",
      "функций:",
      "все",
      "оставшиеся",
      "деструктуризации:",
      "собрать",
      "function",
      "sum(a",
      "numbers)",
      "numbers",
      "массивом",
      "5]",
      "[5]",
      "return",
      "reduce((total",
      "num)",
      "=>",
      "total",
      "num",
      "0);",
      "sum(1",
      "5);",
      "15",
      "[first",
      "second",
      "restofitems]",
      "['apple'",
      "'banana'",
      "'orange'",
      "'grape']",
      "typescript",
      "basic"
    ],
    "_tags": "api операторы spread rest javascript используют один тот же синтаксис (три точки но выполняют противоположные функции: распаковывает элементы массива или объекта собирает их новый массив используется для копирования объединения передачи элементов сбора оставшихся функции при деструктуризации оператор (оператор расширения) \"распаковки\" свойств применение: копирование массивов: создает поверхностную копию не меняя оригинал объединение позволяет объединить несколько массивов передача аргументов: может передавать как отдельные аргументы функцию работа объектами: расширять свойства одного свойствами другого создавая объект пример: const arr1 [1 2]; arr2 [3 4]; combinedarr arr2]; // будет 4] obj1 a: }; obj2 b: combinedobj сбора) \"сбора\" параметрах функций: все оставшиеся деструктуризации: собрать function sum(a numbers) numbers массивом 5] [5] return reduce((total num) => total num 0); sum(1 5); 15 [first second restofitems] ['apple' 'banana' 'orange' 'grape'] typescript basic",
    "_version": 3
  },
  {
    "_id": "68c46bacf63b804800275399",
    "title": "Flexbox",
    "content": "    Долгое время веб-интерфейсы были статичными — сайты разрабатывались и просматривались только на экранах мониторов стационарных компьютеров. Однако с десяток лет назад, совсем недавно по историческим меркам, у нас появилось огромное разнообразие экранов — от мобильных телефонов до телевизоров, — на которых мы можем взаимодействовать с сайтами. Так родилась необходимость в гибких системах раскладки.\n     Идея флексбоксов появилась ещё в 2009 году, и этот стандарт до сих пор развивается и прорабатывается. Основная идея флексов — гибкое распределение места между элементами, гибкая расстановка, выравнивание, гибкое управление. Ключевое слово — гибкое, что и отражено в названии (flex — англ. гибко).\nОсновные термины Скопировать ссылку \"Основные термины\"\nФлекс-контейнер: элемент, к которому применяется свойство display: flex. Вложенные в него элементы подчиняются правилам раскладки флексов.\nФлекс-элемент: элемент, вложенный во флекс-контейнер.\nКогда мы задаём какому-то элементу значение flex для свойства display, мы превращаем этот элемент в флекс-контейнер. Внутри него начинает действовать флекс-контекст, его дочерние элементы начинают подчиняться свойствам флексбокса.\n    Снаружи флекс-контейнер выглядит как блочный элемент — занимает всю ширину родителя, следующие за ним элементы в разметке переносятся на новую строку.\n.container {\n  display: flex;\n  flex-direction: column;\n}\n<div style=\"display:flex; flex-direction: column;\">\n  <div style=\"border: 1px solid red\" >item</div>\n  <div style=\"border: 1px solid red\">item</div>\n  <div style=\"border: 1px solid red\" >item</div>\n</div>\n    Если контейнеру задано значение inline-flex, то снаружи он начинает вести себя как строчный (инлайн) элемент — размеры зависят только от внутреннего контента, встаёт в строку с другими элементами. Внутри это ровно такой же флекс-контейнер, как и при предыдущем значении.\n.container {\n  display: inline-flex;\n}\n     <b>flex-direction</b> \nСвойство управления направлением основной и поперечной осей.\n.container {\n  display: flex;\n  flex-direction: row;\n}\n<div style=\"display:flex; flex-direction: row;\">\n  <div style=\"border: 1px solid red\" >item</div>\n  <div style=\"border: 1px solid red\">item</div>\n  <div style=\"border: 1px solid red\" >item</div>\n</div>\n     Возможные значения:\n     row (значение по умолчанию) — основная ось идёт горизонтально слева направо, поперечная ось идёт вертикально сверху вниз.\n     row-reverse — основная ось идёт горизонтально справа налево, поперечная ось идёт вертикально сверху вниз.\n     column — основная ось идёт вертикально сверху вниз, поперечная ось идёт горизонтально слева направо.\n     column-reverse — основная ось идёт вертикально снизу вверх, поперечная ось идёт горизонтально слева направо.\n.container {\n  display: flex;\n  flex-direction: row-reverse;\n}\n<div style=\"display:flex; flex-direction: row-reverse;\">\n  <div style=\"border: 1px solid red\" >item</div>\n  <div style=\"border: 1px solid red\">item</div>\n  <div style=\"border: 1px solid red\" >item</div>\n</div>\n     Важный момент: на сайтах с направлением текста справа налево, например, на сайте на арабском языке, для значений row и row-reverse основная ось будет идти в обратном направлении. Для значений column и column-reverse своё направление поменяет поперечная ось.\n    <b>flex-wrap </b>\n.container {\n  display: flex;\n  flex-direction: row;\n  flex-wrap: wrap;\n  width:90px\n}\n<div style=\"display:flex; flex-wrap: wrap; flex-direction: row; width:90px\">\n  <div style=\"border: 1px solid red\" >item</div>\n  <div style=\"border: 1px solid red\">item</div>\n  <div style=\"border: 1px solid red\" >item</div>\n  <div style=\"border: 1px solid red\" >item</div>\n  <div style=\"border: 1px solid red\" >item</div>\n</div>\n<b>flex-flow </b>\nЭто свойство-шорткат для одновременного определения значений свойств flex-direction и flex-wrap.\n.container {\n  display: flex;\n  flex-flow: column wrap;\n}\n\n    <b>justify-content</b> \n    Свойство позволяет выравнивать флекс-элементы внутри флекс-контейнера по основной оси.\nВозможные значения:\nstart — элементы прижимаются к тому краю, откуда начинается чтение на том языке, на котором отображается сайт.\nend — элементы прижимаются к краю, противоположному началу направления чтения на языке сайта.\nflex-start — элементы прижимаются к краю, от которого начинается основная ось.\nflex-end — элементы прижимаются к краю, у которого основная ось заканчивается.\nleft — элементы прижмутся к левому краю родителя.\nright — элементы прижмутся к правому краю родителя.\ncenter — элементы выстраиваются по центру родителя.\nspace-between — крайние элементы прижимаются к краям родителя, оставшиеся выстраиваются внутри контейнера равномерно, так, чтобы между ними были одинаковые отступы.\nspace-around — свободное пространство делится поровну между элементами и по половине от этой доли размещается по бокам от каждого элемента. Таким образом, между соседними элементами будет равное расстояние, а снаружи крайних элементов — по половине этого расстояния.\nspace-evenly — свободное место будет распределено так, чтобы расстояние между любыми двумя элементами было одинаковым и расстояние от крайних элементов до края было таким же..\ncontainer {\n  display: flex;\n  flex-direction: row;\n  flex-wrap: wrap;\n  justify-content: space-between;\n}\n<div style=\"display:flex; flex-wrap: wrap; flex-direction: row; justify-content:space-between;\">\n  <div style=\"border: 1px solid red\" >item</div>\n  <div style=\"border: 1px solid red\">item</div>\n  <div style=\"border: 1px solid red\" >item</div>\n  <div style=\"border: 1px solid red\" >item</div>\n  <div style=\"border: 1px solid red\" >item</div>\n</div>\n\n    <b>align-items </b>\n     Свойство выравнивания элементов внутри контейнера по поперечной оси.\n      Возможные значения:\nstretch (значение по умолчанию) — элементы растягиваются вдоль поперечной оси так, чтобы заполнить всего родителя. Это очень удобно, если вы делаете двухколоночный макет. Раньше приходилось при помощи разных костылей добиваться одинаковой высоты, а теперь достаточно сделать контейнер флексом, и колонки по умолчанию будут одной высоты.\nflex-start или start — элементы выстраиваются у начала поперечной оси. Разница между ними лишь в том, что второе значение «уважает» направление чтения выбранного языка.\nflex-end или end — элементы выстраиваются у конца поперечной оси. Разница между первым и вторым значениями аналогична предыдущему пункту.\ncenter — элементы выстраиваются по центру поперечной оси.\nbaseline — элементы выравниваются по базовой линии текста. «Базовая линия» — baseline — воображаемая линия, проходящая по нижнему краю знаков шрифта (без учёта выносных элементов).\ncontainer {\n  display: flex;\n  flex-direction: row;\n  flex-wrap: wrap;\n  justify-content: space-between;\n  align-items:center;\n  height: 220px;\n  border: 1px solid red;\n}\n<div style=\"display:flex; flex-wrap: wrap; flex-direction: row; justify-content:space-between; align-items:center; height: 220px;border: 1px solid red;\">\n  <div style=\"border: 1px solid red\" >item</div>\n  <div style=\"border: 1px solid red\">item</div>\n  <div style=\"border: 1px solid red\" >item</div>\n  <div style=\"border: 1px solid red\" >item</div>\n  <div style=\"border: 1px solid red\" >item</div>\n</div>\n\n    <b>align-content</b> \n.container {\n  display: flex;\n  align-content: center;\n}\n     Свойство распределяет свободное пространство по поперечной оси между рядами флекс-элементов. Предположим, у вас 11 элементов в 3 рядах. Если размер родителя по поперечной оси позволяет, то при помощи align-content можно распределять строчки элементов: по верхнему краю, по нижнему, по центру или равномерно.\n     Не имеет видимого значения, если элементы располагаются в один ряд.\n     Возможные значения:\nstretch (значение по умолчанию) — ряды растягиваются одинаково, так, чтобы занять всё доступное пространство родителя.\nflex-start / start — все ряды располагаются у начала поперечной оси. Первое значение не зависит от направления чтения текущего языка, в отличие от второго.\nflex-end / end — все ряды располагаются у конца поперечной оси. end «уважает» направление чтения текущего языка.\ncenter — ряды выравниваются по центру родителя.\nspace-between — первый ряд прижимается к началу поперечной оси, последний — к концу поперечной оси, а остальные располагаются так, чтобы свободное пространство было поделено на отступы между ними равномерно.\nspace-around — отступы у каждого ряда равнозначны отступам у любого другого ряда.\nspace-evenly — отступы между рядами и от краёв родителя одинаковые.\n\n     <b>gap</b>\nС помощью этого свойства можно с лёгкостью задавать отступы между строками и столбцами.\n     Является краткой записью свойств row-gap и column-gap.\n     Может иметь одно или два значения. Если указано только одно, то column-gap автоматически равен row-gap. Если указаны два значения, то первое будет задавать отступы между рядами (row-gap), а второе — между колонками (column-gap).\n\n     Значения можно указывать в любых доступных единицах измерения, включая проценты.\n     Допускается использование функции calc().\n\n.container {\n  display: flex;\n  gap: 30px calc(10rem - 10px);\n}\nСвойства флекс-элемента Скопировать ссылку \"Свойства флекс-элемента\"\n    \n    <b>order</b>\n    При помощи свойства order можно менять порядок отображения флекс-элементов внутри флекс-контейнера.\n     По умолчанию элементы отображаются в том порядке, в котором они расположены в разметке, а значение свойства order равно 0.\n     Значение задаётся в виде целого отрицательного или положительного числа. Элементы встают по возрастающей.\n.container {\n  display:flex; \n  flex-direction: row;\n}\n.item4 {\n  order: -1;\n}\n<div style=\"display:flex; flex-direction: row;\">\n  <div style=\"border: 1px solid red\" >item1</div>\n  <div style=\"border: 1px solid red\">item2</div>\n  <div style=\"border: 1px solid red\">item3</div>\n  <div style=\"border: 1px solid red; order: -1;\">item4</div>\n</div>\n\nflex-grow\n.container {\n  display: flex;\n}\n.item {\n  flex-grow: 1;\n}\nЭто свойство указывает, может ли вырастать флекс-элемент при наличии свободного места, и насколько. По умолчанию значение равно 0. Значением может быть любое положительное целое число (включая 0).\nЕсли у всех флекс-элементов будет прописано flex-grow: 1, то свободное пространство в контейнере будет равномерно распределено между всеми.\nЕсли при этом одному из элементов мы зададим flex-grow: 2, то он постарается занять в два раза больше свободного места, чем его соседи.\n\nflex-shrink\n.container {\n  display: flex;\n}\n\n.item {\n  flex-shrink: 3;\n}\n\nСвойство flex-shrink полностью противоположно свойству flex-grow. Если в контейнере не хватает места для расположения всех элементов без изменения размеров, то свойство flex-shrink указывает, в каких пропорциях элемент будет уменьшаться.\n\nЧем больше значение у этого свойства, тем быстрее элемент будет сжиматься по сравнению с соседями, имеющими меньшее значение.\n\nЗначение по умолчанию — 1. Значением может быть любое целое положительное число (включая 0).\n\nДва предыдущих свойства работают с пропорциональным разделением пространства, не с конкретными размерами. Они довольно непростые, даже опытный разработчик не всегда знает, как они в точности работают. Загляните в конец статьи, если хотите подробнее почитать о каждом из них.\n\nflex-basis\n.container {\n  display: flex;\n}\n\n.item {\n  flex-basis: 250px;\n}\n\nСвойство flex-basis указывает на размер элемента до того, как свободное место будет распределено (см. flex-grow).\n\nЗначением может быть размер в любых относительных или абсолютных единицах: 20rem, 5vw, 250px. А также можно использовать ключевое слово auto (значение по умолчанию). В этом случае при расчёте размера элемента будут приниматься во внимание значения свойств width, max-width, min-width или аналогичные свойства высоты, в зависимости от того, в каком направлении идёт основная ось.\n\nЕсли никакие размеры не заданы, а свойству flex-basis установлено значение auto, то элемент занимает столько пространства, сколько нужно для отображения контента.\n\nflex\n.container {\n  display: flex;\n}\n\n.item {\n  flex: 1 1 auto;\n}\n\nСвойство-шорткат, с помощью которого можно указать значение трёх свойств одновременно: flex-grow, flex-shrink и flex-basis. Первое значение является обязательным, остальные опциональны.\n\nЗначение по умолчанию: 0 1 auto, что расшифровывается как flex-grow: 0, flex-shrink: 1, flex-basis: auto.\n\nВозможные значения:\n\n/* 0 0 auto */\nflex: none;\n\n/* Одно значение, число без единиц: flex-grow */\nflex: 2;\n\n/* Одно значение, ширина/высота: flex-basis */\nflex: 10em;\nflex: 30px;\nflex: auto;\nflex: content;\n\n/* Два значения: flex-grow | flex-basis */\nflex: 1 30px;\n\n/* Два значения: flex-grow | flex-shrink */\nflex: 2 2;\n\n/* Три значения: flex-grow | flex-shrink | flex-basis */\nflex: 2 2 10%;\n\n/* Глобальные значения */\nflex: inherit;\nflex: initial;\nflex: unset;\n\nalign-self\n.container {\n  display: flex;\n  align-items: flex-start;\n}\n\n.item {\n  align-self: flex-end;\n}\nПри помощи этого свойства можно выровнять один или несколько элементов иначе, чем задано у родительского элемента. Например, в коде выше у родителя задано выравнивание вложенных элементов по верхнему краю родителя. А для элемента с классом .item мы задаём выравнивание по нижнему краю.\n",
    "group": "CSS",
    "subGroup": "CSS Basic",
    "ignoreHtml": false,
    "order": 4,
    "imageUrls": "",
    "_created": "2025-09-12T18:51:24.467Z",
    "_changed": "2025-09-12T18:51:24.467Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "flexbox",
      "долгое",
      "время",
      "веб-интерфейсы",
      "были",
      "статичными",
      "сайты",
      "разрабатывались",
      "просматривались",
      "только",
      "на",
      "экранах",
      "мониторов",
      "стационарных",
      "компьютеров",
      "однако",
      "десяток",
      "лет",
      "назад",
      "совсем",
      "недавно",
      "по",
      "историческим",
      "меркам",
      "нас",
      "появилось",
      "огромное",
      "разнообразие",
      "экранов",
      "от",
      "мобильных",
      "телефонов",
      "до",
      "телевизоров",
      "которых",
      "мы",
      "можем",
      "взаимодействовать",
      "сайтами",
      "так",
      "родилась",
      "необходимость",
      "гибких",
      "системах",
      "раскладки",
      "идея",
      "флексбоксов",
      "появилась",
      "ещё",
      "2009",
      "году",
      "этот",
      "стандарт",
      "сих",
      "пор",
      "развивается",
      "прорабатывается",
      "основная",
      "флексов",
      "гибкое",
      "распределение",
      "места",
      "между",
      "элементами",
      "гибкая",
      "расстановка",
      "выравнивание",
      "управление",
      "ключевое",
      "слово",
      "что",
      "отражено",
      "названии",
      "(flex",
      "англ",
      "гибко)",
      "основные",
      "термины",
      "скопировать",
      "ссылку",
      "\"основные",
      "термины\"",
      "флекс-контейнер:",
      "элемент",
      "которому",
      "применяется",
      "свойство",
      "display:",
      "flex",
      "вложенные",
      "него",
      "элементы",
      "подчиняются",
      "правилам",
      "флекс-элемент:",
      "вложенный",
      "во",
      "флекс-контейнер",
      "когда",
      "задаём",
      "какому-то",
      "элементу",
      "значение",
      "для",
      "свойства",
      "display",
      "превращаем",
      "внутри",
      "начинает",
      "действовать",
      "флекс-контекст",
      "его",
      "дочерние",
      "начинают",
      "подчиняться",
      "свойствам",
      "флексбокса",
      "снаружи",
      "выглядит",
      "как",
      "блочный",
      "занимает",
      "всю",
      "ширину",
      "родителя",
      "следующие",
      "за",
      "ним",
      "разметке",
      "переносятся",
      "новую",
      "строку",
      "container",
      "flex;",
      "flex-direction:",
      "column;",
      "item",
      "если",
      "контейнеру",
      "задано",
      "inline-flex",
      "то",
      "он",
      "вести",
      "себя",
      "строчный",
      "(инлайн)",
      "размеры",
      "зависят",
      "внутреннего",
      "контента",
      "встаёт",
      "другими",
      "это",
      "ровно",
      "такой",
      "же",
      "при",
      "предыдущем",
      "значении",
      "inline-flex;",
      "flex-direction",
      "управления",
      "направлением",
      "основной",
      "поперечной",
      "осей",
      "row;",
      "возможные",
      "значения:",
      "row",
      "(значение",
      "умолчанию)",
      "ось",
      "идёт",
      "горизонтально",
      "слева",
      "направо",
      "поперечная",
      "вертикально",
      "сверху",
      "вниз",
      "row-reverse",
      "справа",
      "налево",
      "column",
      "column-reverse",
      "снизу",
      "вверх",
      "row-reverse;",
      "важный",
      "момент:",
      "сайтах",
      "текста",
      "например",
      "сайте",
      "арабском",
      "языке",
      "значений",
      "будет",
      "идти",
      "обратном",
      "направлении",
      "своё",
      "направление",
      "поменяет",
      "flex-wrap",
      "flex-wrap:",
      "wrap;",
      "width:90px",
      "flex-flow",
      "свойство-шорткат",
      "одновременного",
      "определения",
      "свойств",
      "flex-flow:",
      "justify-content",
      "позволяет",
      "выравнивать",
      "флекс-элементы",
      "флекс-контейнера",
      "оси",
      "start",
      "прижимаются",
      "тому",
      "краю",
      "откуда",
      "начинается",
      "чтение",
      "том",
      "котором",
      "отображается",
      "сайт",
      "end",
      "противоположному",
      "началу",
      "направления",
      "чтения",
      "сайта",
      "flex-start",
      "которого",
      "flex-end",
      "заканчивается",
      "left",
      "прижмутся",
      "левому",
      "right",
      "правому",
      "center",
      "выстраиваются",
      "центру",
      "space-between",
      "крайние",
      "краям",
      "оставшиеся",
      "контейнера",
      "равномерно",
      "чтобы",
      "ними",
      "одинаковые",
      "отступы",
      "space-around",
      "свободное",
      "пространство",
      "делится",
      "поровну",
      "половине",
      "этой",
      "доли",
      "размещается",
      "бокам",
      "каждого",
      "элемента",
      "таким",
      "образом",
      "соседними",
      "равное",
      "расстояние",
      "крайних",
      "элементов",
      "этого",
      "расстояния",
      "space-evenly",
      "место",
      "распределено",
      "любыми",
      "двумя",
      "было",
      "одинаковым",
      "края",
      "justify-content:",
      "space-between;",
      "align-items",
      "выравнивания",
      "stretch",
      "растягиваются",
      "вдоль",
      "заполнить",
      "всего",
      "очень",
      "удобно",
      "вы",
      "делаете",
      "двухколоночный",
      "макет",
      "раньше",
      "приходилось",
      "помощи",
      "разных",
      "костылей",
      "добиваться",
      "одинаковой",
      "высоты",
      "теперь",
      "достаточно",
      "сделать",
      "контейнер",
      "флексом",
      "колонки",
      "умолчанию",
      "будут",
      "одной",
      "или",
      "начала",
      "разница",
      "лишь",
      "второе",
      "«уважает»",
      "выбранного",
      "языка",
      "конца",
      "первым",
      "вторым",
      "значениями",
      "аналогична",
      "предыдущему",
      "пункту",
      "baseline",
      "выравниваются",
      "базовой",
      "линии",
      "«базовая",
      "линия»",
      "воображаемая",
      "линия",
      "проходящая",
      "нижнему",
      "знаков",
      "шрифта",
      "(без",
      "учёта",
      "выносных",
      "элементов)",
      "align-items:center;",
      "height:",
      "220px;",
      "border:",
      "1px",
      "solid",
      "red;",
      "align-content",
      "align-content:",
      "center;",
      "распределяет",
      "рядами",
      "флекс-элементов",
      "предположим",
      "вас",
      "11",
      "рядах",
      "размер",
      "можно",
      "распределять",
      "строчки",
      "элементов:",
      "верхнему",
      "не",
      "имеет",
      "видимого",
      "значения",
      "располагаются",
      "один",
      "ряд",
      "ряды",
      "одинаково",
      "занять",
      "всё",
      "доступное",
      "все",
      "первое",
      "зависит",
      "текущего",
      "отличие",
      "второго",
      "первый",
      "прижимается",
      "последний",
      "концу",
      "остальные",
      "поделено",
      "ряда",
      "равнозначны",
      "отступам",
      "любого",
      "другого",
      "краёв",
      "gap",
      "помощью",
      "лёгкостью",
      "задавать",
      "строками",
      "столбцами",
      "является",
      "краткой",
      "записью",
      "row-gap",
      "column-gap",
      "может",
      "иметь",
      "одно",
      "два",
      "указано",
      "автоматически",
      "равен",
      "указаны",
      "(row-gap)",
      "колонками",
      "(column-gap)",
      "указывать",
      "любых",
      "доступных",
      "единицах",
      "измерения",
      "включая",
      "проценты",
      "допускается",
      "использование",
      "функции",
      "calc()",
      "gap:",
      "30px",
      "calc(10rem",
      "10px);",
      "флекс-элемента",
      "\"свойства",
      "флекс-элемента\"",
      "order",
      "менять",
      "порядок",
      "отображения",
      "отображаются",
      "порядке",
      "они",
      "расположены",
      "равно",
      "задаётся",
      "виде",
      "целого",
      "отрицательного",
      "положительного",
      "числа",
      "встают",
      "возрастающей",
      "display:flex;",
      "item4",
      "order:",
      "-1;",
      "item1",
      "item2",
      "item3",
      "flex-grow",
      "flex-grow:",
      "1;",
      "указывает",
      "ли",
      "вырастать",
      "флекс-элемент",
      "наличии",
      "свободного",
      "насколько",
      "значением",
      "быть",
      "любое",
      "положительное",
      "целое",
      "число",
      "(включая",
      "0)",
      "всех",
      "прописано",
      "контейнере",
      "всеми",
      "этом",
      "одному",
      "из",
      "зададим",
      "постарается",
      "раза",
      "больше",
      "чем",
      "соседи",
      "flex-shrink",
      "flex-shrink:",
      "3;",
      "полностью",
      "противоположно",
      "свойству",
      "хватает",
      "расположения",
      "без",
      "изменения",
      "размеров",
      "каких",
      "пропорциях",
      "уменьшаться",
      "тем",
      "быстрее",
      "сжиматься",
      "сравнению",
      "соседями",
      "имеющими",
      "меньшее",
      "предыдущих",
      "работают",
      "пропорциональным",
      "разделением",
      "пространства",
      "конкретными",
      "размерами",
      "довольно",
      "непростые",
      "даже",
      "опытный",
      "разработчик",
      "всегда",
      "знает",
      "точности",
      "загляните",
      "конец",
      "статьи",
      "хотите",
      "подробнее",
      "почитать",
      "каждом",
      "них",
      "flex-basis",
      "flex-basis:",
      "250px;",
      "того",
      "(см",
      "flex-grow)",
      "относительных",
      "абсолютных",
      "единицах:",
      "20rem",
      "5vw",
      "250px",
      "также",
      "использовать",
      "auto",
      "случае",
      "расчёте",
      "размера",
      "приниматься",
      "внимание",
      "width",
      "max-width",
      "min-width",
      "аналогичные",
      "зависимости",
      "каком",
      "никакие",
      "заданы",
      "установлено",
      "столько",
      "сколько",
      "нужно",
      "flex:",
      "auto;",
      "указать",
      "трёх",
      "одновременно:",
      "обязательным",
      "опциональны",
      "умолчанию:",
      "расшифровывается",
      "/*",
      "*/",
      "none;",
      "единиц:",
      "2;",
      "ширина/высота:",
      "10em;",
      "30px;",
      "content;",
      "три",
      "10%;",
      "глобальные",
      "inherit;",
      "initial;",
      "unset;",
      "align-self",
      "align-items:",
      "flex-start;",
      "align-self:",
      "flex-end;",
      "выровнять",
      "несколько",
      "иначе",
      "родительского",
      "коде",
      "выше",
      "вложенных",
      "классом",
      "css",
      "basic"
    ],
    "_tags": "api flexbox долгое время веб-интерфейсы были статичными сайты разрабатывались просматривались только на экранах мониторов стационарных компьютеров однако десяток лет назад совсем недавно по историческим меркам нас появилось огромное разнообразие экранов от мобильных телефонов до телевизоров которых мы можем взаимодействовать сайтами так родилась необходимость гибких системах раскладки идея флексбоксов появилась ещё 2009 году этот стандарт сих пор развивается прорабатывается основная флексов гибкое распределение места между элементами гибкая расстановка выравнивание управление ключевое слово что отражено названии (flex англ гибко) основные термины скопировать ссылку \"основные термины\" флекс-контейнер: элемент которому применяется свойство display: flex вложенные него элементы подчиняются правилам флекс-элемент: вложенный во флекс-контейнер когда задаём какому-то элементу значение для свойства display превращаем внутри начинает действовать флекс-контекст его дочерние начинают подчиняться свойствам флексбокса снаружи выглядит как блочный занимает всю ширину родителя следующие за ним разметке переносятся новую строку container flex; flex-direction: column; item если контейнеру задано inline-flex то он вести себя строчный (инлайн) размеры зависят внутреннего контента встаёт другими это ровно такой же при предыдущем значении inline-flex; flex-direction управления направлением основной поперечной осей row; возможные значения: row (значение умолчанию) ось идёт горизонтально слева направо поперечная вертикально сверху вниз row-reverse справа налево column column-reverse снизу вверх row-reverse; важный момент: сайтах текста например сайте арабском языке значений будет идти обратном направлении своё направление поменяет flex-wrap flex-wrap: wrap; width:90px flex-flow свойство-шорткат одновременного определения свойств flex-flow: justify-content позволяет выравнивать флекс-элементы флекс-контейнера оси start прижимаются тому краю откуда начинается чтение том котором отображается сайт end противоположному началу направления чтения сайта flex-start которого flex-end заканчивается left прижмутся левому right правому center выстраиваются центру space-between крайние краям оставшиеся контейнера равномерно чтобы ними одинаковые отступы space-around свободное пространство делится поровну половине этой доли размещается бокам каждого элемента таким образом соседними равное расстояние крайних элементов этого расстояния space-evenly место распределено любыми двумя было одинаковым края justify-content: space-between; align-items выравнивания stretch растягиваются вдоль заполнить всего очень удобно вы делаете двухколоночный макет раньше приходилось помощи разных костылей добиваться одинаковой высоты теперь достаточно сделать контейнер флексом колонки умолчанию будут одной или начала разница лишь второе «уважает» выбранного языка конца первым вторым значениями аналогична предыдущему пункту baseline выравниваются базовой линии «базовая линия» воображаемая линия проходящая нижнему знаков шрифта (без учёта выносных элементов) align-items:center; height: 220px; border: 1px solid red; align-content align-content: center; распределяет рядами флекс-элементов предположим вас 11 рядах размер можно распределять строчки элементов: верхнему не имеет видимого значения располагаются один ряд ряды одинаково занять всё доступное все первое зависит текущего отличие второго первый прижимается последний концу остальные поделено ряда равнозначны отступам любого другого краёв gap помощью лёгкостью задавать строками столбцами является краткой записью row-gap column-gap может иметь одно два указано автоматически равен указаны (row-gap) колонками (column-gap) указывать любых доступных единицах измерения включая проценты допускается использование функции calc() gap: 30px calc(10rem 10px); флекс-элемента \"свойства флекс-элемента\" order менять порядок отображения отображаются порядке они расположены равно задаётся виде целого отрицательного положительного числа встают возрастающей display:flex; item4 order: -1; item1 item2 item3 flex-grow flex-grow: 1; указывает ли вырастать флекс-элемент наличии свободного насколько значением быть любое положительное целое число (включая 0) всех прописано контейнере всеми этом одному из зададим постарается раза больше чем соседи flex-shrink flex-shrink: 3; полностью противоположно свойству хватает расположения без изменения размеров каких пропорциях уменьшаться тем быстрее сжиматься сравнению соседями имеющими меньшее предыдущих работают пропорциональным разделением пространства конкретными размерами довольно непростые даже опытный разработчик всегда знает точности загляните конец статьи хотите подробнее почитать каждом них flex-basis flex-basis: 250px; того (см flex-grow) относительных абсолютных единицах: 20rem 5vw 250px также использовать auto случае расчёте размера приниматься внимание width max-width min-width аналогичные зависимости каком никакие заданы установлено столько сколько нужно flex: auto; указать трёх одновременно: обязательным опциональны умолчанию: расшифровывается /* */ none; единиц: 2; ширина/высота: 10em; 30px; content; три 10%; глобальные inherit; initial; unset; align-self align-items: flex-start; align-self: flex-end; выровнять несколько иначе родительского коде выше вложенных классом css basic",
    "_version": 0
  },
  {
    "_id": "68c46cb5f63b8048002753aa",
    "title": "Деструктуризация",
    "content": "Деструктуризация — это механизм, с помощью которого переданный как аргумент объект распаковывается, а его части присваиваются локальным переменным функции. В JavaScript он выглядит так:\n\n<pre><code>// Обычное определение\nconst f = (user) => {\n  console.log(user.firstName, user.age);\n};\n</code></pre>\n<pre><code>// Деструктурированный объект\nconst f = ({ firstName, age }) => {\n  console.log(firstName, age);\n};\nconst user = { firstName: 'Smith', age: 30 };\nf(user); // => 'Smith', 30</code></pre>\nДеструктурированный объект визуально похож на параметры функции. При этом он все равно остается объектом, поэтому в TypeScript его тип описывается после закрывающей фигурной скобки:\n\n<pre><code>// Обычное определение\nfunction f(user: { firstName: string, age: number }) {\n  console.log(user.firstName, user.age);\n}</code></pre>\n\n<pre><code>// Деструктурированный объект\nfunction f({ firstName, age }: { firstName: string, age: number }) {\n  console.log(firstName, age);\n}</code></pre>\nЗдесь мы описали тип объекта внутри параметра функции и сразу же деструктурировали его.\n\nЕсли вынести определение типа в псевдоним, то можно сделать код поменьше:\n\n<pre><code>type User = {\n  firstName: string;\n  age: number;\n}</code></pre>\n\n<pre><code>function foo({ firstName, age }: User) {\n  console.log(firstName, age);\n}</code></pre>\nЭтот же тип User можно будет использовать и в других местах.\n\nТо же самое применимо и к массивам:\n\n<pre><code>// Обычное определение\nfunction foo(point: number[]) {\n  console.log(point);\n}</code></pre>\n\n<pre><code>// Деструктурированный массив\nfunction foo([x, y]: number[]) {\n  console.log(x, y);\n}</code></pre>\n\ntype Point = number[];\n\n<pre><code>// С псевдонимом\nfunction foo([x, y]: Point) {\n  console.log(x, y);\n}</code></pre>\nИспользование деструктуризации удобно, когда внутри функции нужно использовать несколько свойств объекта или элементов массива. В таком случае можно сразу извлечь их в параметрах функции, а не писать user.firstName или point[0] внутри тела функции.",
    "group": "Typescript",
    "subGroup": "Typescript Basic",
    "ignoreHtml": false,
    "order": 5,
    "imageUrls": "",
    "_created": "2025-09-12T18:55:49.152Z",
    "_changed": "2025-10-13T17:23:38.338Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "деструктуризация",
      "это",
      "механизм",
      "помощью",
      "которого",
      "переданный",
      "как",
      "аргумент",
      "объект",
      "распаковывается",
      "его",
      "части",
      "присваиваются",
      "локальным",
      "переменным",
      "функции",
      "javascript",
      "он",
      "выглядит",
      "так:",
      "//",
      "обычное",
      "определение",
      "const",
      "(user)",
      "=>",
      "console",
      "log(user",
      "firstname",
      "user",
      "age);",
      "};",
      "деструктурированный",
      "({",
      "age",
      "})",
      "log(firstname",
      "firstname:",
      "'smith'",
      "age:",
      "30",
      "f(user);",
      "визуально",
      "похож",
      "на",
      "параметры",
      "при",
      "этом",
      "все",
      "равно",
      "остается",
      "объектом",
      "поэтому",
      "typescript",
      "тип",
      "описывается",
      "после",
      "закрывающей",
      "фигурной",
      "скобки:",
      "function",
      "f(user:",
      "string",
      "number",
      "f({",
      "}:",
      "здесь",
      "мы",
      "описали",
      "объекта",
      "внутри",
      "параметра",
      "сразу",
      "же",
      "деструктурировали",
      "если",
      "вынести",
      "типа",
      "псевдоним",
      "то",
      "можно",
      "сделать",
      "код",
      "поменьше:",
      "type",
      "string;",
      "number;",
      "foo({",
      "user)",
      "этот",
      "будет",
      "использовать",
      "других",
      "местах",
      "самое",
      "применимо",
      "массивам:",
      "foo(point:",
      "number[])",
      "log(point);",
      "массив",
      "foo([x",
      "y]:",
      "log(x",
      "y);",
      "point",
      "number[];",
      "псевдонимом",
      "point)",
      "использование",
      "деструктуризации",
      "удобно",
      "когда",
      "нужно",
      "несколько",
      "свойств",
      "или",
      "элементов",
      "массива",
      "таком",
      "случае",
      "извлечь",
      "их",
      "параметрах",
      "не",
      "писать",
      "point[0]",
      "тела",
      "basic"
    ],
    "_tags": "api деструктуризация это механизм помощью которого переданный как аргумент объект распаковывается его части присваиваются локальным переменным функции javascript он выглядит так: // обычное определение const (user) => console log(user firstname user age); }; деструктурированный ({ age }) log(firstname firstname: 'smith' age: 30 f(user); визуально похож на параметры при этом все равно остается объектом поэтому typescript тип описывается после закрывающей фигурной скобки: function f(user: string number f({ }: здесь мы описали объекта внутри параметра сразу же деструктурировали если вынести типа псевдоним то можно сделать код поменьше: type string; number; foo({ user) этот будет использовать других местах самое применимо массивам: foo(point: number[]) log(point); массив foo([x y]: log(x y); point number[]; псевдонимом point) использование деструктуризации удобно когда нужно несколько свойств или элементов массива таком случае извлечь их параметрах не писать point[0] тела basic",
    "_version": 1
  },
  {
    "_id": "68c5c7cdf63b804800276b61",
    "title": "Grid Layout (Дописать)",
    "content": "https://developer.mozilla.org/ru/docs/Web/CSS/CSS_grid_layout/Basic_concepts_of_grid_layout\nЧто такое грид?\nГрид представляет собой пересекающийся набор горизонтальных и вертикальных линий, образующих колонки и строки. Элементы могут быть помещены в грид в пределах линий этих колонок и строк. Грид имеет следующие особенности:\n\nФиксированные и гибкие размеры полос\nВы можете создать грид с фиксированными размерами полоc, например используя пиксели. Это установит грид на определенный пиксель, соответствующим желаемому макету. Вы также можете создать грид с гибкими размерами, используя проценты или новую единицу измерения — «fr», разработанную для этой цели.\n\nРасположение элемента\nВы можете размещать элементы в заданном месте на гриде используя номера строк, имена или путём привязки к области грида. Грид также содержит алгоритм управления размещением элементов, не имеющих явной позиции на гриде.\n\nСоздание дополнительных полос для хранения контента\nВы можете определить явную сетку с помощью грид-раскладки. Cпецификация грид-раскладки достаточно гибкая, чтобы добавить при необходимости дополнительные строки и колонки. Также в нее включены такие возможности как, например, добавление «стольких колонок, сколько будет помещено в контейнер».\n\nУправление выравниванием\nГрид содержит механизм выравнивания, таким образом мы можем контролировать, как элементы выравниваются после размещения в области сетки и как выравнивается вся сетка.\n\nУправление перекрывающимся контентом\nВ ячейку или область грида может быть помещено несколько элементов; эти элементы могут частично перекрывать друг друга. Такое наложение можно контролировать с помощью свойства z-index.\n\nГрид – это мощная спецификация, и в сочетании с другими частями CSS, такими как flexbox, поможет вам создать макеты, которые ранее невозможно было построить в CSS. Все начинается с создания сетки в вашем грид-контейнере.\n\nГрид-контейнер\nМы создаём grid контейнер, объявляя на элементе display: grid или display: inline-grid. Как только мы это сделаем, все прямые потомки этого элемента станут элементами сетки.\n\nВ этом примере у меня есть контейнер div с классом-обёрткой и пятью дочерними элементами внутри.\n.wrapper {\n     display: grid;\n}\n<div style=\"display:grid\">\n  <div style=\"border: 1px solid red\" >One</div>\n  <div style=\"border: 1px solid red\">Two</div>\n  <div style=\"border: 1px solid red\">Three</div>\n  <div style=\"border: 1px solid red\">Four</div>\n  <div style=\"border: 1px solid red\">Five</div>\n</div>\nВсе прямые потомки теперь являются грид-элементами. В браузере вы не увидите разницы с тем, как элементы отображались до помещения их в грид, поскольку грид сделан как одноколоночная сетка. На этой стадии вам, возможно, будет удобнее работать с инструментом «Грид-инспектор», который является частью «Инструментов веб-разработчика» Firefox (Firefox's Developer Tools). Если вы просмотрите этот пример в Firefox и проинспектируете грид, вы увидите маленький значок рядом с значением grid. Нажмите на него и сетка на этом элементе будет наложена в окне браузера.\n <p><img src=\"https://developer.mozilla.org/ru/docs/Web/CSS/CSS_grid_layout/Basic_concepts_of_grid_layout/1-grid-inspector.png\" alt=\"В\" style=\"max-width: 100%;\"></p> \nПо мере вашего обучения и последующей работы с грид-раскладкой этот инструмент даст вам лучшее визуальное представление о том, что происходит с вашим гридом.\n\nЕсли мы хотим, чтобы пример стал более похожим на сетку, нам нужно добавить полосы-колонки.\n\nГрид-треки (грид-полосы)\nМы определяем ряды и колонки в нашей сетке при помощи свойств grid-template-columns и grid-template-rows. Это определения грид-треков (грид-полос). Грид-трек – это промежуток между любыми двумя линиями грида. На изображении ниже вы можете увидеть подсвеченный трек – это первый трек-строка в нашем гриде. <p><img src=\"https://developer.mozilla.org/ru/docs/Web/CSS/CSS_grid_layout/Basic_concepts_of_grid_layout/1_grid_track.png\" alt=\"В\" style=\"max-width: 100%;\"></p> \nБазовый пример\nЯ могу дополнить пример выше, добавив свойство grid-template-columns и задав размеры треков-колонок.\n\nСейчас я создал грид с тремя колонками шириной по 200px. Каждый дочерний элемент будет располагаться в отдельной ячейке грида.\n.wrapper {\n  display: grid;\n  grid-template-columns: 200px 200px 200px;\n}\n\n<div style=\"display: grid; grid-template-columns: 200px 200px 200px\">\n  <div style=\"border: 1px solid red\" >One</div>\n  <div style=\"border: 1px solid red\">Two</div>\n  <div style=\"border: 1px solid red\">Three</div>\n  <div style=\"border: 1px solid red\">Four</div>\n  <div style=\"border: 1px solid red\">Five</div>\n</div>\nЕдиница измерения «fr»\nРазмер треков может быть задан с помощью любой единицы длины. Спецификация также вводит дополнительную единицу длины, позволяющую создавать гибкие (flexible) грид-треки. Новая единица длины «fr» представляет собой долю (fraction) доступного пространства в грид-контейнере. Следующее определение грида создаст три одинаковых по ширине трека, расширяющихся и сужающихся в соответствии с доступным пространством.\n.wrapper {\n  display: grid;\n  grid-template-columns: 1fr 1fr 1fr;\n}\n<div style=\"display: grid; grid-template-columns: 1fr 1fr 1fr\">\n  <div style=\"border: 1px solid red\" >One</div>\n  <div style=\"border: 1px solid red\">Two</div>\n  <div style=\"border: 1px solid red\">Three</div>\n  <div style=\"border: 1px solid red\">Four</div>\n  <div style=\"border: 1px solid red\">Five</div>\n</div>\nРазные размеры\nВ следующем примере мы создаём грид с треком в 2fr и двумя треками по 1fr. Доступное пространство разбивается на четыре части. Две части занимает первый трек, и две части – два оставшихся.\n.wrapper {\n  display: grid;\n  grid-template-columns: 2fr 1fr 1fr;\n}\n<div style=\"display: grid; grid-template-columns: 2fr 1fr 1fr\">\n  <div style=\"border: 1px solid red\" >One</div>\n  <div style=\"border: 1px solid red\">Two</div>\n  <div style=\"border: 1px solid red\">Three</div>\n  <div style=\"border: 1px solid red\">Four</div>\n  <div style=\"border: 1px solid red\">Five</div>\n</div>\nСмешение гибких и фиксированных размеров\nВ последнем примере смешаем треки с абсолютными размерами и треки с размерами, определенными в fr. Первый трек – 500 пикселей, фиксированная ширина убирается из доступного пространства. Оставшееся пространство разбивается на три части и пропорционально разделяется между двумя гибкими треками.\n.wrapper {\n  display: grid;\n  grid-template-columns: 500px 1fr 2fr;\n}\n\n<div style=\"display: grid; grid-template-columns: 500px 1fr 2fr\">\n  <div style=\"border: 1px solid red\" >One</div>\n  <div style=\"border: 1px solid red\">Two</div>\n  <div style=\"border: 1px solid red\">Three</div>\n  <div style=\"border: 1px solid red\">Four</div>\n  <div style=\"border: 1px solid red\">Five</div>\n</div>\nЗадание треков с помощью нотации repeat()\nВ огромных гридах с большим количеством треков можно использовать нотацию repeat(), чтобы повторить всю структуру треков или её часть. Например, определение грида:\n.wrapper {\n  display: grid;\n  grid-template-columns: 1fr 1fr 1fr;\n}\nМожет быть также записано как:\n.wrapper {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n}\nRepeat-нотация может быть использована для части структуры треков. В следующем примере я создал грид с начальным треком в 20 пикселей, затем повторил секцию с шестью треками по 1fr и завершил 20-пиксельным треком.\n.wrapper {\n  display: grid;\n  grid-template-columns: 20px repeat(6, 1fr) 20px;\n}\nRepeat-нотация принимает список треков и использует его для создания повторяющегося шаблона треков. В следующем примере мой грид состоит из 10 треков: за треком в 1fr следует трек в 2fr. Этот шаблон будет повторен пять раз.\n.wrapper {\n  display: grid;\n  grid-template-columns: repeat(5, 1fr 2fr);\n}\nЯвный и неявный грид\nПри создании грида в примере выше мы специально объявляли треки-колонки при помощи свойства grid-template-columns, но грид также самостоятельно создавал строки. Эти строки - часть «неявного» грида. В отличие от него, «явный» грид состоит из строк и колонок, заданных с помощью grid-template-columns или grid-template-rows.\n\nЕсли вы размещаете что-нибудь вне рамок определённого грида или из-за количества контента требуется большее количество грид-треков, грид создаёт строки и колонки в виде неявного грида. Размер этих треков по умолчанию задаётся автоматически в зависимости от находящегося в них контента.\n\nВы также можете задать размер треков, создаваемых в виде неявного грида, с помощью свойств grid-auto-rows и grid-auto-columns.\n\nВ примере ниже мы используем grid-auto-rows, чтобы убедиться, что треки, создаваемые в неявном гриде, были высотой 200 пикселей.\n.wrapper {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  grid-auto-rows: 200px;\n}\n<div style=\"display: grid;  grid-template-columns: repeat(3, 1fr);\n  grid-auto-rows: 200px;\">\n  <div style=\"border: 1px solid red\" >One</div>\n  <div style=\"border: 1px solid red\">Two</div>\n  <div style=\"border: 1px solid red\">Three</div>\n  <div style=\"border: 1px solid red\">Four</div>\n  <div style=\"border: 1px solid red\">Five</div>\n</div>",
    "group": "CSS",
    "subGroup": "CSS Basic",
    "ignoreHtml": false,
    "order": 5,
    "imageUrls": "",
    "_created": "2025-09-13T19:36:45.825Z",
    "_changed": "2025-09-13T19:36:45.825Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "grid",
      "layout",
      "(дописать)",
      "https://developer",
      "mozilla",
      "что",
      "такое",
      "грид?",
      "грид",
      "представляет",
      "собой",
      "пересекающийся",
      "набор",
      "горизонтальных",
      "вертикальных",
      "линий",
      "образующих",
      "колонки",
      "строки",
      "элементы",
      "могут",
      "быть",
      "помещены",
      "пределах",
      "этих",
      "колонок",
      "строк",
      "имеет",
      "следующие",
      "особенности:",
      "фиксированные",
      "гибкие",
      "размеры",
      "полос",
      "вы",
      "можете",
      "создать",
      "фиксированными",
      "размерами",
      "полоc",
      "например",
      "используя",
      "пиксели",
      "это",
      "установит",
      "на",
      "определенный",
      "пиксель",
      "соответствующим",
      "желаемому",
      "макету",
      "также",
      "гибкими",
      "проценты",
      "или",
      "новую",
      "единицу",
      "измерения",
      "«fr»",
      "разработанную",
      "для",
      "этой",
      "цели",
      "расположение",
      "элемента",
      "размещать",
      "заданном",
      "месте",
      "гриде",
      "номера",
      "имена",
      "путём",
      "привязки",
      "области",
      "грида",
      "содержит",
      "алгоритм",
      "управления",
      "размещением",
      "элементов",
      "не",
      "имеющих",
      "явной",
      "позиции",
      "создание",
      "дополнительных",
      "хранения",
      "контента",
      "определить",
      "явную",
      "сетку",
      "помощью",
      "грид-раскладки",
      "cпецификация",
      "достаточно",
      "гибкая",
      "чтобы",
      "добавить",
      "при",
      "необходимости",
      "дополнительные",
      "нее",
      "включены",
      "такие",
      "возможности",
      "как",
      "добавление",
      "«стольких",
      "сколько",
      "будет",
      "помещено",
      "контейнер»",
      "управление",
      "выравниванием",
      "механизм",
      "выравнивания",
      "таким",
      "образом",
      "мы",
      "можем",
      "контролировать",
      "выравниваются",
      "после",
      "размещения",
      "сетки",
      "выравнивается",
      "вся",
      "сетка",
      "перекрывающимся",
      "контентом",
      "ячейку",
      "область",
      "может",
      "несколько",
      "элементов;",
      "эти",
      "частично",
      "перекрывать",
      "друг",
      "друга",
      "наложение",
      "можно",
      "свойства",
      "z-index",
      "мощная",
      "спецификация",
      "сочетании",
      "другими",
      "частями",
      "css",
      "такими",
      "flexbox",
      "поможет",
      "вам",
      "макеты",
      "которые",
      "ранее",
      "невозможно",
      "было",
      "построить",
      "все",
      "начинается",
      "создания",
      "вашем",
      "грид-контейнере",
      "грид-контейнер",
      "создаём",
      "контейнер",
      "объявляя",
      "элементе",
      "display:",
      "inline-grid",
      "только",
      "сделаем",
      "прямые",
      "потомки",
      "этого",
      "станут",
      "элементами",
      "этом",
      "примере",
      "меня",
      "есть",
      "div",
      "классом-обёрткой",
      "пятью",
      "дочерними",
      "внутри",
      "wrapper",
      "grid;",
      "one",
      "two",
      "three",
      "four",
      "five",
      "теперь",
      "являются",
      "грид-элементами",
      "браузере",
      "увидите",
      "разницы",
      "тем",
      "отображались",
      "до",
      "помещения",
      "их",
      "поскольку",
      "сделан",
      "одноколоночная",
      "стадии",
      "возможно",
      "удобнее",
      "работать",
      "инструментом",
      "«грид-инспектор»",
      "который",
      "является",
      "частью",
      "«инструментов",
      "веб-разработчика»",
      "firefox",
      "(firefox's",
      "developer",
      "tools)",
      "если",
      "просмотрите",
      "этот",
      "пример",
      "проинспектируете",
      "маленький",
      "значок",
      "рядом",
      "значением",
      "нажмите",
      "него",
      "наложена",
      "окне",
      "браузера",
      "по",
      "мере",
      "вашего",
      "обучения",
      "последующей",
      "работы",
      "грид-раскладкой",
      "инструмент",
      "даст",
      "лучшее",
      "визуальное",
      "представление",
      "том",
      "происходит",
      "вашим",
      "гридом",
      "хотим",
      "стал",
      "более",
      "похожим",
      "нам",
      "нужно",
      "полосы-колонки",
      "грид-треки",
      "(грид-полосы)",
      "определяем",
      "ряды",
      "нашей",
      "сетке",
      "помощи",
      "свойств",
      "grid-template-columns",
      "grid-template-rows",
      "определения",
      "грид-треков",
      "(грид-полос)",
      "грид-трек",
      "промежуток",
      "между",
      "любыми",
      "двумя",
      "линиями",
      "изображении",
      "ниже",
      "увидеть",
      "подсвеченный",
      "трек",
      "первый",
      "трек-строка",
      "нашем",
      "базовый",
      "могу",
      "дополнить",
      "выше",
      "добавив",
      "свойство",
      "задав",
      "треков-колонок",
      "сейчас",
      "создал",
      "тремя",
      "колонками",
      "шириной",
      "200px",
      "каждый",
      "дочерний",
      "элемент",
      "располагаться",
      "отдельной",
      "ячейке",
      "grid-template-columns:",
      "200px;",
      "единица",
      "размер",
      "треков",
      "задан",
      "любой",
      "единицы",
      "длины",
      "вводит",
      "дополнительную",
      "позволяющую",
      "создавать",
      "(flexible)",
      "новая",
      "долю",
      "(fraction)",
      "доступного",
      "пространства",
      "следующее",
      "определение",
      "создаст",
      "три",
      "одинаковых",
      "ширине",
      "трека",
      "расширяющихся",
      "сужающихся",
      "соответствии",
      "доступным",
      "пространством",
      "1fr",
      "1fr;",
      "разные",
      "следующем",
      "треком",
      "2fr",
      "треками",
      "доступное",
      "пространство",
      "разбивается",
      "четыре",
      "части",
      "две",
      "занимает",
      "два",
      "оставшихся",
      "смешение",
      "гибких",
      "фиксированных",
      "размеров",
      "последнем",
      "смешаем",
      "треки",
      "абсолютными",
      "определенными",
      "fr",
      "500",
      "пикселей",
      "фиксированная",
      "ширина",
      "убирается",
      "из",
      "оставшееся",
      "пропорционально",
      "разделяется",
      "500px",
      "2fr;",
      "задание",
      "нотации",
      "repeat()",
      "огромных",
      "гридах",
      "большим",
      "количеством",
      "использовать",
      "нотацию",
      "повторить",
      "всю",
      "структуру",
      "её",
      "часть",
      "грида:",
      "записано",
      "как:",
      "repeat(3",
      "1fr);",
      "repeat-нотация",
      "использована",
      "структуры",
      "начальным",
      "20",
      "затем",
      "повторил",
      "секцию",
      "шестью",
      "завершил",
      "20-пиксельным",
      "20px",
      "repeat(6",
      "1fr)",
      "20px;",
      "принимает",
      "список",
      "использует",
      "его",
      "повторяющегося",
      "шаблона",
      "мой",
      "состоит",
      "10",
      "треков:",
      "за",
      "следует",
      "шаблон",
      "повторен",
      "пять",
      "раз",
      "repeat(5",
      "2fr);",
      "явный",
      "неявный",
      "создании",
      "специально",
      "объявляли",
      "треки-колонки",
      "но",
      "самостоятельно",
      "создавал",
      "«неявного»",
      "отличие",
      "от",
      "«явный»",
      "заданных",
      "размещаете",
      "что-нибудь",
      "вне",
      "рамок",
      "определённого",
      "из-за",
      "количества",
      "требуется",
      "большее",
      "количество",
      "создаёт",
      "виде",
      "неявного",
      "умолчанию",
      "задаётся",
      "автоматически",
      "зависимости",
      "находящегося",
      "них",
      "задать",
      "создаваемых",
      "grid-auto-rows",
      "grid-auto-columns",
      "используем",
      "убедиться",
      "создаваемые",
      "неявном",
      "были",
      "высотой",
      "200",
      "grid-auto-rows:",
      "basic"
    ],
    "_tags": "api grid layout (дописать) https://developer mozilla что такое грид? грид представляет собой пересекающийся набор горизонтальных вертикальных линий образующих колонки строки элементы могут быть помещены пределах этих колонок строк имеет следующие особенности: фиксированные гибкие размеры полос вы можете создать фиксированными размерами полоc например используя пиксели это установит на определенный пиксель соответствующим желаемому макету также гибкими проценты или новую единицу измерения «fr» разработанную для этой цели расположение элемента размещать заданном месте гриде номера имена путём привязки области грида содержит алгоритм управления размещением элементов не имеющих явной позиции создание дополнительных хранения контента определить явную сетку помощью грид-раскладки cпецификация достаточно гибкая чтобы добавить при необходимости дополнительные нее включены такие возможности как добавление «стольких сколько будет помещено контейнер» управление выравниванием механизм выравнивания таким образом мы можем контролировать выравниваются после размещения сетки выравнивается вся сетка перекрывающимся контентом ячейку область может несколько элементов; эти частично перекрывать друг друга наложение можно свойства z-index мощная спецификация сочетании другими частями css такими flexbox поможет вам макеты которые ранее невозможно было построить все начинается создания вашем грид-контейнере грид-контейнер создаём контейнер объявляя элементе display: inline-grid только сделаем прямые потомки этого станут элементами этом примере меня есть div классом-обёрткой пятью дочерними внутри wrapper grid; one two three four five теперь являются грид-элементами браузере увидите разницы тем отображались до помещения их поскольку сделан одноколоночная стадии возможно удобнее работать инструментом «грид-инспектор» который является частью «инструментов веб-разработчика» firefox (firefox's developer tools) если просмотрите этот пример проинспектируете маленький значок рядом значением нажмите него наложена окне браузера по мере вашего обучения последующей работы грид-раскладкой инструмент даст лучшее визуальное представление том происходит вашим гридом хотим стал более похожим нам нужно полосы-колонки грид-треки (грид-полосы) определяем ряды нашей сетке помощи свойств grid-template-columns grid-template-rows определения грид-треков (грид-полос) грид-трек промежуток между любыми двумя линиями изображении ниже увидеть подсвеченный трек первый трек-строка нашем базовый могу дополнить выше добавив свойство задав треков-колонок сейчас создал тремя колонками шириной 200px каждый дочерний элемент располагаться отдельной ячейке grid-template-columns: 200px; единица размер треков задан любой единицы длины вводит дополнительную позволяющую создавать (flexible) новая долю (fraction) доступного пространства следующее определение создаст три одинаковых ширине трека расширяющихся сужающихся соответствии доступным пространством 1fr 1fr; разные следующем треком 2fr треками доступное пространство разбивается четыре части две занимает два оставшихся смешение гибких фиксированных размеров последнем смешаем треки абсолютными определенными fr 500 пикселей фиксированная ширина убирается из оставшееся пропорционально разделяется 500px 2fr; задание нотации repeat() огромных гридах большим количеством использовать нотацию повторить всю структуру её часть грида: записано как: repeat(3 1fr); repeat-нотация использована структуры начальным 20 затем повторил секцию шестью завершил 20-пиксельным 20px repeat(6 1fr) 20px; принимает список использует его повторяющегося шаблона мой состоит 10 треков: за следует шаблон повторен пять раз repeat(5 2fr); явный неявный создании специально объявляли треки-колонки но самостоятельно создавал «неявного» отличие от «явный» заданных размещаете что-нибудь вне рамок определённого из-за количества требуется большее количество создаёт виде неявного умолчанию задаётся автоматически зависимости находящегося них задать создаваемых grid-auto-rows grid-auto-columns используем убедиться создаваемые неявном были высотой 200 grid-auto-rows: basic",
    "_version": 0
  },
  {
    "_id": "68c5ca79f63b804800276b92",
    "title": "Reactive Forms",
    "content": "https://metanit.com/web/angular2/5.5.php\nПри подходе Reactive Forms для формы создается набор объектов FormGroup и FormControl. Сама форма и ее подсекции представляют класс FormGroup, а отдельные элементы ввода - класс FormControl. Например, базовое создание формы:\nmyForm : FormGroup = new FormGroup();\nДобавляем в форму элементы:\nmyForm : FormGroup = new FormGroup({             \n    \"userName\": new FormControl(),\n    \"userEmail\": new FormControl(),\n    \"userPhone\": new FormControl()\n});\nЗдесь определено три элемента: userName, userEmail и userPhone.\nОбъект FormControl может иметь различные формы определения. (Подробнее можно посмотреть в документации). В частности, в качестве первого параметра можно передавать значение по умолчанию для элемента, а в качестве второго параметра - набор валидаторов:\nmyForm : FormGroup = new FormGroup({             \n    \"userName\": new FormControl(\"Tom\", Validators.required),\n    \"userEmail\": new FormControl(\"\", [\n                Validators.required, \n                Validators.email\n    ]),\n    \"userPhone\": new FormControl(\"\", Validators.pattern(\"[0-9]{10}\")) \n});\nЗдесь к элементам применяется ряд валидаторов. Валидатор Validators.required требует обязательного наличия значения. Валидатор Validators.email проверяет, представляет ли введенная строка электронный адрес. Валидатор Validators.pattern(\"[0-9]{10}\") поверяет на соответствие регулярному выражению. Все встроенные валидаторы можно посмотреть в документации. Если валидаторов несколько, то они заключаются в массив.\nДля привязки объекта myForm к конкретному элементу формы применяется атрибут formGroup:\n<.form [formGroup]=\"myForm\" >\nКроме того, необходимо связать объекты FormControl с элементами ввода с помощью атрибута formControlName:\n<.input name=\"name\" formControlName=\"userName\" />\nДанный элемент будет связан с объектом \"userName\": new FormControl(\"Tom\").\n\nТеперь рассмотрим, как эти объекты будут взаимодействовать с шаблоном компонента. Для этого определим следующий компонент:\n <p><img src=\"https://ik.imagekit.io/ygtb3rzhz/reactiveforms1.png?updatedAt=1757793178980\" alt=\"В\" style=\"max-width: 100%;\"></p> \nДля отображения ошибок валидации здесь используется блоки div, в которых определены выражения типа\n*ngIf=\"myForm.controls['userName'].invalid && myForm.controls['userName'].touched\">\nС помощью выражений myForm.controls['userName'] мы можем обратиться к нужному элементу формы и получить его состояние или значение. В данном случае если значение поля ввода невалидно, и при этом поле ввода уже получало фокус, то отображается ошибка валидации.\n\nНо чтобы все это заработало, необходимо импортировать модуль ReactiveFormsModule:\nimport { ReactiveFormsModule} from \"@angular/forms\"; \n@Component({\n    imports: [FormsModule, ReactiveFormsModule], // импортируем модуль ReactiveFormsModule\n <p><img src=\"https://metanit.com/web/angular2/pics/5.6.png\" alt=\"В\" style=\"max-width: 100%;\"></p> \n<b>Определение валидаторов</b>\nКроме использования встроенных валидаторов мы также можем определять свои валидаторы. К примеру, определим в классе компонента валидатор:\n <p><img src=\"https://ik.imagekit.io/ygtb3rzhz/rf2.png?updatedAt=1757793319126\" alt=\"В\" style=\"max-width: 100%;\"></p> \nПо сути валидатор представляет обычный метод - в данном случае метод userNameValidator. В качестве параметра он принимает элемент формы, к которому этот валидатор применяется, а на выходе возвращает объект, где ключ - строка, а значение равно true.\n\nВ данном случае проверяем, если значение равно строке \"нет\", то возвращаем объект {\"userName\": true}. Значение true указывает, что элемент формы не прошел валидацию. Если же все нормально, то возвращаем null.\nЗатем этот валидатор добавляется к элементу:\n\"userName\": new FormControl(\"Tom\", [Validators.required, this.userNameValidator])\nИ в случае если в поле для ввода имени будет введено значение \"нет\", то данное поле не пройдет валидацию:\n <p><img src=\"https://metanit.com/web/angular2/pics/5.7.png\" alt=\"В\" style=\"max-width: 100%;\"></p> \n<b>Массивы элементов и FormArray</b>\nНекоторые элементы на форме могут относиться к одному и тому же признаку. Например, в анкете пользователя могут попросить указать номера телефоно, которыми он владеет. Их может быть несколько, но они будут представлять один и тот же признак - \"номера телефонов\". То есть логично было бы объединить все поля для ввода номеров телефонов в массив. И в Angular мы легко можем реализовать подобную возможность с помощью класса FormArray.\nИтак, изменим код компонента AppComponent следующим образом:\n <p><img src=\"https://ik.imagekit.io/ygtb3rzhz/rf3.png?updatedAt=1757793425989\" alt=\"В\" style=\"max-width: 100%;\"></p> \nТеперь поля для ввода телефонных номеров представляют массив:\n\"phones\": new FormArray([\n        new FormControl(\"+7\", Validators.required)\n])\nМассив или FormArray хранит набор объектов FormControl. И в данном случае добавляется один такой объект.\nЧтобы можно было динамически при необходимости добавлять новые объекты, в классе компонента предусмотрен метод addPhone():\naddPhone(){\n    (<FormArray>this.myForm.controls[\"phones\"]).push(new FormControl(\"+7\", Validators.required));\n}\nВ этой сложной конструкции мы сначала получаем объект формы через выражение this.myForm.controls[\"phones\"], затем приводим его к типу FormArray. И далее как и в обычный массив добавляем через метод push новый элемент.\nДля упрощения получения массива элементов ввода здесь также определен метод getFormsControls(), который возвращает объект FormArray:\ngetFormsControls() : FormArray{\n    return this.myForm.controls[\"phones\"] as FormArray;\n}\nВ коде html предусматриваем вывод объектов из FormArray, возвращаемого методом getFormsControls(), на форму с помощью конструкции @for:\n<1div formArrayName=\"phones\">\n@for(phone of getFormsControls()[\"controls\"]; track $index){\n    <1div>\n        <1label>Телефон</label><br>\n        <1input formControlName=\"{{$index}}\" />\n    <1/div>\n}\n</div>\nПри этом контейнер всех элементов ввода имеет директиву formArrayName=\"phones\". А каждый элемент в качестве названия принимает его текущий индекс: formControlName=\"{{$index}}\".\nА кнопка \"Добавить телефон\" позволяет добавить на форму новое поле для ввода еще одного телефонного номера:\n <p><img src=\"https://metanit.com/web/angular2/pics/5.8.png\" alt=\"В\" style=\"max-width: 100%;\"></p> \n<b>FormBuilder</b>\nКласс FormBuilder представляет альтернативный подход к созданию форм:\n <p><img src=\"https://ik.imagekit.io/ygtb3rzhz/rf4.png?updatedAt=1757793643741\" alt=\"В\" style=\"max-width: 100%;\"></p> \nFormBuilder передается в качестве сервиса в конструктор. С помощью метода group() создается объект FormGroup. Каждый элемент передается в форму в виде обычного массива значений:\n\"userName\": [\"Tom\", [Validators.required]]\nРезультат работы компонента будет аналогичным предыдущему.\n\n",
    "group": "Angular",
    "subGroup": "Angular basic",
    "ignoreHtml": false,
    "order": 12,
    "imageUrls": "",
    "_created": "2025-09-13T19:48:09.058Z",
    "_changed": "2025-09-13T19:48:09.058Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "reactive",
      "forms",
      "https://metanit",
      "com/web/angular2/5",
      "php",
      "при",
      "подходе",
      "для",
      "формы",
      "создается",
      "набор",
      "объектов",
      "formgroup",
      "formcontrol",
      "сама",
      "форма",
      "ее",
      "подсекции",
      "представляют",
      "класс",
      "отдельные",
      "элементы",
      "ввода",
      "например",
      "базовое",
      "создание",
      "формы:",
      "myform",
      "new",
      "formgroup();",
      "добавляем",
      "форму",
      "элементы:",
      "formgroup({",
      "\"username\":",
      "formcontrol()",
      "\"useremail\":",
      "\"userphone\":",
      "});",
      "здесь",
      "определено",
      "три",
      "элемента:",
      "username",
      "useremail",
      "userphone",
      "объект",
      "может",
      "иметь",
      "различные",
      "определения",
      "(подробнее",
      "можно",
      "посмотреть",
      "документации)",
      "частности",
      "качестве",
      "первого",
      "параметра",
      "передавать",
      "значение",
      "по",
      "умолчанию",
      "элемента",
      "второго",
      "валидаторов:",
      "formcontrol(\"tom\"",
      "validators",
      "required)",
      "formcontrol(\"\"",
      "required",
      "email",
      "])",
      "pattern(\"[0-9]{10}\"))",
      "элементам",
      "применяется",
      "ряд",
      "валидаторов",
      "валидатор",
      "требует",
      "обязательного",
      "наличия",
      "значения",
      "проверяет",
      "представляет",
      "ли",
      "введенная",
      "строка",
      "электронный",
      "адрес",
      "pattern(\"[0-9]{10}\")",
      "поверяет",
      "на",
      "соответствие",
      "регулярному",
      "выражению",
      "все",
      "встроенные",
      "валидаторы",
      "документации",
      "если",
      "несколько",
      "то",
      "они",
      "заключаются",
      "массив",
      "привязки",
      "объекта",
      "конкретному",
      "элементу",
      "атрибут",
      "formgroup:",
      "кроме",
      "того",
      "необходимо",
      "связать",
      "объекты",
      "элементами",
      "помощью",
      "атрибута",
      "formcontrolname:",
      "данный",
      "элемент",
      "будет",
      "связан",
      "объектом",
      "formcontrol(\"tom\")",
      "теперь",
      "рассмотрим",
      "как",
      "эти",
      "будут",
      "взаимодействовать",
      "шаблоном",
      "компонента",
      "этого",
      "определим",
      "следующий",
      "компонент:",
      "отображения",
      "ошибок",
      "валидации",
      "используется",
      "блоки",
      "div",
      "которых",
      "определены",
      "выражения",
      "типа",
      "*ngif=\"myform",
      "controls['username']",
      "invalid",
      "&&",
      "touched\">",
      "выражений",
      "мы",
      "можем",
      "обратиться",
      "нужному",
      "получить",
      "его",
      "состояние",
      "или",
      "данном",
      "случае",
      "поля",
      "невалидно",
      "этом",
      "поле",
      "уже",
      "получало",
      "фокус",
      "отображается",
      "ошибка",
      "но",
      "чтобы",
      "это",
      "заработало",
      "импортировать",
      "модуль",
      "reactiveformsmodule:",
      "import",
      "reactiveformsmodule}",
      "from",
      "angular/forms\";",
      "component({",
      "imports:",
      "[formsmodule",
      "reactiveformsmodule]",
      "//",
      "импортируем",
      "reactiveformsmodule",
      "определение",
      "использования",
      "встроенных",
      "также",
      "определять",
      "свои",
      "примеру",
      "классе",
      "валидатор:",
      "сути",
      "обычный",
      "метод",
      "usernamevalidator",
      "он",
      "принимает",
      "которому",
      "этот",
      "выходе",
      "возвращает",
      "где",
      "ключ",
      "равно",
      "true",
      "проверяем",
      "строке",
      "\"нет\"",
      "возвращаем",
      "{\"username\":",
      "true}",
      "указывает",
      "что",
      "не",
      "прошел",
      "валидацию",
      "же",
      "нормально",
      "затем",
      "добавляется",
      "элементу:",
      "[validators",
      "this",
      "usernamevalidator])",
      "имени",
      "введено",
      "данное",
      "пройдет",
      "валидацию:",
      "массивы",
      "элементов",
      "formarray",
      "некоторые",
      "форме",
      "могут",
      "относиться",
      "одному",
      "тому",
      "признаку",
      "анкете",
      "пользователя",
      "попросить",
      "указать",
      "номера",
      "телефоно",
      "которыми",
      "владеет",
      "их",
      "быть",
      "представлять",
      "один",
      "тот",
      "признак",
      "\"номера",
      "телефонов\"",
      "есть",
      "логично",
      "было",
      "бы",
      "объединить",
      "номеров",
      "телефонов",
      "angular",
      "легко",
      "реализовать",
      "подобную",
      "возможность",
      "класса",
      "итак",
      "изменим",
      "код",
      "appcomponent",
      "следующим",
      "образом:",
      "телефонных",
      "массив:",
      "\"phones\":",
      "formarray([",
      "formcontrol(\"+7\"",
      "хранит",
      "такой",
      "динамически",
      "необходимости",
      "добавлять",
      "новые",
      "предусмотрен",
      "addphone():",
      "addphone(){",
      "(this",
      "controls[\"phones\"])",
      "push(new",
      "required));",
      "этой",
      "сложной",
      "конструкции",
      "сначала",
      "получаем",
      "через",
      "выражение",
      "controls[\"phones\"]",
      "приводим",
      "типу",
      "далее",
      "push",
      "новый",
      "упрощения",
      "получения",
      "массива",
      "определен",
      "getformscontrols()",
      "который",
      "formarray:",
      "formarray{",
      "return",
      "as",
      "formarray;",
      "коде",
      "html",
      "предусматриваем",
      "вывод",
      "из",
      "возвращаемого",
      "методом",
      "for:",
      "for(phone",
      "of",
      "getformscontrols()[\"controls\"];",
      "track",
      "$index){",
      "телефон",
      "контейнер",
      "всех",
      "имеет",
      "директиву",
      "formarrayname=\"phones\"",
      "каждый",
      "названия",
      "текущий",
      "индекс:",
      "formcontrolname=\"{{$index}}\"",
      "кнопка",
      "\"добавить",
      "телефон\"",
      "позволяет",
      "добавить",
      "новое",
      "еще",
      "одного",
      "телефонного",
      "номера:",
      "formbuilder",
      "альтернативный",
      "подход",
      "созданию",
      "форм:",
      "передается",
      "сервиса",
      "конструктор",
      "метода",
      "group()",
      "виде",
      "обычного",
      "значений:",
      "[\"tom\"",
      "required]]",
      "результат",
      "работы",
      "аналогичным",
      "предыдущему",
      "basic",
      "12"
    ],
    "_tags": "api reactive forms https://metanit com/web/angular2/5 php при подходе для формы создается набор объектов formgroup formcontrol сама форма ее подсекции представляют класс отдельные элементы ввода например базовое создание формы: myform new formgroup(); добавляем форму элементы: formgroup({ \"username\": formcontrol() \"useremail\": \"userphone\": }); здесь определено три элемента: username useremail userphone объект может иметь различные определения (подробнее можно посмотреть документации) частности качестве первого параметра передавать значение по умолчанию элемента второго валидаторов: formcontrol(\"tom\" validators required) formcontrol(\"\" required email ]) pattern(\"[0-9]{10}\")) элементам применяется ряд валидаторов валидатор требует обязательного наличия значения проверяет представляет ли введенная строка электронный адрес pattern(\"[0-9]{10}\") поверяет на соответствие регулярному выражению все встроенные валидаторы документации если несколько то они заключаются массив привязки объекта конкретному элементу атрибут formgroup: кроме того необходимо связать объекты элементами помощью атрибута formcontrolname: данный элемент будет связан объектом formcontrol(\"tom\") теперь рассмотрим как эти будут взаимодействовать шаблоном компонента этого определим следующий компонент: отображения ошибок валидации используется блоки div которых определены выражения типа *ngif=\"myform controls['username'] invalid && touched\"> выражений мы можем обратиться нужному получить его состояние или данном случае поля невалидно этом поле уже получало фокус отображается ошибка но чтобы это заработало импортировать модуль reactiveformsmodule: import reactiveformsmodule} from angular/forms\"; component({ imports: [formsmodule reactiveformsmodule] // импортируем reactiveformsmodule определение использования встроенных также определять свои примеру классе валидатор: сути обычный метод usernamevalidator он принимает которому этот выходе возвращает где ключ равно true проверяем строке \"нет\" возвращаем {\"username\": true} указывает что не прошел валидацию же нормально затем добавляется элементу: [validators this usernamevalidator]) имени введено данное пройдет валидацию: массивы элементов formarray некоторые форме могут относиться одному тому признаку анкете пользователя попросить указать номера телефоно которыми владеет их быть представлять один тот признак \"номера телефонов\" есть логично было бы объединить номеров телефонов angular легко реализовать подобную возможность класса итак изменим код appcomponent следующим образом: телефонных массив: \"phones\": formarray([ formcontrol(\"+7\" хранит такой динамически необходимости добавлять новые предусмотрен addphone(): addphone(){ (this controls[\"phones\"]) push(new required)); этой сложной конструкции сначала получаем через выражение controls[\"phones\"] приводим типу далее push новый упрощения получения массива определен getformscontrols() который formarray: formarray{ return as formarray; коде html предусматриваем вывод из возвращаемого методом for: for(phone of getformscontrols()[\"controls\"]; track $index){ телефон контейнер всех имеет директиву formarrayname=\"phones\" каждый названия текущий индекс: formcontrolname=\"{{$index}}\" кнопка \"добавить телефон\" позволяет добавить новое еще одного телефонного номера: formbuilder альтернативный подход созданию форм: передается сервиса конструктор метода group() виде обычного значений: [\"tom\" required]] результат работы аналогичным предыдущему basic 12",
    "_version": 0
  },
  {
    "_id": "68c5cb58f63b804800276b9f",
    "title": "@if @for @switch @case",
    "content": "Одним из нововведений Angular 17 стало добавление во фреймворк новых синтаксических конструкций управления шаблоном компонента, которые позволяют легко определять условные и циклические конструкции. В предыдущих версиях Angular для этого применялись специальные директивы.\n@if(num==5){\n   <.p>Переменная num равна 5<./p>      \n}\n@else if(num==6){\n   <.p>Переменная num равна 6<./p>\n} @else {\n   <.p>У переменной num неизвестное значение<./p>\n}\n <p><img src=\"https://ik.imagekit.io/ygtb3rzhz/new(1).png?updatedAt=1757793892721\" alt=\"В\" style=\"max-width: 100%;\"></p> ",
    "group": "Angular",
    "subGroup": "Обновления",
    "ignoreHtml": false,
    "order": 1,
    "imageUrls": "",
    "_created": "2025-09-13T19:51:52.559Z",
    "_changed": "2025-09-13T19:51:52.559Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "if",
      "for",
      "switch",
      "case",
      "одним",
      "из",
      "нововведений",
      "angular",
      "17",
      "стало",
      "добавление",
      "во",
      "фреймворк",
      "новых",
      "синтаксических",
      "конструкций",
      "управления",
      "шаблоном",
      "компонента",
      "которые",
      "позволяют",
      "легко",
      "определять",
      "условные",
      "циклические",
      "конструкции",
      "предыдущих",
      "версиях",
      "для",
      "этого",
      "применялись",
      "специальные",
      "директивы",
      "if(num==5){",
      "переменная",
      "num",
      "равна",
      "else",
      "if(num==6){",
      "переменной",
      "неизвестное",
      "значение",
      "обновления"
    ],
    "_tags": "api if for switch case одним из нововведений angular 17 стало добавление во фреймворк новых синтаксических конструкций управления шаблоном компонента которые позволяют легко определять условные циклические конструкции предыдущих версиях для этого применялись специальные директивы if(num==5){ переменная num равна else if(num==6){ переменной неизвестное значение обновления",
    "_version": 0
  },
  {
    "_id": "68c97219f63b80480027b7ce",
    "title": "11117",
    "content": "12227",
    "group": "Группа1",
    "subGroup": "234234",
    "ignoreHtml": false,
    "order": 2,
    "_created": "2025-09-16T14:20:09.798Z",
    "_changed": "2025-09-18T19:23:26.313Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "11117",
      "12227",
      "группа1",
      "234234"
    ],
    "_tags": "api 11117 12227 группа1 234234",
    "_version": 2
  },
  {
    "_id": "68c31710f63b8048002739d2",
    "title": "ASDAFASDAFAS5DFSDF",
    "content": "<b>SAFDSDFSDFSDF4SDF</b>",
    "group": "Группа1",
    "subGroup": "sdfsdfsdf",
    "ignoreHtml": true,
    "order": 8,
    "imageUrls": "",
    "_created": "2025-09-11T18:38:08.621Z",
    "_changed": "2025-09-18T19:28:43.946Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "asdafasdafas5dfsdf",
      "safdsdfsdfsdf4sdf",
      "группа1",
      "sdfsdfsdf"
    ],
    "_tags": "api asdafasdafas5dfsdf safdsdfsdfsdf4sdf группа1 sdfsdfsdf",
    "_version": 4,
    "done": false
  },
  {
    "_id": "68d828200d20f72500014d5a",
    "title": "Git rebase и git merge",
    "content": "Git rebase и git merge — это два основных способа объединить изменения из одной ветки в другую.  Оба достигают схожей цели, но делают это по-разному, что приводит к разным историям коммитов.\nGit Merge\n•   Как работает: Merge берет изменения из целевой ветки (например, feature) и создает новый коммит слияния в текущей ветке (например, main). Этот коммит слияния явно указывает на то, что изменения из feature были интегрированы в main.\n•   История коммитов: История коммитов сохраняет информацию обо всех ветках и слияниях.  Вы увидите четкие ветки, которые отходят и сливаются обратно.\n\n•   Плюсы:\n    *   Простота и безопасность: Merge — это обычно более простой и безопасный вариант, особенно для начинающих.  Он не переписывает историю, поэтому проще восстановиться, если что-то пойдет не так.\n    *   Сохраняет контекст:  Сохраняет информацию о том, когда и как были объединены ветки, что может быть полезно для отслеживания истории изменений.\n    *   Легко отменить: Если что-то пойдет не так после слияния, относительно легко отменить коммит слияния и вернуться к предыдущему состоянию.\n\n•   Минусы:\n    *   Загроможденная история:  Со временем, если ветки сливаются часто, история коммитов может стать загроможденной коммитами слияния, что усложняет ее чтение и понимание.\n    *   Усложняет git bisect:  git bisect — это полезный инструмент для поиска коммита, вызвавшего регрессию.  Слияния могут усложнить этот процесс, так как они вводят дополнительные коммиты для анализа.\n\nGit Rebase\n•   Как работает: Rebase берет коммиты из текущей ветки (например, feature) и перемещает их так, чтобы они начинались с последнего коммита в целевой ветке (например, main).  Фактически, он переписывает историю текущей ветки.  Каждый коммит в ветке feature применяется поверх main как новый коммит.\n•   История коммитов:  История коммитов выглядит более линейной и чистой, как будто работа над веткой feature всегда велась поверх последней версии main.\n\n•   Плюсы:\n    *   Чистая история:  Rebase создает более чистую и линейную историю коммитов, что облегчает ее чтение и понимание.\n    *   Упрощает git bisect:  Линейная история упрощает использование git bisect для поиска проблем.\n    *   Более легкое отслеживание изменений:  Легче увидеть эволюцию изменений в проекте, так как нет коммитов слияния, загромождающих историю.\n\n•   Минусы:\n    *   Переписывает историю:  Rebase переписывает историю, что может быть опасным, особенно если ветка уже была опубликована и другие разработчики строят свою работу на ее основе.\n    *   Сложность при конфликтах:  Конфликты при rebase могут быть сложнее, чем при merge, особенно если их много.\n    *   Потеря информации:  Rebase удаляет информацию о ветвлении, что может быть нежелательным в некоторых случаях.\n\nКогда использовать Merge vs. Rebase\n\n•   Merge:\n    *   Когда важна история ветвления (например, для аудита или отслеживания фич).\n    *   Когда вы работаете в команде и хотите избежать проблем с переписыванием истории в общих ветках.\n    *   Когда безопасность важнее чистоты истории.\n\n•   Rebase:\n    *   Когда вы хотите поддерживать чистую и линейную историю коммитов (особенно в главной ветке).\n    *   Когда вы работаете в локальной ветке, которая еще не была опубликована.\n    *   Когда вы хотите упростить процесс git bisect.\n\nПравило золотого сечения:\n•   Никогда не переписывайте историю опубликованных коммитов.  Если вы работаете в ветке, которую другие разработчики уже используют (например, main или develop), не используйте rebase, если только вы не абсолютно уверены, что это не вызовет проблем.  В таких случаях безопаснее использовать merge.\n•   Rebase только свои локальные ветки.  Rebase можно использовать в локальных ветках, которые еще не были опубликованы, чтобы привести их в порядок перед слиянием в общую ветку. Rebase можно использовать в локальных ветках, которые еще не были опубликованы, чтобы привести их в порядок перед слиянием в общую ветку.\n\nПример:\nПредположим, у вас есть две ветки: main и feature.  Вы хотите объединить изменения из feature в main.\n\n•   **Merge:**\nЭто создаст новый коммит слияния в main, объединяющий изменения из feature. История коммитов будет выглядеть примерно так:\n  A -- B -- C -- D -- M (main)\n     \\    /\n      E -- F  (feature)\nГде M — коммит слияния.\n\n•  Rebase:\n    git checkout feature\n    git rebase main\n    git checkout main\n    git merge feature\nСначала выполняется rebase, перенося коммиты E и F на вершину ветки main. Затем выполняется merge, но поскольку ветка feature уже содержит все коммиты из main (благодаря rebase), это будет fast-forward merge (ветка main просто переместится на коммит F). История коммитов будет выглядеть примерно так:\n  A -- B -- C -- D -- E' -- F' (main, feature)\nГде E' и F' — это перенесенные версии коммитов E и F.\n\nВ заключение:\nОба git rebase и git merge являются важными инструментами в арсенале Git. Выбор между ними зависит от конкретной ситуации и от того, что вы больше цените: чистую историю или безопасность. Понимание их различий и правильное использование поможет вам эффективно управлять своим репозиторием и сотрудничать с другими разработчиками. Всегда будьте осторожны при использовании rebase, особенно в общих ветках.\n\n",
    "group": "Прочее",
    "subGroup": "Git",
    "ignoreHtml": false,
    "order": 1,
    "_created": "2025-09-27T18:08:32.623Z",
    "_changed": "2025-09-27T18:08:32.623Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "git",
      "rebase",
      "merge",
      "это",
      "два",
      "основных",
      "способа",
      "объединить",
      "изменения",
      "из",
      "одной",
      "ветки",
      "другую",
      "оба",
      "достигают",
      "схожей",
      "цели",
      "но",
      "делают",
      "по-разному",
      "что",
      "приводит",
      "разным",
      "историям",
      "коммитов",
      "как",
      "работает:",
      "берет",
      "целевой",
      "(например",
      "feature)",
      "создает",
      "новый",
      "коммит",
      "слияния",
      "текущей",
      "ветке",
      "main)",
      "этот",
      "явно",
      "указывает",
      "на",
      "то",
      "feature",
      "были",
      "интегрированы",
      "main",
      "история",
      "коммитов:",
      "сохраняет",
      "информацию",
      "обо",
      "всех",
      "ветках",
      "слияниях",
      "вы",
      "увидите",
      "четкие",
      "которые",
      "отходят",
      "сливаются",
      "обратно",
      "плюсы:",
      "простота",
      "безопасность:",
      "обычно",
      "более",
      "простой",
      "безопасный",
      "вариант",
      "особенно",
      "для",
      "начинающих",
      "он",
      "не",
      "переписывает",
      "историю",
      "поэтому",
      "проще",
      "восстановиться",
      "если",
      "что-то",
      "пойдет",
      "так",
      "контекст:",
      "том",
      "когда",
      "объединены",
      "может",
      "быть",
      "полезно",
      "отслеживания",
      "истории",
      "изменений",
      "легко",
      "отменить:",
      "после",
      "относительно",
      "отменить",
      "вернуться",
      "предыдущему",
      "состоянию",
      "минусы:",
      "загроможденная",
      "история:",
      "со",
      "временем",
      "часто",
      "стать",
      "загроможденной",
      "коммитами",
      "усложняет",
      "ее",
      "чтение",
      "понимание",
      "bisect:",
      "bisect",
      "полезный",
      "инструмент",
      "поиска",
      "коммита",
      "вызвавшего",
      "регрессию",
      "могут",
      "усложнить",
      "процесс",
      "они",
      "вводят",
      "дополнительные",
      "коммиты",
      "анализа",
      "перемещает",
      "их",
      "чтобы",
      "начинались",
      "последнего",
      "фактически",
      "каждый",
      "применяется",
      "поверх",
      "выглядит",
      "линейной",
      "чистой",
      "будто",
      "работа",
      "над",
      "веткой",
      "всегда",
      "велась",
      "последней",
      "версии",
      "чистая",
      "чистую",
      "линейную",
      "облегчает",
      "упрощает",
      "линейная",
      "использование",
      "проблем",
      "легкое",
      "отслеживание",
      "изменений:",
      "легче",
      "увидеть",
      "эволюцию",
      "проекте",
      "нет",
      "загромождающих",
      "историю:",
      "опасным",
      "ветка",
      "уже",
      "была",
      "опубликована",
      "другие",
      "разработчики",
      "строят",
      "свою",
      "работу",
      "основе",
      "сложность",
      "при",
      "конфликтах:",
      "конфликты",
      "сложнее",
      "чем",
      "много",
      "потеря",
      "информации:",
      "удаляет",
      "ветвлении",
      "нежелательным",
      "некоторых",
      "случаях",
      "использовать",
      "vs",
      "merge:",
      "важна",
      "ветвления",
      "аудита",
      "или",
      "фич)",
      "работаете",
      "команде",
      "хотите",
      "избежать",
      "переписыванием",
      "общих",
      "безопасность",
      "важнее",
      "чистоты",
      "rebase:",
      "поддерживать",
      "(особенно",
      "главной",
      "ветке)",
      "локальной",
      "которая",
      "еще",
      "упростить",
      "правило",
      "золотого",
      "сечения:",
      "никогда",
      "переписывайте",
      "опубликованных",
      "которую",
      "используют",
      "develop)",
      "используйте",
      "только",
      "абсолютно",
      "уверены",
      "вызовет",
      "таких",
      "безопаснее",
      "свои",
      "локальные",
      "можно",
      "локальных",
      "опубликованы",
      "привести",
      "порядок",
      "перед",
      "слиянием",
      "общую",
      "ветку",
      "пример:",
      "предположим",
      "вас",
      "есть",
      "две",
      "ветки:",
      "**merge:**",
      "создаст",
      "объединяющий",
      "будет",
      "выглядеть",
      "примерно",
      "так:",
      "--",
      "(main)",
      "(feature)",
      "где",
      "checkout",
      "сначала",
      "выполняется",
      "перенося",
      "вершину",
      "затем",
      "поскольку",
      "содержит",
      "все",
      "(благодаря",
      "rebase)",
      "fast-forward",
      "(ветка",
      "просто",
      "переместится",
      "f)",
      "e'",
      "f'",
      "(main",
      "перенесенные",
      "заключение:",
      "являются",
      "важными",
      "инструментами",
      "арсенале",
      "выбор",
      "между",
      "ними",
      "зависит",
      "от",
      "конкретной",
      "ситуации",
      "того",
      "больше",
      "цените:",
      "различий",
      "правильное",
      "поможет",
      "вам",
      "эффективно",
      "управлять",
      "своим",
      "репозиторием",
      "сотрудничать",
      "другими",
      "разработчиками",
      "будьте",
      "осторожны",
      "использовании",
      "прочее"
    ],
    "_tags": "api git rebase merge это два основных способа объединить изменения из одной ветки другую оба достигают схожей цели но делают по-разному что приводит разным историям коммитов как работает: берет целевой (например feature) создает новый коммит слияния текущей ветке main) этот явно указывает на то feature были интегрированы main история коммитов: сохраняет информацию обо всех ветках слияниях вы увидите четкие которые отходят сливаются обратно плюсы: простота безопасность: обычно более простой безопасный вариант особенно для начинающих он не переписывает историю поэтому проще восстановиться если что-то пойдет так контекст: том когда объединены может быть полезно отслеживания истории изменений легко отменить: после относительно отменить вернуться предыдущему состоянию минусы: загроможденная история: со временем часто стать загроможденной коммитами усложняет ее чтение понимание bisect: bisect полезный инструмент поиска коммита вызвавшего регрессию могут усложнить процесс они вводят дополнительные коммиты анализа перемещает их чтобы начинались последнего фактически каждый применяется поверх выглядит линейной чистой будто работа над веткой всегда велась последней версии чистая чистую линейную облегчает упрощает линейная использование проблем легкое отслеживание изменений: легче увидеть эволюцию проекте нет загромождающих историю: опасным ветка уже была опубликована другие разработчики строят свою работу основе сложность при конфликтах: конфликты сложнее чем много потеря информации: удаляет ветвлении нежелательным некоторых случаях использовать vs merge: важна ветвления аудита или фич) работаете команде хотите избежать переписыванием общих безопасность важнее чистоты rebase: поддерживать (особенно главной ветке) локальной которая еще упростить правило золотого сечения: никогда переписывайте опубликованных которую используют develop) используйте только абсолютно уверены вызовет таких безопаснее свои локальные можно локальных опубликованы привести порядок перед слиянием общую ветку пример: предположим вас есть две ветки: **merge:** создаст объединяющий будет выглядеть примерно так: -- (main) (feature) где checkout сначала выполняется перенося вершину затем поскольку содержит все (благодаря rebase) fast-forward (ветка просто переместится f) e' f' (main перенесенные заключение: являются важными инструментами арсенале выбор между ними зависит от конкретной ситуации того больше цените: различий правильное поможет вам эффективно управлять своим репозиторием сотрудничать другими разработчиками будьте осторожны использовании прочее",
    "_version": 0
  },
  {
    "_id": "68d82b0f0d20f72500014d91",
    "title": "Map, Set, WeakMap и WeakSet",
    "content": "В JavaScript Map, Set, WeakMap и WeakSet — это структуры данных, которые предоставляют более гибкие и эффективные способы хранения и управления коллекциями данных по сравнению с обычными объектами и массивами. Давайте разберем каждый из них:\n1. Map\n•  Что это: Map — это коллекция пар ключ-значение, где ключом может быть любой тип данных (в отличие от объектов, где ключи всегда строки или символы). Map запоминает порядок вставки элементов.\n•  Когда использовать: Когда вам нужна коллекция пар ключ-значение, где ключи могут быть любого типа, и порядок элементов важен.\n•  Основные методы:\n  •  set(key, value): Добавляет новую пару ключ-значение в Map.\n  •  get(key): Возвращает значение, связанное с заданным ключом, или undefined, если ключ не найден.\n  •  has(key): Возвращает true, если ключ существует в Map, и false в противном случае.\n  •  delete(key): Удаляет пару ключ-значение с заданным ключом.\n  •  clear(): Удаляет все элементы из Map.\n  •  size: Возвращает количество элементов в Map.\n  •  keys(): Возвращает итератор ключей.\n  •  values(): Возвращает итератор значений.\n  •  entries(): Возвращает итератор пар ключ-значение.\n  •  forEach(callbackFn, thisArg?): Выполняет функцию обратного вызова для каждой пары ключ-значение.\n\n•  Пример: <p><img src=\"https://ik.imagekit.io/ygtb3rzhz/map.png?updatedAt=1758997857625\" alt=\"В\" style=\"max-width: 100%;\"></p> \n2. Set\n•  Что это: Set — это коллекция уникальных значений любого типа. Подобно Map, Set запоминает порядок вставки элементов.\n•  Когда использовать: Когда вам нужно хранить набор уникальных значений и порядок добавления важен. Полезно для устранения дубликатов из массива или для проверки, существует ли значение в наборе.\n•  Основные методы:\n  •  add(value): Добавляет новое значение в Set. Если значение уже существует, ничего не происходит.\n  •  delete(value): Удаляет значение из Set.\n  •  has(value): Возвращает true, если значение существует в Set, и false в противном случае.\n  •  clear(): Удаляет все элементы из Set.\n  •  size: Возвращает количество элементов в Set.\n  •  values(): Возвращает итератор значений.\n  •  entries(): Возвращает итератор пар [value, value] (для совместимости с Map).\n  •  forEach(callbackFn, thisArg?): Выполняет функцию обратного вызова для каждого значения.\n•  Пример:\n <p><img src=\"https://ik.imagekit.io/ygtb3rzhz/set.png?updatedAt=1758997880052\" alt=\"В\" style=\"max-width: 100%;\"></p>\n3. WeakMap\n•  Что это: WeakMap — это коллекция пар ключ-значение, как и Map, но с двумя ключевыми отличиями:\n  •  Ключи должны быть объектами: Ключи в WeakMap могут быть только объектами.\n  •  Слабые ссылки: Ссылки на ключи в WeakMap являются слабыми. Это означает, что если на объект-ключ больше нет ссылок, он может быть собран сборщиком мусора (garbage collector), и соответствующая запись в WeakMap будет автоматически удалена.\n•  Когда использовать: Когда вам нужно связать данные с объектами, но вы не хотите предотвращать их сборку мусором. Часто используется для хранения приватных данных объектов или для реализации паттерна \"кэширования\" с учетом жизненного цикла объектов.\n\n•  Основные методы:\n  •  set(key, value): Добавляет новую пару ключ-значение в WeakMap.\n  •  get(key): Возвращает значение, связанное с заданным ключом, или undefined, если ключ не найден.\n  •  has(key): Возвращает true, если ключ существует в WeakMap, и false в противном случае.\n  •  delete(key): Удаляет пару ключ-значение с заданным ключом.\n•  Важно:\n  •  WeakMap не имеет методов clear(), size, keys(), values() и entries(). Это связано с тем, что сборщик мусора может удалить записи в любое время, и эти методы были бы ненадежными.\n  •  Вы не можете перебирать WeakMap.\n•  Пример:  <p><img src=\"https://ik.imagekit.io/ygtb3rzhz/weakmap.png?updatedAt=1758997902232\" alt=\"В\" style=\"max-width: 100%;\"></p> \n4. WeakSet\n•  Что это: WeakSet — это коллекция объектов, подобная Set, но с двумя ключевыми отличиями:\n  •  Содержит только объекты: WeakSet может содержать только объекты.\n  •  Слабые ссылки: Ссылки на объекты в WeakSet являются слабыми. Если на объект больше нет ссылок, он может быть собран сборщиком мусора, и он будет автоматически удален из WeakSet.\n•  Когда использовать: Когда вам нужно отслеживать набор объектов, но вы не хотите предотвращать их сборку мусором. Полезно для отслеживания, например, какие объекты определенного класса были инициализированы или какие объекты в данный момент находятся в активном состоянии.\n\n•  Основные методы:\n  •  add(value): Добавляет новый объект в WeakSet.\n  •  delete(value): Удаляет объект из WeakSet.\n  •  has(value): Возвращает true, если объект существует в WeakSet, и false в противном случае.\n\n•  Важно:\n  •  WeakSet не имеет методов clear(), size, values(), entries() и forEach().\n  •  Вы не можете перебирать WeakSet.\n•  Пример: <p><img src=\"https://ik.imagekit.io/ygtb3rzhz/weakset.png?updatedAt=1758997924013\" alt=\"В\" style=\"max-width: 100%;\"></p> \n",
    "group": "JavaScript",
    "subGroup": "JavaScript Deep",
    "ignoreHtml": false,
    "order": 1,
    "_created": "2025-09-27T18:21:03.241Z",
    "_changed": "2025-09-27T18:21:03.241Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "map",
      "set",
      "weakmap",
      "weakset",
      "javascript",
      "это",
      "структуры",
      "данных",
      "которые",
      "предоставляют",
      "более",
      "гибкие",
      "эффективные",
      "способы",
      "хранения",
      "управления",
      "коллекциями",
      "по",
      "сравнению",
      "обычными",
      "объектами",
      "массивами",
      "давайте",
      "разберем",
      "каждый",
      "из",
      "них:",
      "что",
      "это:",
      "коллекция",
      "пар",
      "ключ-значение",
      "где",
      "ключом",
      "может",
      "быть",
      "любой",
      "тип",
      "(в",
      "отличие",
      "от",
      "объектов",
      "ключи",
      "всегда",
      "строки",
      "или",
      "символы)",
      "запоминает",
      "порядок",
      "вставки",
      "элементов",
      "когда",
      "использовать:",
      "вам",
      "нужна",
      "могут",
      "любого",
      "типа",
      "важен",
      "основные",
      "методы:",
      "set(key",
      "value):",
      "добавляет",
      "новую",
      "пару",
      "get(key):",
      "возвращает",
      "значение",
      "связанное",
      "заданным",
      "если",
      "ключ",
      "не",
      "найден",
      "has(key):",
      "true",
      "существует",
      "false",
      "противном",
      "случае",
      "delete(key):",
      "удаляет",
      "clear():",
      "все",
      "элементы",
      "size:",
      "количество",
      "keys():",
      "итератор",
      "ключей",
      "values():",
      "значений",
      "entries():",
      "foreach(callbackfn",
      "thisarg?):",
      "выполняет",
      "функцию",
      "обратного",
      "вызова",
      "для",
      "каждой",
      "пары",
      "пример:",
      "уникальных",
      "подобно",
      "нужно",
      "хранить",
      "набор",
      "добавления",
      "полезно",
      "устранения",
      "дубликатов",
      "массива",
      "проверки",
      "ли",
      "наборе",
      "add(value):",
      "новое",
      "уже",
      "ничего",
      "происходит",
      "delete(value):",
      "has(value):",
      "[value",
      "value]",
      "(для",
      "совместимости",
      "map)",
      "каждого",
      "значения",
      "как",
      "но",
      "двумя",
      "ключевыми",
      "отличиями:",
      "должны",
      "объектами:",
      "только",
      "слабые",
      "ссылки:",
      "ссылки",
      "на",
      "являются",
      "слабыми",
      "означает",
      "объект-ключ",
      "больше",
      "нет",
      "ссылок",
      "он",
      "собран",
      "сборщиком",
      "мусора",
      "(garbage",
      "collector)",
      "соответствующая",
      "запись",
      "будет",
      "автоматически",
      "удалена",
      "связать",
      "данные",
      "вы",
      "хотите",
      "предотвращать",
      "их",
      "сборку",
      "мусором",
      "часто",
      "используется",
      "приватных",
      "реализации",
      "паттерна",
      "\"кэширования\"",
      "учетом",
      "жизненного",
      "цикла",
      "важно:",
      "имеет",
      "методов",
      "clear()",
      "size",
      "keys()",
      "values()",
      "entries()",
      "связано",
      "тем",
      "сборщик",
      "удалить",
      "записи",
      "любое",
      "время",
      "эти",
      "методы",
      "были",
      "бы",
      "ненадежными",
      "можете",
      "перебирать",
      "подобная",
      "содержит",
      "объекты:",
      "содержать",
      "объекты",
      "объект",
      "удален",
      "отслеживать",
      "отслеживания",
      "например",
      "какие",
      "определенного",
      "класса",
      "инициализированы",
      "данный",
      "момент",
      "находятся",
      "активном",
      "состоянии",
      "новый",
      "foreach()",
      "deep"
    ],
    "_tags": "api map set weakmap weakset javascript это структуры данных которые предоставляют более гибкие эффективные способы хранения управления коллекциями по сравнению обычными объектами массивами давайте разберем каждый из них: что это: коллекция пар ключ-значение где ключом может быть любой тип (в отличие от объектов ключи всегда строки или символы) запоминает порядок вставки элементов когда использовать: вам нужна могут любого типа важен основные методы: set(key value): добавляет новую пару get(key): возвращает значение связанное заданным если ключ не найден has(key): true существует false противном случае delete(key): удаляет clear(): все элементы size: количество keys(): итератор ключей values(): значений entries(): foreach(callbackfn thisarg?): выполняет функцию обратного вызова для каждой пары пример: уникальных подобно нужно хранить набор добавления полезно устранения дубликатов массива проверки ли наборе add(value): новое уже ничего происходит delete(value): has(value): [value value] (для совместимости map) каждого значения как но двумя ключевыми отличиями: должны объектами: только слабые ссылки: ссылки на являются слабыми означает объект-ключ больше нет ссылок он собран сборщиком мусора (garbage collector) соответствующая запись будет автоматически удалена связать данные вы хотите предотвращать их сборку мусором часто используется приватных реализации паттерна \"кэширования\" учетом жизненного цикла важно: имеет методов clear() size keys() values() entries() связано тем сборщик удалить записи любое время эти методы были бы ненадежными можете перебирать подобная содержит объекты: содержать объекты объект удален отслеживать отслеживания например какие определенного класса инициализированы данный момент находятся активном состоянии новый foreach() deep",
    "_version": 0
  },
  {
    "_id": "68ed37ed0d20f7250002f78a",
    "title": "Чем стрелочная функция отличается от обычной",
    "content": "Стрелочные функции отличаются от обычных тремя основными аспектами: \n1. более кратким синтаксисом, \n2. лексическим связыванием this (он не создаёт собственный контекст)\n3. отсутствием собственных arguments, super и new.target. Это значит, что this в стрелочной функции ссылается на this из внешнего окружения, и такие функции не могут быть использованы как конструкторы. \nСинтаксис\nКраткость: Стрелочные функции позволяют писать меньше кода, опуская ключевое слово function.\nНеявный return: Если тело функции состоит из одного выражения, его можно вернуть без явного return. \nОбычная функция\t                        Стрелочная функция\nfunction add(a, b) { return a + b; }\tconst add = (a, b) => a + b;\nКонтекст this\nОбычная функция: Значение this определяется тем, как функция вызвана. Его можно изменить с помощью call(), apply() или bind().\nСтрелочная функция: Лексически привязана к родительской области видимости. this внутри стрелочной функции — это тот же this, что и снаружи, и его нельзя переопределить методами call(), apply() или bind(). Это особенно удобно в колбэках, таких как обработчики событий. \nОтсутствие собственных arguments, super, new.target\nОбычная функция: Имеет собственный массив arguments, который содержит все переданные аргументы.\nСтрелочная функция: Не имеет своего объекта arguments. Вместо этого она обращается к arguments из внешнего окружения или использует rest параметры (...args).\nОбычная функция: Может быть использована как конструктор с ключевым словом new.\nСтрелочная функция: Не может быть использована как конструктор. Попытка вызвать её с new вызовет ошибку. ",
    "group": "Вопросы с собеседований",
    "subGroup": "Selectel",
    "ignoreHtml": false,
    "order": 2,
    "_created": "2025-10-13T17:33:33.446Z",
    "_changed": "2025-10-13T17:33:33.446Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "чем",
      "стрелочная",
      "функция",
      "отличается",
      "от",
      "обычной",
      "стрелочные",
      "функции",
      "отличаются",
      "обычных",
      "тремя",
      "основными",
      "аспектами:",
      "более",
      "кратким",
      "синтаксисом",
      "лексическим",
      "связыванием",
      "this",
      "(он",
      "не",
      "создаёт",
      "собственный",
      "контекст)",
      "отсутствием",
      "собственных",
      "arguments",
      "super",
      "new",
      "target",
      "это",
      "значит",
      "что",
      "стрелочной",
      "ссылается",
      "на",
      "из",
      "внешнего",
      "окружения",
      "такие",
      "могут",
      "быть",
      "использованы",
      "как",
      "конструкторы",
      "синтаксис",
      "краткость:",
      "позволяют",
      "писать",
      "меньше",
      "кода",
      "опуская",
      "ключевое",
      "слово",
      "function",
      "неявный",
      "return:",
      "если",
      "тело",
      "состоит",
      "одного",
      "выражения",
      "его",
      "можно",
      "вернуть",
      "без",
      "явного",
      "return",
      "обычная",
      "функция\t",
      "add(a",
      "b)",
      "b;",
      "}\tconst",
      "add",
      "(a",
      "=>",
      "контекст",
      "функция:",
      "значение",
      "определяется",
      "тем",
      "вызвана",
      "изменить",
      "помощью",
      "call()",
      "apply()",
      "или",
      "bind()",
      "лексически",
      "привязана",
      "родительской",
      "области",
      "видимости",
      "внутри",
      "тот",
      "же",
      "снаружи",
      "нельзя",
      "переопределить",
      "методами",
      "особенно",
      "удобно",
      "колбэках",
      "таких",
      "обработчики",
      "событий",
      "отсутствие",
      "имеет",
      "массив",
      "который",
      "содержит",
      "все",
      "переданные",
      "аргументы",
      "своего",
      "объекта",
      "вместо",
      "этого",
      "она",
      "обращается",
      "использует",
      "rest",
      "параметры",
      "args)",
      "может",
      "использована",
      "конструктор",
      "ключевым",
      "словом",
      "попытка",
      "вызвать",
      "её",
      "вызовет",
      "ошибку",
      "вопросы",
      "собеседований",
      "selectel"
    ],
    "_tags": "api чем стрелочная функция отличается от обычной стрелочные функции отличаются обычных тремя основными аспектами: более кратким синтаксисом лексическим связыванием this (он не создаёт собственный контекст) отсутствием собственных arguments super new target это значит что стрелочной ссылается на из внешнего окружения такие могут быть использованы как конструкторы синтаксис краткость: позволяют писать меньше кода опуская ключевое слово function неявный return: если тело состоит одного выражения его можно вернуть без явного return обычная функция\t add(a b) b; }\tconst add (a => контекст функция: значение определяется тем вызвана изменить помощью call() apply() или bind() лексически привязана родительской области видимости внутри тот же снаружи нельзя переопределить методами особенно удобно колбэках таких обработчики событий отсутствие имеет массив который содержит все переданные аргументы своего объекта вместо этого она обращается использует rest параметры args) может использована конструктор ключевым словом попытка вызвать её вызовет ошибку вопросы собеседований selectel",
    "_version": 0
  },
  {
    "_id": "68d82fc50d20f72500014de3",
    "title": "localStorage, sessionStorage и cookies",
    "content": "localStorage, sessionStorage и cookies — это три разных способа хранения данных на стороне клиента (в браузере пользователя). Они отличаются по своему назначению, объему хранимых данных, сроку хранения и доступности. Понимание этих различий необходимо для выбора подходящего решения для хранения информации в веб-приложениях.\n1. Cookies\n•  Что это: Cookies - это небольшие текстовые файлы, которые веб-сайт сохраняет на компьютере пользователя. Они используются для хранения различной информации, такой как предпочтения пользователя, данные сеанса или идентификаторы отслеживания.\n•  Назначение:\n  •  Управление сессиями: Отслеживание состояния сессии пользователя (например, авторизован ли он).\n  •  Персонализация: Запоминание предпочтений пользователя (например, язык интерфейса, тема оформления).\n  •  Отслеживание: Отслеживание действий пользователя на сайте для аналитики и рекламы.\n•  Срок хранения: Может быть разным:\n  •  Сессионные cookies: Удаляются при закрытии браузера.\n  •  Постоянные cookies: Хранятся на компьютере пользователя в течение заданного времени (например, несколько дней, месяцев или лет).\n•  Объем хранимых данных: Ограничен – обычно около 4KB на cookie и общее ограничение в ~20 cookies на домен.\n•  Доступность:\n  •  Скрипты на стороне клиента: Доступны через JavaScript.\n  •  Сервер: Автоматически передаются сервером в заголовках HTTP-запросов (как при запросе, так и при ответе). Это означает, что cookies могут быть прочитаны и изменены как на стороне клиента, так и на стороне сервера.\n•  Безопасность:\n  •  HTTPOnly: Атрибут cookie, который предотвращает доступ к cookie из JavaScript, снижая риск XSS-атак.\n  •  Secure: Атрибут cookie, который указывает, что cookie должен передаваться только по HTTPS, обеспечивая защиту от перехвата данных.\n•  Пример:\n    // Установка cookie\n    document.cookie = \"username=John Doe; expires=Thu, 18 Dec 2024 12:00:00 UTC; path=/\";\n    // Получение cookie\n    const cookies = document.cookie;\n2. localStorage\n•  Что это: localStorage - это веб-хранилище, которое позволяет веб-приложениям хранить данные на компьютере пользователя на постоянной основе (данные сохраняются между сессиями браузера).\n•  Назначение:\n  •  Хранение пользовательских настроек.\n  •  Кэширование данных для повышения производительности.\n  •  Хранение состояния приложения между сессиями.\n•  Срок хранения: Данные сохраняются, пока пользователь явно не удалит их или не очистит данные браузера.\n•  Объем хранимых данных: Значительно больше, чем у cookies - обычно около 5-10MB на домен (зависит от браузера).\n•  Доступность:\n  •  Скрипты на стороне клиента: Доступны только через JavaScript.\n  •  Сервер: Не передаются автоматически в HTTP-запросах. Это означает, что localStorage предназначен только для хранения данных, используемых клиентским кодом.\n•  Безопасность:\n  •  Более безопасно, чем cookies, потому что данные не передаются автоматически на сервер, снижая риск перехвата.\n  •  Однако, подвержены XSS-атакам, если злоумышленник сможет выполнить произвольный JavaScript-код на сайте.\n•  Пример:\n    // Сохранение данных\n    localStorage.setItem('name', 'John Doe');\n    // Получение данных\n    const name = localStorage.getItem('name');\n    // Удаление данных\n    localStorage.removeItem('name');\n    // Очистка всего хранилища\n    localStorage.clear();\n3. sessionStorage\n•  Что это: sessionStorage - это веб-хранилище, которое позволяет веб-приложениям хранить данные только на время текущей сессии браузера (данные удаляются при закрытии вкладки или окна браузера).\n•  Назначение:\n  •  Хранение временных данных сессии (например, информация о текущем заказе в интернет-магазине).\n  •  Хранение состояния приложения в рамках одной сессии.\n•  Срок хранения: Данные удаляются при закрытии вкладки или окна браузера.\n•  Объем хранимых данных: Как и localStorage, имеет больший объем, чем cookies (около 5-10MB на домен).\n•  Доступность:\n  •  Скрипты на стороне клиента: Доступны только через JavaScript.\n  •  Сервер: Не передаются автоматически в HTTP-запросах.\n•  Безопасность:\n  •  Похожа на localStorage - более безопасно, чем cookies, но подвержено XSS-атакам.\n  •  Поскольку данные хранятся только на время сессии, это может снизить риск, связанный с компрометацией данных, если сравнивать с localStorage.\n•  Пример:\n    // Сохранение данных\n    sessionStorage.setItem('sessionData', 'Some session specific data');\n    // Получение данных\n    const sessionData = sessionStorage.getItem('sessionData');\n    // Удаление данных\n    sessionStorage.removeItem('sessionData');\n    // Очистка всего хранилища\n    sessionStorage.clear();\nКогда что использовать:\n\n•  Cookies: Используйте cookies для хранения небольших объемов данных, которые необходимо передавать на сервер (например, идентификатор сессии, параметры авторизации, языковые настройки). Особенно если вам нужно поддерживать старые браузеры.\n\n•  localStorage: Используйте localStorage для хранения больших объемов данных, которые не нужно передавать на сервер и которые должны сохраняться между сессиями (например, пользовательские настройки приложения, кэшированные данные).\n\n•  sessionStorage: Используйте sessionStorage для хранения временных данных, которые необходимы только в течение текущей сессии (например, состояние формы, данные о корзине покупок).\n\nРекомендации по безопасности:\n\n•  Защита от XSS-атак: Независимо от выбранного способа хранения данных, всегда тщательно проверяйте и экранируйте все данные, которые отображаете на странице, чтобы предотвратить XSS-атаки.\n•  HTTPOnly и Secure атрибуты для cookies: Всегда используйте атрибуты HTTPOnly и Secure для cookies, если они не должны быть доступны из JavaScript и должны передаваться только по HTTPS.\n•  Не храните конфиденциальные данные: Избегайте хранения конфиденциальной информации (например, паролей, номеров кредитных карт) в любом из этих хранилищ. Если вам необходимо хранить конфиденциальные данные на стороне клиента, используйте надежные методы шифрования.\n•  Очистка хранилища: Предоставьте пользователям возможность очищать данные, хранящиеся в localStorage и cookies, чтобы они могли контролировать свою конфиденциальность.\n\nПравильный выбор между localStorage, sessionStorage и cookies зависит от требований вашего приложения к объему данных, сроку хранения, доступности и безопасности. Помните о рисках безопасности и принимайте соответствующие меры для защиты данных ваших пользователей.\n",
    "group": "Браузер",
    "subGroup": "Basic",
    "ignoreHtml": false,
    "order": 1,
    "_created": "2025-09-27T18:41:09.508Z",
    "_changed": "2025-09-27T18:41:09.508Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "localstorage",
      "sessionstorage",
      "cookies",
      "это",
      "три",
      "разных",
      "способа",
      "хранения",
      "данных",
      "на",
      "стороне",
      "клиента",
      "(в",
      "браузере",
      "пользователя)",
      "они",
      "отличаются",
      "по",
      "своему",
      "назначению",
      "объему",
      "хранимых",
      "сроку",
      "доступности",
      "понимание",
      "этих",
      "различий",
      "необходимо",
      "для",
      "выбора",
      "подходящего",
      "решения",
      "информации",
      "веб-приложениях",
      "что",
      "это:",
      "небольшие",
      "текстовые",
      "файлы",
      "которые",
      "веб-сайт",
      "сохраняет",
      "компьютере",
      "пользователя",
      "используются",
      "различной",
      "такой",
      "как",
      "предпочтения",
      "данные",
      "сеанса",
      "или",
      "идентификаторы",
      "отслеживания",
      "назначение:",
      "управление",
      "сессиями:",
      "отслеживание",
      "состояния",
      "сессии",
      "(например",
      "авторизован",
      "ли",
      "он)",
      "персонализация:",
      "запоминание",
      "предпочтений",
      "язык",
      "интерфейса",
      "тема",
      "оформления)",
      "отслеживание:",
      "действий",
      "сайте",
      "аналитики",
      "рекламы",
      "срок",
      "хранения:",
      "может",
      "быть",
      "разным:",
      "сессионные",
      "cookies:",
      "удаляются",
      "при",
      "закрытии",
      "браузера",
      "постоянные",
      "хранятся",
      "течение",
      "заданного",
      "времени",
      "несколько",
      "дней",
      "месяцев",
      "лет)",
      "объем",
      "данных:",
      "ограничен",
      "обычно",
      "около",
      "4kb",
      "cookie",
      "общее",
      "ограничение",
      "~20",
      "домен",
      "доступность:",
      "скрипты",
      "клиента:",
      "доступны",
      "через",
      "javascript",
      "сервер:",
      "автоматически",
      "передаются",
      "сервером",
      "заголовках",
      "http-запросов",
      "(как",
      "запросе",
      "так",
      "ответе)",
      "означает",
      "могут",
      "прочитаны",
      "изменены",
      "сервера",
      "безопасность:",
      "httponly:",
      "атрибут",
      "который",
      "предотвращает",
      "доступ",
      "из",
      "снижая",
      "риск",
      "xss-атак",
      "secure:",
      "указывает",
      "должен",
      "передаваться",
      "только",
      "https",
      "обеспечивая",
      "защиту",
      "от",
      "перехвата",
      "пример:",
      "//",
      "установка",
      "document",
      "\"username=john",
      "doe;",
      "expires=thu",
      "18",
      "dec",
      "2024",
      "12:00:00",
      "utc;",
      "path=/\";",
      "получение",
      "const",
      "cookie;",
      "веб-хранилище",
      "которое",
      "позволяет",
      "веб-приложениям",
      "хранить",
      "постоянной",
      "основе",
      "(данные",
      "сохраняются",
      "между",
      "сессиями",
      "браузера)",
      "хранение",
      "пользовательских",
      "настроек",
      "кэширование",
      "повышения",
      "производительности",
      "приложения",
      "пока",
      "пользователь",
      "явно",
      "не",
      "удалит",
      "их",
      "очистит",
      "значительно",
      "больше",
      "чем",
      "5-10mb",
      "(зависит",
      "http-запросах",
      "предназначен",
      "используемых",
      "клиентским",
      "кодом",
      "более",
      "безопасно",
      "потому",
      "сервер",
      "однако",
      "подвержены",
      "xss-атакам",
      "если",
      "злоумышленник",
      "сможет",
      "выполнить",
      "произвольный",
      "javascript-код",
      "сохранение",
      "setitem('name'",
      "'john",
      "doe');",
      "name",
      "getitem('name');",
      "удаление",
      "removeitem('name');",
      "очистка",
      "всего",
      "хранилища",
      "clear();",
      "время",
      "текущей",
      "вкладки",
      "окна",
      "временных",
      "информация",
      "текущем",
      "заказе",
      "интернет-магазине)",
      "рамках",
      "одной",
      "имеет",
      "больший",
      "(около",
      "домен)",
      "похожа",
      "но",
      "подвержено",
      "поскольку",
      "снизить",
      "связанный",
      "компрометацией",
      "сравнивать",
      "setitem('sessiondata'",
      "'some",
      "session",
      "specific",
      "data');",
      "sessiondata",
      "getitem('sessiondata');",
      "removeitem('sessiondata');",
      "когда",
      "использовать:",
      "используйте",
      "небольших",
      "объемов",
      "передавать",
      "идентификатор",
      "параметры",
      "авторизации",
      "языковые",
      "настройки)",
      "особенно",
      "вам",
      "нужно",
      "поддерживать",
      "старые",
      "браузеры",
      "localstorage:",
      "больших",
      "должны",
      "сохраняться",
      "пользовательские",
      "настройки",
      "кэшированные",
      "данные)",
      "sessionstorage:",
      "необходимы",
      "состояние",
      "формы",
      "корзине",
      "покупок)",
      "рекомендации",
      "безопасности:",
      "защита",
      "xss-атак:",
      "независимо",
      "выбранного",
      "всегда",
      "тщательно",
      "проверяйте",
      "экранируйте",
      "все",
      "отображаете",
      "странице",
      "чтобы",
      "предотвратить",
      "xss-атаки",
      "httponly",
      "secure",
      "атрибуты",
      "храните",
      "конфиденциальные",
      "данные:",
      "избегайте",
      "конфиденциальной",
      "паролей",
      "номеров",
      "кредитных",
      "карт)",
      "любом",
      "хранилищ",
      "надежные",
      "методы",
      "шифрования",
      "хранилища:",
      "предоставьте",
      "пользователям",
      "возможность",
      "очищать",
      "хранящиеся",
      "могли",
      "контролировать",
      "свою",
      "конфиденциальность",
      "правильный",
      "выбор",
      "зависит",
      "требований",
      "вашего",
      "безопасности",
      "помните",
      "рисках",
      "принимайте",
      "соответствующие",
      "меры",
      "защиты",
      "ваших",
      "пользователей",
      "браузер",
      "basic"
    ],
    "_tags": "api localstorage sessionstorage cookies это три разных способа хранения данных на стороне клиента (в браузере пользователя) они отличаются по своему назначению объему хранимых сроку доступности понимание этих различий необходимо для выбора подходящего решения информации веб-приложениях что это: небольшие текстовые файлы которые веб-сайт сохраняет компьютере пользователя используются различной такой как предпочтения данные сеанса или идентификаторы отслеживания назначение: управление сессиями: отслеживание состояния сессии (например авторизован ли он) персонализация: запоминание предпочтений язык интерфейса тема оформления) отслеживание: действий сайте аналитики рекламы срок хранения: может быть разным: сессионные cookies: удаляются при закрытии браузера постоянные хранятся течение заданного времени несколько дней месяцев лет) объем данных: ограничен обычно около 4kb cookie общее ограничение ~20 домен доступность: скрипты клиента: доступны через javascript сервер: автоматически передаются сервером заголовках http-запросов (как запросе так ответе) означает могут прочитаны изменены сервера безопасность: httponly: атрибут который предотвращает доступ из снижая риск xss-атак secure: указывает должен передаваться только https обеспечивая защиту от перехвата пример: // установка document \"username=john doe; expires=thu 18 dec 2024 12:00:00 utc; path=/\"; получение const cookie; веб-хранилище которое позволяет веб-приложениям хранить постоянной основе (данные сохраняются между сессиями браузера) хранение пользовательских настроек кэширование повышения производительности приложения пока пользователь явно не удалит их очистит значительно больше чем 5-10mb (зависит http-запросах предназначен используемых клиентским кодом более безопасно потому сервер однако подвержены xss-атакам если злоумышленник сможет выполнить произвольный javascript-код сохранение setitem('name' 'john doe'); name getitem('name'); удаление removeitem('name'); очистка всего хранилища clear(); время текущей вкладки окна временных информация текущем заказе интернет-магазине) рамках одной имеет больший (около домен) похожа но подвержено поскольку снизить связанный компрометацией сравнивать setitem('sessiondata' 'some session specific data'); sessiondata getitem('sessiondata'); removeitem('sessiondata'); когда использовать: используйте небольших объемов передавать идентификатор параметры авторизации языковые настройки) особенно вам нужно поддерживать старые браузеры localstorage: больших должны сохраняться пользовательские настройки кэшированные данные) sessionstorage: необходимы состояние формы корзине покупок) рекомендации безопасности: защита xss-атак: независимо выбранного всегда тщательно проверяйте экранируйте все отображаете странице чтобы предотвратить xss-атаки httponly secure атрибуты храните конфиденциальные данные: избегайте конфиденциальной паролей номеров кредитных карт) любом хранилищ надежные методы шифрования хранилища: предоставьте пользователям возможность очищать хранящиеся могли контролировать свою конфиденциальность правильный выбор зависит требований вашего безопасности помните рисках принимайте соответствующие меры защиты ваших пользователей браузер basic",
    "_version": 0
  },
  {
    "_id": "68dac44e0d20f7250001838c",
    "title": "retetetetetetetetetet",
    "content": "etetrrrrrrrrrrrrr",
    "group": "Группа1",
    "subGroup": "sdfsdfsdf",
    "ignoreHtml": false,
    "order": 8,
    "_created": "2025-09-29T17:39:26.744Z",
    "_changed": "2025-09-29T17:39:26.744Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "retetetetetetetetetet",
      "etetrrrrrrrrrrrrr",
      "группа1",
      "sdfsdfsdf"
    ],
    "_tags": "api retetetetetetetetetet etetrrrrrrrrrrrrr группа1 sdfsdfsdf",
    "_version": 0
  },
  {
    "_id": "68e2b5e10d20f7250002213a",
    "title": "trest",
    "content": "  <pre><code appHighlight>\nget selectedGroupFormControl(): FormControl {\n    return this.group.get(ArticleFormFields.SELECTED_GROUP) as FormControl;\n  }\n\n  get selectedSubGroupFormControl(): FormControl {\n    return this.group.get(ArticleFormFields.SELECTED_SUB_GROUP) as FormControl;\n  }\n\n  get newGroupFormControl(): FormControl {\n    return this.group.get(ArticleFormFields.NEW_GROUP) as FormControl;\n  }\n\n  get newSubGroupFormControl(): FormControl {\n</code></pre>",
    "group": "Группа1",
    "subGroup": "sdfsdfsdf",
    "ignoreHtml": false,
    "order": 9,
    "_created": "2025-10-05T18:16:01.148Z",
    "_changed": "2025-10-05T18:16:01.148Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "trest",
      "get",
      "selectedgroupformcontrol():",
      "formcontrol",
      "return",
      "this",
      "group",
      "get(articleformfields",
      "selected_group)",
      "as",
      "formcontrol;",
      "selectedsubgroupformcontrol():",
      "selected_sub_group)",
      "newgroupformcontrol():",
      "new_group)",
      "newsubgroupformcontrol():",
      "группа1",
      "sdfsdfsdf"
    ],
    "_tags": "api trest get selectedgroupformcontrol(): formcontrol return this group get(articleformfields selected_group) as formcontrol; selectedsubgroupformcontrol(): selected_sub_group) newgroupformcontrol(): new_group) newsubgroupformcontrol(): группа1 sdfsdfsdf",
    "_version": 0
  },
  {
    "_id": "68ed39410d20f7250002f7a3",
    "title": "call(), apply() и bind()",
    "content": "call(), apply() и bind() в JavaScript — это методы для управления контекстом (this) функции. \nОсновное отличие: call() и apply() немедленно выполняют функцию, передавая аргументы по-разному call — списком, apply — массивом). \nbind() создает новую функцию с привязанным this, которую можно вызвать позже. \ncall() Выполняет функцию немедленно. Позволяет указать значение this для функции. Аргументы для функции передаются списком, через запятую. \nПример: <pre><code>myFunction.call(context, arg1, arg2).apply()</code></pre> Выполняет функцию немедленно. Позволяет указать значение this для функции. Аргументы для функции передаются массивом. Пример: <pre><code>myFunction.apply(context, [arg1, arg2]). bind()</code></pre> bind() не выполняет функцию сразу. Возвращает новую функцию с привязанным значением this. Аргументы можно передать при создании новой функции или при ее последующем вызове. Пример: <pre><code>const newFunction = myFunction.bind(context, arg1).</code></pre> \n\n<pre><code>const car = {\n  model: 'Toyota',\n  year: 2007,\n  showModel: function(color, engine){\n    console.log(this.model, color, engine);\n  }\n};\n\n// car.showModel.apply(anotherCar, ['red', 'diesel']);\nconst modelShower = car.showModel.bind(anotherCar);\nmodelShower('black', 'diesel');</code></pre>\n",
    "group": "JavaScript",
    "subGroup": "JavaScript Deep",
    "ignoreHtml": false,
    "order": 4,
    "_created": "2025-10-13T17:39:13.477Z",
    "_changed": "2025-10-13T17:42:30.146Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "call()",
      "apply()",
      "bind()",
      "javascript",
      "это",
      "методы",
      "для",
      "управления",
      "контекстом",
      "(this)",
      "функции",
      "основное",
      "отличие:",
      "немедленно",
      "выполняют",
      "функцию",
      "передавая",
      "аргументы",
      "по-разному",
      "call",
      "списком",
      "apply",
      "массивом)",
      "создает",
      "новую",
      "привязанным",
      "this",
      "которую",
      "можно",
      "вызвать",
      "позже",
      "call() выполняет",
      "позволяет",
      "указать",
      "значение",
      "передаются",
      "через",
      "запятую",
      "пример:",
      "myfunction",
      "call(context",
      "arg1",
      "arg2)",
      "apply() выполняет",
      "массивом",
      "apply(context",
      "[arg1",
      "arg2])",
      " bind() bind()",
      "не",
      "выполняет",
      "сразу",
      "возвращает",
      "значением",
      "передать",
      "при",
      "создании",
      "новой",
      "или",
      "ее",
      "последующем",
      "вызове",
      "const",
      "newfunction",
      "bind(context",
      "arg1)",
      "car",
      "model:",
      "'toyota'",
      "year:",
      "2007",
      "showmodel:",
      "function(color",
      "engine){",
      "console",
      "log(this",
      "model",
      "color",
      "engine);",
      "};",
      "//",
      "showmodel",
      "apply(anothercar",
      "['red'",
      "'diesel']);",
      "modelshower",
      "bind(anothercar);",
      "modelshower('black'",
      "'diesel');",
      "deep"
    ],
    "_tags": "api call() apply() bind() javascript это методы для управления контекстом (this) функции основное отличие: немедленно выполняют функцию передавая аргументы по-разному call списком apply массивом) создает новую привязанным this которую можно вызвать позже call() выполняет позволяет указать значение передаются через запятую пример: myfunction call(context arg1 arg2) apply() выполняет массивом apply(context [arg1 arg2])  bind() bind() не выполняет сразу возвращает значением передать при создании новой или ее последующем вызове const newfunction bind(context arg1) car model: 'toyota' year: 2007 showmodel: function(color engine){ console log(this model color engine); }; // showmodel apply(anothercar ['red' 'diesel']); modelshower bind(anothercar); modelshower('black' 'diesel'); deep",
    "_version": 2
  },
  {
    "_id": "68c331e8f63b804800273b9c",
    "title": "Const, let и var - область видимости",
    "content": "Различия между const, let и var в JavaScript (и TypeScript) касаются области видимости (scope), переопределения (redeclaration) и переназначения (reassignment) переменных. Понимание этих различий критично для написания чистого, поддерживаемого и предсказуемого кода.\n\n1. Область видимости (Scope):\n•  var:\n  •  Функциональная область видимости (Function Scope): Переменные, объявленные с помощью var, доступны внутри функции, в которой они объявлены. Если переменная объявлена вне какой-либо функции, она становится глобальной переменной.\n  •  Подъем (Hoisting): Переменные, объявленные с помощью var, \"поднимаются\" в начало своей области видимости. Это означает, что вы можете использовать переменную до того, как она объявлена, но ее значение будет undefined.\n\n•  let и const:\n  •  Блочная область видимости (Block Scope): Переменные, объявленные с помощью let и const, доступны только внутри блока (между фигурными скобками {}), в котором они объявлены (например, внутри циклов for, while, условных операторов if, else и т.д.).\n  •  Подъем (Hoisting): Переменные, объявленные с помощью let и const, также \"поднимаются\", но не инициализируются. Это означает, что попытка использовать переменную до ее объявления приведет к ошибке ReferenceError (нельзя получить доступ к переменной до инициализации).\n\n<pre><code>function testScope() {\n  if (true) {\n    var x = 10;  // var имеет функциональную область видимости\n    let y = 20;  // let имеет блочную область видимости\n    const z = 30; // const имеет блочную область видимости\n  }\n  console.log(x); // 10 (x доступна, так как объявлена с var)\n  // console.log(y); // ReferenceError: y is not defined (y не доступна, так как объявлена с let)\n  // console.log(z); // ReferenceError: z is not defined (z не доступна, так как объявлена с const)\n}</code></pre>",
    "group": "Typescript",
    "subGroup": "Typescript Basic",
    "ignoreHtml": false,
    "order": 5,
    "imageUrls": "",
    "_created": "2025-09-11T20:32:40.256Z",
    "_changed": "2025-10-13T17:21:31.299Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "const",
      "let",
      "var",
      "область",
      "видимости",
      "различия",
      "между",
      "javascript",
      "(и",
      "typescript)",
      "касаются",
      "области",
      "(scope)",
      "переопределения",
      "(redeclaration)",
      "переназначения",
      "(reassignment)",
      "переменных",
      "понимание",
      "этих",
      "различий",
      "критично",
      "для",
      "написания",
      "чистого",
      "поддерживаемого",
      "предсказуемого",
      "кода",
      "(scope):",
      "var:",
      "функциональная",
      "(function",
      "scope):",
      "переменные",
      "объявленные",
      "помощью",
      "доступны",
      "внутри",
      "функции",
      "которой",
      "они",
      "объявлены",
      "если",
      "переменная",
      "объявлена",
      "вне",
      "какой-либо",
      "она",
      "становится",
      "глобальной",
      "переменной",
      "подъем",
      "(hoisting):",
      "\"поднимаются\"",
      "начало",
      "своей",
      "это",
      "означает",
      "что",
      "вы",
      "можете",
      "использовать",
      "переменную",
      "до",
      "того",
      "как",
      "но",
      "ее",
      "значение",
      "будет",
      "const:",
      "блочная",
      "(block",
      "только",
      "блока",
      "(между",
      "фигурными",
      "скобками",
      "{})",
      "котором",
      "(например",
      "циклов",
      "for",
      "while",
      "условных",
      "операторов",
      "if",
      "else",
      "также",
      "не",
      "инициализируются",
      "попытка",
      "объявления",
      "приведет",
      "ошибке",
      "referenceerror",
      "(нельзя",
      "получить",
      "доступ",
      "инициализации)",
      "function",
      "testscope()",
      "(true)",
      "10;",
      "//",
      "имеет",
      "функциональную",
      "20;",
      "блочную",
      "30;",
      "console",
      "log(x);",
      "10",
      "(x",
      "доступна",
      "так",
      "var)",
      "log(y);",
      "referenceerror:",
      "is",
      "not",
      "defined",
      "(y",
      "let)",
      "log(z);",
      "(z",
      "const)",
      "typescript",
      "basic"
    ],
    "_tags": "api const let var область видимости различия между javascript (и typescript) касаются области (scope) переопределения (redeclaration) переназначения (reassignment) переменных понимание этих различий критично для написания чистого поддерживаемого предсказуемого кода (scope): var: функциональная (function scope): переменные объявленные помощью доступны внутри функции которой они объявлены если переменная объявлена вне какой-либо она становится глобальной переменной подъем (hoisting): \"поднимаются\" начало своей это означает что вы можете использовать переменную до того как но ее значение будет const: блочная (block только блока (между фигурными скобками {}) котором (например циклов for while условных операторов if else также не инициализируются попытка объявления приведет ошибке referenceerror (нельзя получить доступ инициализации) function testscope() (true) 10; // имеет функциональную 20; блочную 30; console log(x); 10 (x доступна так var) log(y); referenceerror: is not defined (y let) log(z); (z const) typescript basic",
    "_version": 1
  },
  {
    "_id": "68dad2290d20f72500018483",
    "title": "Dependency Injection",
    "content": "Dependency Injection (DI) в Angular — это встроенная система для предоставления зависимостей (сервисов, значений, фабрик) туда, где они нужны, без явного new и ручного управления зависимостями.\nВ системе DI существуют две основные роли: потребитель зависимостей и поставщик зависимостей.\n\nAngular облегчает взаимодействие между потребителями зависимостей и поставщиками зависимостей, используя абстракцию под названием Injector. Когда запрашивается зависимость, инжектор проверяет свой реестр на предмет наличия уже доступного экземпляра. Если нет, создается новый экземпляр и сохраняется в реестре. Angular создает инжектор для всего приложения (также известный как \"корневой\" инжектор) во время процесса загрузки приложения, а также другие инжекторы по мере необходимости. В большинстве случаев вам не нужно вручную создавать инжекторы, но вы должны знать, что существует слой, соединяющий провайдеров и потребителей.\n\nПредоставление зависимостей\nПредставьте, что есть класс HeroService, который должен выступать в качестве зависимости в компоненте.\n\nПервым шагом будет добавление декоратора @Injectable, чтобы показать, что класс может быть инжектирован.\n\n<b>@Injectable()\nclass HeroService {}</b>\nСледующий шаг — сделать ее доступной в DI, предоставив ее. Зависимость может быть предоставлена в нескольких местах:\n\nНа уровне компонента, используя поле providers декоратора @Component. В этом случае HeroService становится доступным для всех экземпляров этого компонента и других компонентов и директив, используемых в шаблоне. Например:\n\n@Component({\n    selector: 'hero-list',\n    template: '...',\n    providers: [HeroService],\n})\nclass HeroListComponent {}\nКогда вы регистрируете провайдера на уровне компонента, вы получаете новый экземпляр сервиса с каждым новым экземпляром этого компонента.\n\nНа уровне NgModule, используя поле providers декоратора @NgModule. В этом сценарии HeroService доступен для всех компонентов, директив и пайпов, объявленных в этом NgModule или другом NgModule, который находится внутри того же ModuleInjector, применимого к этому NgModule. Когда вы регистрируете провайдера в определенном NgModule, один и тот же экземпляр сервиса становится доступным для всех применимых компонентов, директив и пайпов.\nЧтобы понять все крайние случаи, смотрите Иерархические инжекторы. Например:\n\n@NgModule({\n    declarations: [HeroListComponent],\n    providers: [HeroService],\n})\nclass HeroListModule {}\nНа уровне корня приложения, что позволяет инжектировать его в другие классы приложения. Это можно сделать, добавив поле providedIn: 'root' в декоратор @Injectable:\n\n@Injectable({\n    providedIn: 'root',\n})\nclass HeroService {}\nКогда вы предоставляете сервис на корневом уровне, Angular создает единственный, общий экземпляр HeroService и внедряет его в любой класс, который его запрашивает. Регистрация провайдера в метаданных @Injectable также позволяет Angular оптимизировать приложение, удаляя сервис из скомпилированного приложения, если он не используется, процесс, известный как tree-shaking.\n\nИнжектирование зависимости¶\nСамый распространенный способ внедрения зависимости — объявить ее в конструкторе класса. Когда Angular создает новый экземпляр компонента, директивы или класса pipe, он определяет, какие сервисы или другие зависимости нужны этому классу, глядя на типы параметров конструктора. Например, если HeroListComponent нуждается в HeroService, конструктор может выглядеть следующим образом:\n\n@Component({\n    /* ... */\n})\nclass HeroListComponent {\n    constructor(private service: HeroService) {}\n}\nКогда Angular обнаруживает, что компонент зависит от сервиса, он сначала проверяет, есть ли в инжекторе существующие экземпляры этого сервиса. Если запрошенный экземпляр сервиса еще не существует, инжектор создает его, используя зарегистрированного провайдера, и добавляет его в инжектор перед тем, как вернуть сервис в Angular.\n\nКогда все запрошенные сервисы будут разрешены и возвращены, Angular может вызвать конструктор компонента с этими сервисами в качестве аргументов\n <p><img src=\"https://angdev.ru/angular/injector-injects.png\" alt=\"В\" style=\"max-width: 100%;\"></p> \n",
    "group": "Angular",
    "subGroup": "Angular Deep",
    "ignoreHtml": false,
    "order": 4,
    "_created": "2025-09-29T18:38:33.877Z",
    "_changed": "2025-09-29T18:41:56.773Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "dependency",
      "injection",
      "(di)",
      "angular",
      "это",
      "встроенная",
      "система",
      "для",
      "предоставления",
      "зависимостей",
      "(сервисов",
      "значений",
      "фабрик)",
      "туда",
      "где",
      "они",
      "нужны",
      "без",
      "явного",
      "new",
      "ручного",
      "управления",
      "зависимостями",
      "системе",
      "di",
      "существуют",
      "две",
      "основные",
      "роли:",
      "потребитель",
      "поставщик",
      "облегчает",
      "взаимодействие",
      "между",
      "потребителями",
      "поставщиками",
      "используя",
      "абстракцию",
      "под",
      "названием",
      "injector",
      "когда",
      "запрашивается",
      "зависимость",
      "инжектор",
      "проверяет",
      "свой",
      "реестр",
      "на",
      "предмет",
      "наличия",
      "уже",
      "доступного",
      "экземпляра",
      "если",
      "нет",
      "создается",
      "новый",
      "экземпляр",
      "сохраняется",
      "реестре",
      "создает",
      "всего",
      "приложения",
      "(также",
      "известный",
      "как",
      "\"корневой\"",
      "инжектор)",
      "во",
      "время",
      "процесса",
      "загрузки",
      "также",
      "другие",
      "инжекторы",
      "по",
      "мере",
      "необходимости",
      "большинстве",
      "случаев",
      "вам",
      "не",
      "нужно",
      "вручную",
      "создавать",
      "но",
      "вы",
      "должны",
      "знать",
      "что",
      "существует",
      "слой",
      "соединяющий",
      "провайдеров",
      "потребителей",
      "предоставление",
      "представьте",
      "есть",
      "класс",
      "heroservice",
      "который",
      "должен",
      "выступать",
      "качестве",
      "зависимости",
      "компоненте",
      "первым",
      "шагом",
      "будет",
      "добавление",
      "декоратора",
      "injectable",
      "чтобы",
      "показать",
      "может",
      "быть",
      "инжектирован",
      "injectable()",
      "class",
      "{}",
      "следующий",
      "шаг",
      "сделать",
      "ее",
      "доступной",
      "предоставив",
      "предоставлена",
      "нескольких",
      "местах:",
      "уровне",
      "компонента",
      "поле",
      "providers",
      "component",
      "этом",
      "случае",
      "становится",
      "доступным",
      "всех",
      "экземпляров",
      "этого",
      "других",
      "компонентов",
      "директив",
      "используемых",
      "шаблоне",
      "например:",
      "component({",
      "selector:",
      "'hero-list'",
      "template:",
      "providers:",
      "[heroservice]",
      "})",
      "herolistcomponent",
      "регистрируете",
      "провайдера",
      "получаете",
      "сервиса",
      "каждым",
      "новым",
      "экземпляром",
      "ngmodule",
      "сценарии",
      "доступен",
      "пайпов",
      "объявленных",
      "или",
      "другом",
      "находится",
      "внутри",
      "того",
      "же",
      "moduleinjector",
      "применимого",
      "этому",
      "определенном",
      "один",
      "тот",
      "применимых",
      "понять",
      "все",
      "крайние",
      "случаи",
      "смотрите",
      "иерархические",
      "ngmodule({",
      "declarations:",
      "[herolistcomponent]",
      "herolistmodule",
      "корня",
      "позволяет",
      "инжектировать",
      "его",
      "классы",
      "можно",
      "добавив",
      "providedin:",
      "'root'",
      "декоратор",
      "injectable:",
      "injectable({",
      "предоставляете",
      "сервис",
      "корневом",
      "единственный",
      "общий",
      "внедряет",
      "любой",
      "запрашивает",
      "регистрация",
      "метаданных",
      "оптимизировать",
      "приложение",
      "удаляя",
      "из",
      "скомпилированного",
      "он",
      "используется",
      "процесс",
      "tree-shaking",
      "инжектирование",
      "зависимости¶",
      "самый",
      "распространенный",
      "способ",
      "внедрения",
      "объявить",
      "конструкторе",
      "класса",
      "директивы",
      "pipe",
      "определяет",
      "какие",
      "сервисы",
      "классу",
      "глядя",
      "типы",
      "параметров",
      "конструктора",
      "например",
      "нуждается",
      "конструктор",
      "выглядеть",
      "следующим",
      "образом:",
      "/*",
      "*/",
      "constructor(private",
      "service:",
      "heroservice)",
      "обнаруживает",
      "компонент",
      "зависит",
      "от",
      "сначала",
      "ли",
      "инжекторе",
      "существующие",
      "экземпляры",
      "запрошенный",
      "еще",
      "зарегистрированного",
      "добавляет",
      "перед",
      "тем",
      "вернуть",
      "запрошенные",
      "будут",
      "разрешены",
      "возвращены",
      "вызвать",
      "этими",
      "сервисами",
      "аргументов",
      "deep"
    ],
    "_tags": "api dependency injection (di) angular это встроенная система для предоставления зависимостей (сервисов значений фабрик) туда где они нужны без явного new ручного управления зависимостями системе di существуют две основные роли: потребитель поставщик облегчает взаимодействие между потребителями поставщиками используя абстракцию под названием injector когда запрашивается зависимость инжектор проверяет свой реестр на предмет наличия уже доступного экземпляра если нет создается новый экземпляр сохраняется реестре создает всего приложения (также известный как \"корневой\" инжектор) во время процесса загрузки также другие инжекторы по мере необходимости большинстве случаев вам не нужно вручную создавать но вы должны знать что существует слой соединяющий провайдеров потребителей предоставление представьте есть класс heroservice который должен выступать качестве зависимости компоненте первым шагом будет добавление декоратора injectable чтобы показать может быть инжектирован injectable() class {} следующий шаг сделать ее доступной предоставив предоставлена нескольких местах: уровне компонента поле providers component этом случае становится доступным всех экземпляров этого других компонентов директив используемых шаблоне например: component({ selector: 'hero-list' template: providers: [heroservice] }) herolistcomponent регистрируете провайдера получаете сервиса каждым новым экземпляром ngmodule сценарии доступен пайпов объявленных или другом находится внутри того же moduleinjector применимого этому определенном один тот применимых понять все крайние случаи смотрите иерархические ngmodule({ declarations: [herolistcomponent] herolistmodule корня позволяет инжектировать его классы можно добавив providedin: 'root' декоратор injectable: injectable({ предоставляете сервис корневом единственный общий внедряет любой запрашивает регистрация метаданных оптимизировать приложение удаляя из скомпилированного он используется процесс tree-shaking инжектирование зависимости¶ самый распространенный способ внедрения объявить конструкторе класса директивы pipe определяет какие сервисы классу глядя типы параметров конструктора например нуждается конструктор выглядеть следующим образом: /* */ constructor(private service: heroservice) обнаруживает компонент зависит от сначала ли инжекторе существующие экземпляры запрошенный еще зарегистрированного добавляет перед тем вернуть запрошенные будут разрешены возвращены вызвать этими сервисами аргументов deep",
    "_version": 1
  },
  {
    "_id": "68b72e9af63b804800264775",
    "title": "Семантические теги",
    "content": "Семантические теги HTML - это теги, которые несут смысл о структуре и содержании документа, помимо простого форматирования. Они помогают поисковым системам, вспомогательным технологиям и другим системам понимать смысл вашего контента, что приводит к лучшей доступности, SEO и общей структуре.\n\nВот полный список семантических тегов HTML с их описанием и типичным использованием:\n\nСтруктурные теги:\n•   <article>:  Представляет собой самостоятельный, независимый элемент контента, который может быть распространен независимо от остальной части страницы. Например, статья блога, новостная статья, форумный пост.  Может содержать <header>, <footer>, <section>.\n•   <aside>:  Содержит контент, который относится к окружающему контенту, но не является его основной частью. Часто используется для боковых панелей, рекламных блоков, цитат, дополнительной информации.\n•   <details>:  Представляет собой виджет, из которого пользователь может получить дополнительную информацию по запросу. Обычно используется для скрытия и отображения длинных разделов текста, например, часто задаваемых вопросов.  Внутри должен быть <summary>.\n•   <figcaption>:  Представляет собой заголовок или описание для элемента <figure>.\n•   <figure>:  Представляет собой самодостаточный контент, такой как изображение, диаграмма, иллюстрация, код и т.д., на который может быть ссылка из основного текста, но который можно переместить без ущерба для понимания.\n•   <footer>:  Представляет собой нижний колонтитул для раздела или всего документа. Содержит информацию об авторе, авторских правах, контактную информацию, ссылки на связанные документы.\n•   <header>:  Представляет собой вводный контент для раздела или всего документа. Обычно содержит заголовок, логотип, меню навигации.\n•   <main>:  Представляет собой основное содержимое документа. В документе может быть только один <main>.  Не должно содержать контент, который повторяется в других документах (например, навигация, баннеры).\n•   <nav>:  Представляет собой раздел, содержащий навигационные ссылки.  Не все группы ссылок должны быть внутри <nav>. Используется для основной навигации сайта.\n•   <section>:  Представляет собой тематический раздел документа.  Каждая <section> обычно имеет заголовок. Если содержимое не является тематическим, лучше использовать <div>.\n•   <summary>:  Определяет видимый заголовок для элемента <details>. Щелчок по <summary> переключает видимость остальной части <details>.\n\nТекстовые семантические теги:\n•   <abbr>:  Представляет собой аббревиатуру или акроним. Атрибут title должен содержать полное развернутое значение.  Например, <abbr title=\"World Wide Web\">WWW</abbr>.\n•   <address>:  Представляет собой контактную информацию для автора или владельца документа или статьи.\n•   <cite>:  Представляет собой название работы (книга, статья, песня и т.д.).  Не должен содержать полное цитирование, только название.\n•   <code>:  Представляет собой фрагмент компьютерного кода.  Обычно используется моноширинный шрифт.  Для больших фрагментов кода рекомендуется использовать <pre><code>...</code></pre>.\n•   <data>:  Связывает машиночитаемую форму данных со своим содержимым. Атрибут value содержит машиночитаемую форму.\n•   <dfn>:  Представляет собой определяющий экземпляр термина.  Ближайший родительский элемент должен содержать определение термина.\n•   <em>:  Представляет собой акцент на тексте.  Обычно отображается курсивом.  Указывает на логическое ударение.\n•   <i>:  Представляет собой текст в альтернативном голосе или настроении.  Использовать только когда нет более подходящего семантического тега.  Например, термины на иностранном языке, мысли, названия кораблей.  Предпочтительнее использовать <em> или <strong>, если речь идет об акценте.\n•   <mark>:  Представляет собой текст, выделенный для справки или аннотации.\n•   <pre>:  Представляет собой предварительно отформатированный текст.  Сохраняет пробелы и переносы строк, как они есть в HTML-коде.  Часто используется для отображения кода.\n•   <q>:  Представляет собой короткую встроенную цитату.  Браузеры могут автоматически добавлять кавычки.  Атрибут cite указывает источник цитаты.\n•   <samp>:  Представляет собой пример вывода компьютерной программы.\n•   <small>:  Представляет собой побочные комментарии, мелкий шрифт.  Например, информацию об авторских правах.\n•   <strong>:  Представляет собой важный текст.  Обычно отображается полужирным шрифтом.  Указывает на сильную важность.\n•   <sub>:  Представляет собой нижний индекс.\n•   <sup>:  Представляет собой верхний индекс.\n•   <time>:  Представляет собой определенное время или дату. Атрибут datetime содержит дату/время в машиночитаемом формате.\n•   <var>:  Представляет собой переменную.\n•   <wbr>:  Указывает место в тексте, где браузер может разбить строку, если это необходимо.\n\nТеги для встраивания мультимедиа:\n•   <audio>:  Встраивает аудиоконтент.\n•   <video>:  Встраивает видеоконтент.\n•   <source>:  Определяет несколько источников мультимедиа для элементов <audio> и <video>.\n•   <track>:  Определяет текстовые дорожки для элементов <audio> и <video>. Например, субтитры.\n•   <embed>:  Встраивает внешние приложения или интерактивный контент (например, Flash).\n•   <object>:  Встраивает различные типы мультимедийного контента, включая изображения, аудио, видео, Flash, Java-апплеты и другие плагины.\n\nДругие семантические теги:\n•   <dialog>:  Представляет собой диалоговое окно или другое интерактивное окно, например, окно предупреждения или инспектор.\n\nКогда использовать семантические теги:\n•   Всякий раз, когда вы описываете структуру или значение контента, а не только его визуальное отображение.\n•   Вместо использования <div> и <span> везде, где это возможно.\n•   Чтобы улучшить доступность и SEO.\n\nПреимущества использования семантических тегов:\n•   SEO (Search Engine Optimization): Поисковые системы лучше понимают структуру вашего контента и могут более точно индексировать его.\n•   Доступность: Вспомогательные технологии (например, экранные читалки) могут правильно интерпретировать и предоставлять информацию пользователям с ограниченными возможностями.\n•   Поддержка разных устройств:  Семантические теги позволяют браузерам правильно отображать контент на различных устройствах, от компьютеров до мобильных телефонов.\n•   Чистый и читаемый код:  Семантический код легче читать и понимать, что упрощает разработку и поддержку сайта.\n•   Удобство сопровождения: Изменения в стилях не влияют на структуру, и наоборот.\n<pre><code appHighlight>\n<!DOCTYPE html>\n<html lang=\"ru\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Пример использования семантических тегов</title>\n</head>\n<body>\n\n  <header>\n    <h1>Мой блог</h1>\n    <nav>\n      <ul>\n        <li><a href=\"#\">Главная</a></li>\n        <li><a href=\"#\">Статьи</a></li>\n        <li><a href=\"#\">Обо мне</a></li>\n      </ul>\n    </nav>\n  </header>\n\n  <main>\n    <article>\n      <header>\n        <h2>Заголовок статьи</h2>\n        <p>Опубликовано: <time datetime=\"2023-10-27\">27 октября 2023</time> автором: <address><a href=\"mailto:me@example.com\">John Doe</a></address></p>\n      </header>\n\n      <section>\n        <h3>Раздел 1</h3>\n        <p>Текст раздела 1...</p>\n        <figure>\n          <img src=\"image.jpg\" alt=\"Описание изображения\">\n          <figcaption>Рисунок 1: Описание изображения</figcaption>\n        </figure>\n      </section>\n\n      <section>\n        <h3>Раздел 2</h3>\n        <p>Текст раздела 2...</p>\n        <p>Пример кода: <code>console.log(\"Hello, world!\");</code></p>\n      </section>\n\n      <footer>\n        <p>Категории: <a href=\"#\">HTML</a>, <a href=\"#\">Семантика</a></p>\n      </footer>\n    </article>\n\n    <aside>\n      <h3>Популярные статьи</h3>\n      <ul>\n        <li><a href=\"#\">Статья 1</a></li>\n        <li><a href=\"#\">Статья 2</a></li>\n        <li><a href=\"#\">Статья 3</a></li>\n      </ul>\n    </aside>\n  </main>\n\n  <footer>\n    <p>© 2023 Мой блог</p>\n  </footer>\n\n</body>\n</html>\n</code></pre>",
    "group": "HTML",
    "subGroup": "HTML теги",
    "ignoreHtml": true,
    "order": 3,
    "imageUrls": "",
    "_created": "2025-09-02T17:51:22.522Z",
    "_changed": "2025-10-05T18:27:20.791Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "семантические",
      "теги",
      "html",
      "это",
      "которые",
      "несут",
      "смысл",
      "структуре",
      "содержании",
      "документа",
      "помимо",
      "простого",
      "форматирования",
      "они",
      "помогают",
      "поисковым",
      "системам",
      "вспомогательным",
      "технологиям",
      "другим",
      "понимать",
      "вашего",
      "контента",
      "что",
      "приводит",
      "лучшей",
      "доступности",
      "seo",
      "общей",
      "вот",
      "полный",
      "список",
      "семантических",
      "тегов",
      "их",
      "описанием",
      "типичным",
      "использованием:",
      "структурные",
      "теги:",
      "представляет",
      "собой",
      "самостоятельный",
      "независимый",
      "элемент",
      "который",
      "может",
      "быть",
      "распространен",
      "независимо",
      "от",
      "остальной",
      "части",
      "страницы",
      "например",
      "статья",
      "блога",
      "новостная",
      "форумный",
      "пост",
      "содержать",
      "содержит",
      "контент",
      "относится",
      "окружающему",
      "контенту",
      "но",
      "не",
      "является",
      "его",
      "основной",
      "частью",
      "часто",
      "используется",
      "для",
      "боковых",
      "панелей",
      "рекламных",
      "блоков",
      "цитат",
      "дополнительной",
      "информации",
      "виджет",
      "из",
      "которого",
      "пользователь",
      "получить",
      "дополнительную",
      "информацию",
      "по",
      "запросу",
      "обычно",
      "скрытия",
      "отображения",
      "длинных",
      "разделов",
      "текста",
      "задаваемых",
      "вопросов",
      "внутри",
      "должен",
      "заголовок",
      "или",
      "описание",
      "элемента",
      "самодостаточный",
      "такой",
      "как",
      "изображение",
      "диаграмма",
      "иллюстрация",
      "код",
      "на",
      "ссылка",
      "основного",
      "можно",
      "переместить",
      "без",
      "ущерба",
      "понимания",
      "нижний",
      "колонтитул",
      "раздела",
      "всего",
      "об",
      "авторе",
      "авторских",
      "правах",
      "контактную",
      "ссылки",
      "связанные",
      "документы",
      "вводный",
      "логотип",
      "меню",
      "навигации",
      "основное",
      "содержимое",
      "документе",
      "только",
      "один",
      "должно",
      "повторяется",
      "других",
      "документах",
      "(например",
      "навигация",
      "баннеры)",
      "раздел",
      "содержащий",
      "навигационные",
      "все",
      "группы",
      "ссылок",
      "должны",
      "сайта",
      "тематический",
      "каждая",
      "имеет",
      "если",
      "тематическим",
      "лучше",
      "использовать",
      "определяет",
      "видимый",
      "щелчок",
      "переключает",
      "видимость",
      "текстовые",
      "аббревиатуру",
      "акроним",
      "атрибут",
      "title",
      "полное",
      "развернутое",
      "значение",
      "www",
      "автора",
      "владельца",
      "статьи",
      "название",
      "работы",
      "(книга",
      "песня",
      "цитирование",
      "фрагмент",
      "компьютерного",
      "кода",
      "моноширинный",
      "шрифт",
      "больших",
      "фрагментов",
      "рекомендуется",
      "связывает",
      "машиночитаемую",
      "форму",
      "данных",
      "со",
      "своим",
      "содержимым",
      "value",
      "определяющий",
      "экземпляр",
      "термина",
      "ближайший",
      "родительский",
      "определение",
      "акцент",
      "тексте",
      "отображается",
      "курсивом",
      "указывает",
      "логическое",
      "ударение",
      "текст",
      "альтернативном",
      "голосе",
      "настроении",
      "когда",
      "нет",
      "более",
      "подходящего",
      "семантического",
      "тега",
      "термины",
      "иностранном",
      "языке",
      "мысли",
      "названия",
      "кораблей",
      "предпочтительнее",
      "речь",
      "идет",
      "акценте",
      "выделенный",
      "справки",
      "аннотации",
      "предварительно",
      "отформатированный",
      "сохраняет",
      "пробелы",
      "переносы",
      "строк",
      "есть",
      "html-коде",
      "короткую",
      "встроенную",
      "цитату",
      "браузеры",
      "могут",
      "автоматически",
      "добавлять",
      "кавычки",
      "cite",
      "источник",
      "цитаты",
      "пример",
      "вывода",
      "компьютерной",
      "программы",
      "побочные",
      "комментарии",
      "мелкий",
      "важный",
      "полужирным",
      "шрифтом",
      "сильную",
      "важность",
      "индекс",
      "верхний",
      "определенное",
      "время",
      "дату",
      "datetime",
      "дату/время",
      "машиночитаемом",
      "формате",
      "переменную",
      "место",
      "где",
      "браузер",
      "разбить",
      "строку",
      "необходимо",
      "встраивания",
      "мультимедиа:",
      "встраивает",
      "аудиоконтент",
      "видеоконтент",
      "несколько",
      "источников",
      "мультимедиа",
      "элементов",
      "дорожки",
      "субтитры",
      "внешние",
      "приложения",
      "интерактивный",
      "flash)",
      "различные",
      "типы",
      "мультимедийного",
      "включая",
      "изображения",
      "аудио",
      "видео",
      "flash",
      "java-апплеты",
      "другие",
      "плагины",
      "диалоговое",
      "окно",
      "другое",
      "интерактивное",
      "предупреждения",
      "инспектор",
      "всякий",
      "раз",
      "вы",
      "описываете",
      "структуру",
      "визуальное",
      "отображение",
      "вместо",
      "использования",
      "везде",
      "возможно",
      "чтобы",
      "улучшить",
      "доступность",
      "преимущества",
      "тегов:",
      "(search",
      "engine",
      "optimization):",
      "поисковые",
      "системы",
      "понимают",
      "точно",
      "индексировать",
      "доступность:",
      "вспомогательные",
      "технологии",
      "экранные",
      "читалки)",
      "правильно",
      "интерпретировать",
      "предоставлять",
      "пользователям",
      "ограниченными",
      "возможностями",
      "поддержка",
      "разных",
      "устройств:",
      "позволяют",
      "браузерам",
      "отображать",
      "различных",
      "устройствах",
      "компьютеров",
      "до",
      "мобильных",
      "телефонов",
      "чистый",
      "читаемый",
      "код:",
      "семантический",
      "легче",
      "читать",
      "упрощает",
      "разработку",
      "поддержку",
      "удобство",
      "сопровождения:",
      "изменения",
      "стилях",
      "влияют",
      "наоборот",
      "мой",
      "блог",
      "главная",
      "обо",
      "мне",
      "опубликовано:",
      "27",
      "октября",
      "2023",
      "автором:",
      "john",
      "doe",
      "рисунок",
      "1:",
      "кода:",
      "console",
      "log(\"hello",
      "world!\");",
      "категории:",
      "семантика",
      "популярные"
    ],
    "_tags": "api семантические теги html это которые несут смысл структуре содержании документа помимо простого форматирования они помогают поисковым системам вспомогательным технологиям другим понимать вашего контента что приводит лучшей доступности seo общей вот полный список семантических тегов их описанием типичным использованием: структурные теги: представляет собой самостоятельный независимый элемент который может быть распространен независимо от остальной части страницы например статья блога новостная форумный пост содержать содержит контент относится окружающему контенту но не является его основной частью часто используется для боковых панелей рекламных блоков цитат дополнительной информации виджет из которого пользователь получить дополнительную информацию по запросу обычно скрытия отображения длинных разделов текста задаваемых вопросов внутри должен заголовок или описание элемента самодостаточный такой как изображение диаграмма иллюстрация код на ссылка основного можно переместить без ущерба понимания нижний колонтитул раздела всего об авторе авторских правах контактную ссылки связанные документы вводный логотип меню навигации основное содержимое документе только один должно повторяется других документах (например навигация баннеры) раздел содержащий навигационные все группы ссылок должны сайта тематический каждая имеет если тематическим лучше использовать определяет видимый щелчок переключает видимость текстовые аббревиатуру акроним атрибут title полное развернутое значение www автора владельца статьи название работы (книга песня цитирование фрагмент компьютерного кода моноширинный шрифт больших фрагментов рекомендуется связывает машиночитаемую форму данных со своим содержимым value определяющий экземпляр термина ближайший родительский определение акцент тексте отображается курсивом указывает логическое ударение текст альтернативном голосе настроении когда нет более подходящего семантического тега термины иностранном языке мысли названия кораблей предпочтительнее речь идет акценте выделенный справки аннотации предварительно отформатированный сохраняет пробелы переносы строк есть html-коде короткую встроенную цитату браузеры могут автоматически добавлять кавычки cite источник цитаты пример вывода компьютерной программы побочные комментарии мелкий важный полужирным шрифтом сильную важность индекс верхний определенное время дату datetime дату/время машиночитаемом формате переменную место где браузер разбить строку необходимо встраивания мультимедиа: встраивает аудиоконтент видеоконтент несколько источников мультимедиа элементов дорожки субтитры внешние приложения интерактивный flash) различные типы мультимедийного включая изображения аудио видео flash java-апплеты другие плагины диалоговое окно другое интерактивное предупреждения инспектор всякий раз вы описываете структуру визуальное отображение вместо использования везде возможно чтобы улучшить доступность преимущества тегов: (search engine optimization): поисковые системы понимают точно индексировать доступность: вспомогательные технологии экранные читалки) правильно интерпретировать предоставлять пользователям ограниченными возможностями поддержка разных устройств: позволяют браузерам отображать различных устройствах компьютеров до мобильных телефонов чистый читаемый код: семантический легче читать упрощает разработку поддержку удобство сопровождения: изменения стилях влияют наоборот мой блог главная обо мне опубликовано: 27 октября 2023 автором: john doe рисунок 1: кода: console log(\"hello world!\"); категории: семантика популярные",
    "_version": 5
  },
  {
    "_id": "68d82e970d20f72500014dce",
    "title": "Контекст функции",
    "content": "В TypeScript и JavaScript под контекстом функции понимается значение ключевого слова this, которое определяет объект, \"владеющий\" исполняемым кодом или вызвавший метод функции. Контекст меняется в зависимости от способа вызова функции, поэтому this может ссылаться на разные объекты, например, при вызове метода объекта, при использовании ключевого слова new, или при передаче функции как колбэка. \nКак определяется контекст (this)\nКонтекст функции определяется в момент её вызова, а не написания, и может быть разным:\nВызов метода объекта\n: this указывает на объект, у которого вызвали метод. \n<pre><code>typescript\nconst user = {\n  name: \"Алиса\",\n  sayHello() {\n    console.log(`Привет, ${this.name}`); // this ссылается на user\n  }\n};\nuser.sayHello(); // \"Привет, Алиса\"</code></pre>\nВызов с new\n: this ссылается на новый создаваемый объект, когда функция используется как конструктор. \ntypescript\n<pre><code>function Person(name: string) {\n  this.name = name; // this ссылается на новый объект Person\n}\nconst bob = new Person(\"Боб\");</code></pre>\nПотеря контекста\n: Если функция передается отдельно от объекта, this теряется и может стать undefined или указать на глобальный объект. \ntypescript\n<pre><code>const user = {\n  name: \"Вася\",\n  sayHi() {\n    setTimeout(function() {\n      alert(`Привет, ${this.name}`); // this здесь будет undefined\n    }, 1000);\n  }\n};\nuser.sayHi();</code></pre>\nЯвное связывание\n: Для управления this используются методы bind(), call(), и apply(). \nTypeScript и контекст\nХотя TypeScript добавляет статическую типизацию, он не меняет фундаментальные механизмы определения контекста, присущие JavaScript. В TS вы можете аннотировать this в типичной функции, что помогает избежать ошибок и делает код более понятным. \n\n<b>Стрелочные функции</b> не имеют собственного контекста this. Значение this внутри стрелочной функции берется из окружающего, ближайшего родительского контекста и не меняется на протяжении ее жизни. Это отличается от обычных функций, которые получают свой собственный this, зависящий от способа вызова функции. \nКак это работает:\nЛексическое связывание this:\nСтрелочные функции используют лексическое связывание, а не динамическое, как обычные функции. Это означает, что this внутри стрелочной функции всегда привязано к значению this в том месте, где эта стрелочная функция была объявлена. \nРешение проблем с this:\nЭто позволяет избежать распространенных проблем, связанных с переменным значением this в обычных функциях, которые могут привести к неожиданному поведению или ошибкам, особенно при работе с объектами и колбэками. \nПример:\ntypescript\n<pre><code>let person = {\n  name: \"Иван\",\n  sayMyName: function() {\n    console.log(`Привет, я ${this.name}.`); // this ссылается на person\n  },\n  sayMyNameArrow: () => {\n    // this здесь будет унаследован из глобальной области видимости (или ближайшего контекста)\n    // и не будет ссылаться на person.\n    // В зависимости от окружения, это может быть window (в браузере) или undefined.\n    console.log(`Я из стрелочной функции: ${this.name}.`);\n  }\n};\n\nperson.sayMyName(); // Выведет: Привет, я Иван.\nperson.sayMyNameArrow(); // Выведет: Я из стрелочной функции: undefined. (или другое значение, не Иван)\n</code></pre>\nВ этом примере person.sayMyName() работает правильно, потому что this внутри обычной функции sayMyName ссылается на объект person. Однако person.sayMyNameArrow() выведет undefined, так как this внутри стрелочной функции sayMyNameArrow не привязано к person. \n",
    "group": "JavaScript",
    "subGroup": "JavaScript Deep",
    "ignoreHtml": false,
    "order": 3,
    "_created": "2025-09-27T18:36:07.262Z",
    "_changed": "2025-10-13T17:29:06.275Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "контекст",
      "функции",
      "typescript",
      "javascript",
      "под",
      "контекстом",
      "понимается",
      "значение",
      "ключевого",
      "слова",
      "this",
      "которое",
      "определяет",
      "объект",
      "\"владеющий\"",
      "исполняемым",
      "кодом",
      "или",
      "вызвавший",
      "метод",
      "меняется",
      "зависимости",
      "от",
      "способа",
      "вызова",
      "поэтому",
      "может",
      "ссылаться",
      "на",
      "разные",
      "объекты",
      "например",
      "при",
      "вызове",
      "метода",
      "объекта",
      "использовании",
      "new",
      "передаче",
      "как",
      "колбэка",
      "определяется",
      "(this)",
      "момент",
      "её",
      "не",
      "написания",
      "быть",
      "разным:",
      "вызов",
      "указывает",
      "которого",
      "вызвали",
      "const",
      "user",
      "name:",
      "\"алиса\"",
      "sayhello()",
      "console",
      "log(`привет",
      "${this",
      "name}`);",
      "//",
      "ссылается",
      "};",
      "sayhello();",
      "\"привет",
      "алиса\"",
      "новый",
      "создаваемый",
      "когда",
      "функция",
      "используется",
      "конструктор",
      "function",
      "person(name:",
      "string)",
      "name",
      "name;",
      "person",
      "bob",
      "person(\"боб\");",
      "потеря",
      "контекста",
      "если",
      "передается",
      "отдельно",
      "теряется",
      "стать",
      "указать",
      "глобальный",
      "\"вася\"",
      "sayhi()",
      "settimeout(function()",
      "alert(`привет",
      "здесь",
      "будет",
      "1000);",
      "sayhi();",
      "явное",
      "связывание",
      "для",
      "управления",
      "используются",
      "методы",
      "bind()",
      "call()",
      "apply()",
      "хотя",
      "добавляет",
      "статическую",
      "типизацию",
      "он",
      "меняет",
      "фундаментальные",
      "механизмы",
      "определения",
      "присущие",
      "ts",
      "вы",
      "можете",
      "аннотировать",
      "типичной",
      "что",
      "помогает",
      "избежать",
      "ошибок",
      "делает",
      "код",
      "более",
      "понятным",
      "стрелочные",
      "имеют",
      "собственного",
      "внутри",
      "стрелочной",
      "берется",
      "из",
      "окружающего",
      "ближайшего",
      "родительского",
      "протяжении",
      "ее",
      "жизни",
      "это",
      "отличается",
      "обычных",
      "функций",
      "которые",
      "получают",
      "свой",
      "собственный",
      "зависящий",
      "работает:",
      "лексическое",
      "this:",
      "используют",
      "динамическое",
      "обычные",
      "означает",
      "всегда",
      "привязано",
      "значению",
      "том",
      "месте",
      "где",
      "эта",
      "стрелочная",
      "была",
      "объявлена",
      "решение",
      "проблем",
      "позволяет",
      "распространенных",
      "связанных",
      "переменным",
      "значением",
      "функциях",
      "могут",
      "привести",
      "неожиданному",
      "поведению",
      "ошибкам",
      "особенно",
      "работе",
      "объектами",
      "колбэками",
      "пример:",
      "let",
      "\"иван\"",
      "saymyname:",
      "function()",
      "name}",
      "`);",
      "saymynamearrow:",
      "()",
      "=>",
      "унаследован",
      "глобальной",
      "области",
      "видимости",
      "(или",
      "контекста)",
      "окружения",
      "window",
      "(в",
      "браузере)",
      "log(`я",
      "функции:",
      "saymyname();",
      "выведет:",
      "привет",
      "иван",
      "saymynamearrow();",
      "другое",
      "иван)",
      "этом",
      "примере",
      "saymyname()",
      "работает",
      "правильно",
      "потому",
      "обычной",
      "saymyname",
      "однако",
      "saymynamearrow()",
      "выведет",
      "так",
      "saymynamearrow",
      "deep"
    ],
    "_tags": "api контекст функции typescript javascript под контекстом понимается значение ключевого слова this которое определяет объект \"владеющий\" исполняемым кодом или вызвавший метод меняется зависимости от способа вызова поэтому может ссылаться на разные объекты например при вызове метода объекта использовании new передаче как колбэка определяется (this) момент её не написания быть разным: вызов указывает которого вызвали const user name: \"алиса\" sayhello() console log(`привет ${this name}`); // ссылается }; sayhello(); \"привет алиса\" новый создаваемый когда функция используется конструктор function person(name: string) name name; person bob person(\"боб\"); потеря контекста если передается отдельно теряется стать указать глобальный \"вася\" sayhi() settimeout(function() alert(`привет здесь будет 1000); sayhi(); явное связывание для управления используются методы bind() call() apply() хотя добавляет статическую типизацию он меняет фундаментальные механизмы определения присущие ts вы можете аннотировать типичной что помогает избежать ошибок делает код более понятным стрелочные имеют собственного внутри стрелочной берется из окружающего ближайшего родительского протяжении ее жизни это отличается обычных функций которые получают свой собственный зависящий работает: лексическое this: используют динамическое обычные означает всегда привязано значению том месте где эта стрелочная была объявлена решение проблем позволяет распространенных связанных переменным значением функциях могут привести неожиданному поведению ошибкам особенно работе объектами колбэками пример: let \"иван\" saymyname: function() name} `); saymynamearrow: () => унаследован глобальной области видимости (или контекста) окружения window (в браузере) log(`я функции: saymyname(); выведет: привет иван saymynamearrow(); другое иван) этом примере saymyname() работает правильно потому обычной saymyname однако saymynamearrow() выведет так saymynamearrow deep",
    "_version": 1
  },
  {
    "_id": "68f7d56a0d20f7250003c8ab",
    "title": "Как браузер рисует страницы",
    "content": "Кратко\nЧтобы нарисовать на экране результат работы нашего кода, браузеру нужно выполнить несколько этапов:\n\nСперва ему нужно скачать исходники.\nЗатем их нужно прочитать и распарсить.\nПосле этого браузер приступает к рендерингу — отрисовке.\nКаждый из процессов очень сложен, и мы не будем рассматривать их до мельчайших подробностей.\n\n<b>Получение ресурсов, Fetching</b>\nРесурсы браузер получает с помощью запросов к серверу. В ответ он может получить как, например, данные в виде JSON, так и картинки, видео, файлы стилей и скриптов.\n\nСамый первый запрос к серверу — обычно запрос на получение HTML-страницы (чаще всего index.html).\n\nВ её коде содержатся ссылки на другие ресурсы, которые браузер тоже запросит у сервера:\n<pre><code><.!DOCTYPE html>\n<.html lang=\"en\">\n  <.head>\n    <.link href=\"/style.css\" rel=\"stylesheet\">\n    <.title>Document</title>\n  <./head>\n  <.body>\n    <.img src=\"/hello.jpg\" alt=\"Привет!\">\n    <.script src=\"/index.js\"></script>\n  <./body>\n<./html></code></pre>\nВ примере выше браузер запросит также:\n\nфайл стилей style.css;\nизображение hello.jpg;\nи скрипт index.js.\n\n<b>Парсинг, Parsing </b>\nПо мере того как скачивается HTML-страница, браузер пытается её «прочитать» — распарсить.\n\nDOM Скопировать ссылку \"DOM\"\nБраузер работает не с текстом разметки, а с абстракциями над ним. Одна из таких абстракций, результат парсинга HTML-кода, называется DOM.\n\nDOM (Document Object Model) — абстрактное представление HTML-документа, с помощью которого браузер может получать доступ к его элементам, изменять его структуру и оформление.\n\nDOM — это дерево. Корень этого дерева — это элемент HTML, все остальные элементы — это дочерние узлы.\n\nДля такого документа:\n<pre><code><.html>\n  <.head>\n    <.meta charset=\"utf-8\">\n    <.title>Hello</title>\n  <./head>\n  <.body>\n    <.p class=\"text\">Hello world</p>\n    <.img src=\"/hello.jpg\" alt=\"Привет!\">\n  <./body>\n<./html></code></pre>\n...получится такое дерево:\n <p><img src=\"https://doka.guide/tools/how-the-browser-creates-pages/images/DOM-2200w.webp\" alt=\"В\" style=\"max-width: 100%;\"></p> \nПока браузер парсит документ и строит DOM, он натыкается на элементы типа <img>, <link>, <script>, которые содержат ссылки на другие ресурсы.\n\nЕсли ресурс неблокирующий (например, изображение), браузер запрашивает его параллельно с парсингом оставшейся части документа. Блокирующие ресурсы (например, скрипты) приостанавливают обработку до своей полной загрузки.\n\nМы можем указывать браузеру, как именно ему следует запрашивать некоторые ресурсы, например, скрипты. Это может быть полезно, когда в скрипте мы собираемся работать с элементами, которые находятся в разметке после тега <script>:\n\n// script.js\n<pre><code>const image = document.getElementById('image')</code></pre>\n<pre><code><.body>\n  <.script src=\"script.js\"></script>\n  <.img src=\"/hello.jpg\" alt=\"Hello world\" id=\"image\">\n<./body></code></pre>\nВ этом случае image === undefined, потому что браузер успел распарсить только часть документа до этого тега <script>.\n\nА в этом всё в порядке, изображение найдётся:\n<pre><code><.body>\n  <.img src=\"/hello.jpg\" alt=\"Hello world\" id=\"image\">\n  <.script src=\"script.js\"></script>\n<./body></code></pre>\n\nИ в этом тоже порядок, атрибут defer скажет браузеру продолжать парсить страницу и выполнить скрипт потом:\n\n<pre><code><.body>\n  <.script src=\"script.js\" defer></script>\n  <.img src=\"/hello.jpg\" alt=\"Hello world\" id=\"image\">\n<./body></code></pre>\nCSSOM Скопировать ссылку \"CSSOM\"\nКогда браузер находит элемент <link>, который указывает на файл стилей, браузер скачивает и парсит его. Результат парсинга CSS-кода — CSSOM.\n\nCSSOM (CSS Object Model) — по аналогии с DOM, представление стилевых правил в виде дерева.\n\nДля документа выше с такими стилями:\n<pre><code>body {\n  font-size: 1.5rem;\n}\n\n.text {\n  color: red;\n}\n\nimg {\n  max-width: 100%;\n}</code></pre>\n...получим такое дерево:\n <p><img src=\"https://doka.guide/tools/how-the-browser-creates-pages/images/CSSOM-2200w.webp\" alt=\"В\" style=\"max-width: 100%;\"></p>\nЧтение стилей приостанавливает чтение кода страницы. Поэтому рекомендуется в самом начале отдавать только критичные стили — которые есть на всех страницах и конкретно на этой. Так мы уменьшаем время ожидания, пока «страница загрузится».\n📝\nБлагодаря оптимизациям (например, сканеру предзагрузки) стили могут не блокировать чтение HTML, но они точно блокируют выполнение JavaScript, потому что в JS могут использоваться CSS-селекторы для выборки элементов.\n\n<b>Render Tree </b>\nПосле того как браузер составил DOM и CSSOM, он объединяет их в общее дерево рендеринга — Render Tree.\n\nRender Tree — это термин, который используется движком WebKit, в других движках он может отличаться. Например, Gecko использует термин Frame Tree.\n\nВ итоге для нашего документа выше мы получим такое дерево: \n <p><img src=\"https://doka.guide/tools/how-the-browser-creates-pages/images/render-tree-2200w.webp\" alt=\"В\" style=\"max-width: 100%;\"></p> \nОбратите внимание, что в Render tree попадают только видимые элементы. Если бы у нас был элемент, спрятанный через display: none, он бы в это дерево не попал. Об этом подробнее мы ещё поговорим дальше.\n\nОбщая схема парсинга выглядит вот так:\n <p><img src=\"https://doka.guide/tools/how-the-browser-creates-pages/images/1-1800w.webp\" alt=\"В\" style=\"max-width: 100%;\"></p> \nНа первых шагах мы разбираемся с HTML и CSS, а затем объединяем их в Render Tree.\n\n<b>Вычисление позиции и размеров, Layout</b>\nПосле того как у браузера появилось дерево рендеринга (Render Tree), он начинает «расставлять» элементы на странице. Этот процесс называется Layout.\n\nЧтобы понимать, где какой элемент должен находиться и как он влияет на расположение других элементов, браузер рассчитывает размеры и положение каждого рекурсивно.\n\nРасчёт начинается от корневого элемента дерева рендеринга, его размеры равны размеру вьюпорта. Далее браузер переходит поочерёдно к каждому из дочерних элементов.\n\nВажно помнить, что Layout построен на поточной модели компоновки. Это значит, что если элементы не влияют на расположение и размеры других элементов, то их положение и размеры можно просчитать за один подход.\n\nИменно поэтому при вёрстке макетов рекомендуется «находиться в потоке» — чтобы браузеру не приходилось несколько раз пересчитывать один и тот же элемент, так страница отрисовывается быстрее.\n\nГлобальный и инкрементальный Layout Скопировать ссылку \"Глобальный и инкрементальный Layout\"\nГлобальный Layout — это процесс просчёта всего дерева полностью, то есть каждого элемента. Инкрементальный — просчитывает только часть.\n\nГлобальный Layout запускается, например, при изменении размера окна, потому что браузеру требуется подогнать всю страницу под новый размер экрана. Это очень дорогой процесс.\n\nИнкрементальный Layout запускает пересчёт только «грязных» элементов.\n\n«Грязные» элементы Скопировать ссылку \"«Грязные» элементы\"\nЭто те элементы, которые были изменены, и их дочерние элементы.\n\nЕсли мы как-то поменяли блок, то браузер перерисует его и его детей, потому что их положение и размеры могут зависеть от родителя.\n <p><img src=\"https://doka.guide/tools/how-the-browser-creates-pages/images/2-1784w.webp\" alt=\"В\" style=\"max-width: 100%;\"></p> \nДальше браузер приступает к, собственно, отрисовке.\n\n<b>Непосредственно отрисовка, Paint</b>\nВо время отрисовки (Paint) браузер наполняет пиксели на экране нужными цветами в зависимости от того, что в конкретном месте должно быть нарисовано: текст, изображение, цвет фона, тени, рамки и т. д.\n\nОтрисовка тоже бывает глобальной и инкрементальной. Чтобы понять, какую часть вьюпорта надо перерисовать, браузер делит весь вьюпорт на прямоугольные участки. Логика тут та же, как и в Layout — если изменения ограничены одним участком, то пометится «грязным» и перерисуется лишь он.\n\nОтрисовка — это самый дорогой процесс из всех, что мы уже перечислили.\n\nПорядок отрисовки Скопировать ссылку \"Порядок отрисовки\"\nПорядок отрисовки связан со стековым контекстом.\n\nВ общих чертах, отрисовка начинается с заднего плана и постепенно переходит к переднему:\n\nbackground-color;\nbackground-image;\nborder;\nchildren;\noutline.\nCPU и композитинг Скопировать ссылку \"CPU и композитинг\"\nИ Layout, и Paint работают за счёт CPU (central process unit), поэтому относительно медленные. Плавные анимации при таком раскладе невероятно дорогие.\n\nДля плавных анимаций в браузерах предусмотрен композитинг (Compositing).\n\nКомпозитинг — это разделение содержимого страницы на «слои», которые браузер будет перерисовывать. Эти слои друг от друга не зависят, из-за чего изменение элемента в одном слое не затрагивает элементы из других слоёв, и перерисовывать их становится не нужно.\n\nИменно из-за разнесения элементов по разным композиционным слоям свойство transform не так сильно нагружает браузер. Поэтому чтобы анимации не тормозили, их рекомендуется делать с применением transform и opacity.\n <p><img src=\"https://doka.guide/tools/how-the-browser-creates-pages/images/3-1800w.webp\" alt=\"В\" style=\"max-width: 100%;\"></p> \nПрименение таких свойств, как, например, transform, «выносит» элемент на отдельный композитный слой, где положение элемента не зависит от других и не влияет на них.\n\n📝\nЧтобы узнать, вызывает ли конкретное CSS-свойство композитинг и перерисовку в браузере, воспользуйтесь инструментом «CSS Triggers».\n\n<b>Перерисовка, Reflow (relayout) и Repaint</b>\nПроцесс отрисовки — циклический. Браузер перерисовывает экран каждый раз, когда на странице происходят какие-то изменения.\n\nЕсли, например, в DOM-дереве добавился новый узел, или изменился текст, то браузер построит новое дерево рендеринга и запустит вычисление позиции и отрисовку заново.\n\nОдин цикл обновления — это animation frame.\n\nЗная «расписание отрисовки» браузера, мы можем «предупредить» его, что хотим запустить какую-то анимацию на каждый новый фрейм. Это можно сделать с помощью requestAnimationFrame().\n\n<pre><code>const animate = () => {\n  // Код анимации\n}</code></pre>\n\nСкопировать\nЭта функция запускает новый кадр анимации: обновляет какое-то свойство или перерисовывает canvas.\n\nЕсли мы хотим добиться плавной анимации, используя функцию выше, мы должны обеспечить в среднем 60 обновлений экрана за секунду (60 fps — frames per second).\n\nЭто можно сделать топорно, через интервал:\n\n<pre><code>// 60 раз в 1000 миллисекунд, приблизительно 16 мс.\nconst intervalMS = 1000 / 60\nsetInterval(animate, intervalMS)\n</code></pre>\nЛибо использовать window.requestAnimationFrame():\n<pre><code>window.requestAnimationFrame(animate)</code></pre>\n\nИнтервалы не всегда запускаются в нужный момент. setInterval() не учитывает, на какой стадии отрисовки находится страница, и в итоге кадры отрисовки могут быть рваными или дёрганными.\n\nС интервалом анимация может быть рваной, потому что перерисовка может быть запущена в неподходящее время.\n\nА если вкладка была неактивна, то интервал может «попытаться догнать время», и несколько кадров запустятся разом:\n <p><img src=\"https://doka.guide/tools/how-the-browser-creates-pages/images/reflow-2200w.webp\" alt=\"В\" style=\"max-width: 100%;\"></p> \nС requestAnimationFrame() анимация плавнее, потому что браузер знает, что в следующем фрейме надо запустить новый кадр анимации.\n\nОна не гарантирует, что анимация будет запущена строго раз в 16 мс, но значение будет достаточно близким.\n <p><img src=\"https://doka.guide/tools/how-the-browser-creates-pages/images/reflow-2-2200w.webp\" alt=\"В\" style=\"max-width: 100%;\"></p> \n\n",
    "group": "Браузер",
    "subGroup": "Basic",
    "ignoreHtml": false,
    "order": 2,
    "_created": "2025-10-21T18:48:10.463Z",
    "_changed": "2025-10-21T18:48:10.463Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "как",
      "браузер",
      "рисует",
      "страницы",
      "кратко",
      "чтобы",
      "нарисовать",
      "на",
      "экране",
      "результат",
      "работы",
      "нашего",
      "кода",
      "браузеру",
      "нужно",
      "выполнить",
      "несколько",
      "этапов:",
      "сперва",
      "ему",
      "скачать",
      "исходники",
      "затем",
      "их",
      "прочитать",
      "распарсить",
      "после",
      "этого",
      "приступает",
      "рендерингу",
      "отрисовке",
      "каждый",
      "из",
      "процессов",
      "очень",
      "сложен",
      "мы",
      "не",
      "будем",
      "рассматривать",
      "до",
      "мельчайших",
      "подробностей",
      "получение",
      "ресурсов",
      "fetching",
      "ресурсы",
      "получает",
      "помощью",
      "запросов",
      "серверу",
      "ответ",
      "он",
      "может",
      "получить",
      "например",
      "данные",
      "виде",
      "json",
      "так",
      "картинки",
      "видео",
      "файлы",
      "стилей",
      "скриптов",
      "самый",
      "первый",
      "запрос",
      "обычно",
      "html-страницы",
      "(чаще",
      "всего",
      "index",
      "html)",
      "её",
      "коде",
      "содержатся",
      "ссылки",
      "другие",
      "которые",
      "тоже",
      "запросит",
      "сервера:",
      "document",
      "примере",
      "выше",
      "также:",
      "файл",
      "style",
      "css;",
      "изображение",
      "hello",
      "jpg;",
      "скрипт",
      "js",
      "парсинг",
      "parsing",
      "по",
      "мере",
      "того",
      "скачивается",
      "html-страница",
      "пытается",
      "«прочитать»",
      "dom",
      "скопировать",
      "ссылку",
      "\"dom\"",
      "работает",
      "текстом",
      "разметки",
      "абстракциями",
      "над",
      "ним",
      "одна",
      "таких",
      "абстракций",
      "парсинга",
      "html-кода",
      "называется",
      "(document",
      "object",
      "model)",
      "абстрактное",
      "представление",
      "html-документа",
      "которого",
      "получать",
      "доступ",
      "его",
      "элементам",
      "изменять",
      "структуру",
      "оформление",
      "это",
      "дерево",
      "корень",
      "дерева",
      "элемент",
      "html",
      "все",
      "остальные",
      "элементы",
      "дочерние",
      "узлы",
      "для",
      "такого",
      "документа:",
      "world",
      "получится",
      "такое",
      "дерево:",
      "пока",
      "парсит",
      "документ",
      "строит",
      "натыкается",
      "типа",
      "содержат",
      "если",
      "ресурс",
      "неблокирующий",
      "(например",
      "изображение)",
      "запрашивает",
      "параллельно",
      "парсингом",
      "оставшейся",
      "части",
      "документа",
      "блокирующие",
      "скрипты)",
      "приостанавливают",
      "обработку",
      "своей",
      "полной",
      "загрузки",
      "можем",
      "указывать",
      "именно",
      "следует",
      "запрашивать",
      "некоторые",
      "скрипты",
      "быть",
      "полезно",
      "когда",
      "скрипте",
      "собираемся",
      "работать",
      "элементами",
      "находятся",
      "разметке",
      "тега",
      "<script>:",
      "//",
      "script",
      "<pre><code>const",
      "image",
      "getelementbyid('image')</code></pre>",
      "<pre><code><",
      "body>",
      "src=\"script",
      "js\">",
      "этом",
      "случае",
      "===",
      "потому",
      "что",
      "успел",
      "только",
      "часть",
      "всё",
      "порядке",
      "найдётся:",
      "img",
      "src=\"/hello",
      "jpg\"",
      "alt=\"hello",
      "world\"",
      "id=\"image\">",
      "порядок",
      "атрибут",
      "defer",
      "скажет",
      "продолжать",
      "парсить",
      "страницу",
      "потом:",
      "cssom",
      "\"cssom\"",
      "находит",
      "который",
      "указывает",
      "скачивает",
      "css-кода",
      "(css",
      "аналогии",
      "стилевых",
      "правил",
      "такими",
      "стилями:",
      "body",
      "font-size:",
      "5rem;",
      "text",
      "color:",
      "red;",
      "max-width:",
      "100%;",
      "получим",
      "чтение",
      "приостанавливает",
      "поэтому",
      "рекомендуется",
      "самом",
      "начале",
      "отдавать",
      "критичные",
      "стили",
      "есть",
      "всех",
      "страницах",
      "конкретно",
      "этой",
      "уменьшаем",
      "время",
      "ожидания",
      "«страница",
      "загрузится»",
      "📝",
      "благодаря",
      "оптимизациям",
      "сканеру",
      "предзагрузки)",
      "могут",
      "блокировать",
      "но",
      "они",
      "точно",
      "блокируют",
      "выполнение",
      "javascript",
      "использоваться",
      "css-селекторы",
      "выборки",
      "элементов",
      "render",
      "tree",
      "составил",
      "объединяет",
      "общее",
      "рендеринга",
      "термин",
      "используется",
      "движком",
      "webkit",
      "других",
      "движках",
      "отличаться",
      "gecko",
      "использует",
      "frame",
      "итоге",
      "обратите",
      "внимание",
      "попадают",
      "видимые",
      "бы",
      "нас",
      "был",
      "спрятанный",
      "через",
      "display:",
      "none",
      "попал",
      "об",
      "подробнее",
      "ещё",
      "поговорим",
      "дальше",
      "общая",
      "схема",
      "выглядит",
      "вот",
      "так:",
      "первых",
      "шагах",
      "разбираемся",
      "css",
      "объединяем",
      "вычисление",
      "позиции",
      "размеров",
      "layout",
      "браузера",
      "появилось",
      "(render",
      "tree)",
      "начинает",
      "«расставлять»",
      "странице",
      "этот",
      "процесс",
      "понимать",
      "где",
      "какой",
      "должен",
      "находиться",
      "влияет",
      "расположение",
      "рассчитывает",
      "размеры",
      "положение",
      "каждого",
      "рекурсивно",
      "расчёт",
      "начинается",
      "от",
      "корневого",
      "элемента",
      "равны",
      "размеру",
      "вьюпорта",
      "далее",
      "переходит",
      "поочерёдно",
      "каждому",
      "дочерних",
      "важно",
      "помнить",
      "построен",
      "поточной",
      "модели",
      "компоновки",
      "значит",
      "влияют",
      "то",
      "можно",
      "просчитать",
      "за",
      "один",
      "подход",
      "при",
      "вёрстке",
      "макетов",
      "«находиться",
      "потоке»",
      "приходилось",
      "раз",
      "пересчитывать",
      "тот",
      "же",
      "страница",
      "отрисовывается",
      "быстрее",
      "глобальный",
      "инкрементальный",
      "\"глобальный",
      "layout\"",
      "просчёта",
      "полностью",
      "просчитывает",
      "запускается",
      "изменении",
      "размера",
      "окна",
      "требуется",
      "подогнать",
      "всю",
      "под",
      "новый",
      "размер",
      "экрана",
      "дорогой",
      "запускает",
      "пересчёт",
      "«грязных»",
      "«грязные»",
      "\"«грязные»",
      "элементы\"",
      "те",
      "были",
      "изменены",
      "как-то",
      "поменяли",
      "блок",
      "перерисует",
      "детей",
      "зависеть",
      "родителя",
      "собственно",
      "непосредственно",
      "отрисовка",
      "paint",
      "во",
      "отрисовки",
      "(paint)",
      "наполняет",
      "пиксели",
      "нужными",
      "цветами",
      "зависимости",
      "конкретном",
      "месте",
      "должно",
      "нарисовано:",
      "текст",
      "цвет",
      "фона",
      "тени",
      "рамки",
      "бывает",
      "глобальной",
      "инкрементальной",
      "понять",
      "какую",
      "надо",
      "перерисовать",
      "делит",
      "весь",
      "вьюпорт",
      "прямоугольные",
      "участки",
      "логика",
      "тут",
      "та",
      "изменения",
      "ограничены",
      "одним",
      "участком",
      "пометится",
      "«грязным»",
      "перерисуется",
      "лишь",
      "уже",
      "перечислили",
      "\"порядок",
      "отрисовки\"",
      "связан",
      "со",
      "стековым",
      "контекстом",
      "общих",
      "чертах",
      "заднего",
      "плана",
      "постепенно",
      "переднему:",
      "background-color;",
      "background-image;",
      "border;",
      "children;",
      "outline",
      "cpu",
      "композитинг",
      "\"cpu",
      "композитинг\"",
      "работают",
      "счёт",
      "(central",
      "process",
      "unit)",
      "относительно",
      "медленные",
      "плавные",
      "анимации",
      "таком",
      "раскладе",
      "невероятно",
      "дорогие",
      "плавных",
      "анимаций",
      "браузерах",
      "предусмотрен",
      "(compositing)",
      "разделение",
      "содержимого",
      "«слои»",
      "будет",
      "перерисовывать",
      "эти",
      "слои",
      "друг",
      "друга",
      "зависят",
      "из-за",
      "чего",
      "изменение",
      "одном",
      "слое",
      "затрагивает",
      "слоёв",
      "становится",
      "разнесения",
      "разным",
      "композиционным",
      "слоям",
      "свойство",
      "transform",
      "сильно",
      "нагружает",
      "тормозили",
      "делать",
      "применением",
      "opacity",
      "применение",
      "свойств",
      "«выносит»",
      "отдельный",
      "композитный",
      "слой",
      "зависит",
      "них",
      "узнать",
      "вызывает",
      "ли",
      "конкретное",
      "css-свойство",
      "перерисовку",
      "браузере",
      "воспользуйтесь",
      "инструментом",
      "«css",
      "triggers»",
      "перерисовка",
      "reflow",
      "(relayout)",
      "repaint",
      "циклический",
      "перерисовывает",
      "экран",
      "происходят",
      "какие-то",
      "dom-дереве",
      "добавился",
      "узел",
      "или",
      "изменился",
      "построит",
      "новое",
      "запустит",
      "отрисовку",
      "заново",
      "цикл",
      "обновления",
      "animation",
      "зная",
      "«расписание",
      "отрисовки»",
      "«предупредить»",
      "хотим",
      "запустить",
      "какую-то",
      "анимацию",
      "фрейм",
      "сделать",
      "requestanimationframe()",
      "const",
      "animate",
      "()",
      "=>",
      "код",
      "эта",
      "функция",
      "кадр",
      "анимации:",
      "обновляет",
      "какое-то",
      "canvas",
      "добиться",
      "плавной",
      "используя",
      "функцию",
      "должны",
      "обеспечить",
      "среднем",
      "60",
      "обновлений",
      "секунду",
      "(60",
      "fps",
      "frames",
      "per",
      "second)",
      "топорно",
      "интервал:",
      "1000",
      "миллисекунд",
      "приблизительно",
      "16",
      "мс",
      "intervalms",
      "setinterval(animate",
      "intervalms)",
      "либо",
      "использовать",
      "window",
      "requestanimationframe():",
      "requestanimationframe(animate)",
      "интервалы",
      "всегда",
      "запускаются",
      "нужный",
      "момент",
      "setinterval()",
      "учитывает",
      "стадии",
      "находится",
      "кадры",
      "рваными",
      "дёрганными",
      "интервалом",
      "анимация",
      "рваной",
      "запущена",
      "неподходящее",
      "вкладка",
      "была",
      "неактивна",
      "интервал",
      "«попытаться",
      "догнать",
      "время»",
      "кадров",
      "запустятся",
      "разом:",
      "плавнее",
      "знает",
      "следующем",
      "фрейме",
      "она",
      "гарантирует",
      "строго",
      "значение",
      "достаточно",
      "близким",
      "basic"
    ],
    "_tags": "api как браузер рисует страницы кратко чтобы нарисовать на экране результат работы нашего кода браузеру нужно выполнить несколько этапов: сперва ему скачать исходники затем их прочитать распарсить после этого приступает рендерингу отрисовке каждый из процессов очень сложен мы не будем рассматривать до мельчайших подробностей получение ресурсов fetching ресурсы получает помощью запросов серверу ответ он может получить например данные виде json так картинки видео файлы стилей скриптов самый первый запрос обычно html-страницы (чаще всего index html) её коде содержатся ссылки другие которые тоже запросит сервера: document примере выше также: файл style css; изображение hello jpg; скрипт js парсинг parsing по мере того скачивается html-страница пытается «прочитать» dom скопировать ссылку \"dom\" работает текстом разметки абстракциями над ним одна таких абстракций парсинга html-кода называется (document object model) абстрактное представление html-документа которого получать доступ его элементам изменять структуру оформление это дерево корень дерева элемент html все остальные элементы дочерние узлы для такого документа: world получится такое дерево: пока парсит документ строит натыкается типа содержат если ресурс неблокирующий (например изображение) запрашивает параллельно парсингом оставшейся части документа блокирующие скрипты) приостанавливают обработку своей полной загрузки можем указывать именно следует запрашивать некоторые скрипты быть полезно когда скрипте собираемся работать элементами находятся разметке тега <script>: // script <pre><code>const image getelementbyid('image')</code></pre> <pre><code>< body> src=\"script js\"> этом случае === потому что успел только часть всё порядке найдётся: img src=\"/hello jpg\" alt=\"hello world\" id=\"image\"> порядок атрибут defer скажет продолжать парсить страницу потом: cssom \"cssom\" находит который указывает скачивает css-кода (css аналогии стилевых правил такими стилями: body font-size: 5rem; text color: red; max-width: 100%; получим чтение приостанавливает поэтому рекомендуется самом начале отдавать критичные стили есть всех страницах конкретно этой уменьшаем время ожидания «страница загрузится» 📝 благодаря оптимизациям сканеру предзагрузки) могут блокировать но они точно блокируют выполнение javascript использоваться css-селекторы выборки элементов render tree составил объединяет общее рендеринга термин используется движком webkit других движках отличаться gecko использует frame итоге обратите внимание попадают видимые бы нас был спрятанный через display: none попал об подробнее ещё поговорим дальше общая схема выглядит вот так: первых шагах разбираемся css объединяем вычисление позиции размеров layout браузера появилось (render tree) начинает «расставлять» странице этот процесс понимать где какой должен находиться влияет расположение рассчитывает размеры положение каждого рекурсивно расчёт начинается от корневого элемента равны размеру вьюпорта далее переходит поочерёдно каждому дочерних важно помнить построен поточной модели компоновки значит влияют то можно просчитать за один подход при вёрстке макетов «находиться потоке» приходилось раз пересчитывать тот же страница отрисовывается быстрее глобальный инкрементальный \"глобальный layout\" просчёта полностью просчитывает запускается изменении размера окна требуется подогнать всю под новый размер экрана дорогой запускает пересчёт «грязных» «грязные» \"«грязные» элементы\" те были изменены как-то поменяли блок перерисует детей зависеть родителя собственно непосредственно отрисовка paint во отрисовки (paint) наполняет пиксели нужными цветами зависимости конкретном месте должно нарисовано: текст цвет фона тени рамки бывает глобальной инкрементальной понять какую надо перерисовать делит весь вьюпорт прямоугольные участки логика тут та изменения ограничены одним участком пометится «грязным» перерисуется лишь уже перечислили \"порядок отрисовки\" связан со стековым контекстом общих чертах заднего плана постепенно переднему: background-color; background-image; border; children; outline cpu композитинг \"cpu композитинг\" работают счёт (central process unit) относительно медленные плавные анимации таком раскладе невероятно дорогие плавных анимаций браузерах предусмотрен (compositing) разделение содержимого «слои» будет перерисовывать эти слои друг друга зависят из-за чего изменение одном слое затрагивает слоёв становится разнесения разным композиционным слоям свойство transform сильно нагружает тормозили делать применением opacity применение свойств «выносит» отдельный композитный слой зависит них узнать вызывает ли конкретное css-свойство перерисовку браузере воспользуйтесь инструментом «css triggers» перерисовка reflow (relayout) repaint циклический перерисовывает экран происходят какие-то dom-дереве добавился узел или изменился построит новое запустит отрисовку заново цикл обновления animation зная «расписание отрисовки» «предупредить» хотим запустить какую-то анимацию фрейм сделать requestanimationframe() const animate () => код эта функция кадр анимации: обновляет какое-то canvas добиться плавной используя функцию должны обеспечить среднем 60 обновлений секунду (60 fps frames per second) топорно интервал: 1000 миллисекунд приблизительно 16 мс intervalms setinterval(animate intervalms) либо использовать window requestanimationframe(): requestanimationframe(animate) интервалы всегда запускаются нужный момент setinterval() учитывает стадии находится кадры рваными дёрганными интервалом анимация рваной запущена неподходящее вкладка была неактивна интервал «попытаться догнать время» кадров запустятся разом: плавнее знает следующем фрейме она гарантирует строго значение достаточно близким basic",
    "_version": 0
  },
  {
    "_id": "68f8e6ca0d20f7250003ddd2",
    "title": "Nginx + Minio",
    "content": "## Nginx простыми словами\n\nПредставь, что Nginx - это официант в ресторане (который называется твой сервер).\n\n• Клиент (пользователь) приходит в ресторан (твой сайт) и хочет получить определенное блюдо (статический ресурс, например, картинку или файл HTML).\n• Nginx (официант) получает этот заказ (запрос) и решает, кто его выполнит.\n• В простом случае, Nginx может сам принести клиенту готовое блюдо (статический файл) прямо из своей кладовой (папки на сервере).\n• В более сложных случаях, Nginx может перенаправить заказ на кухню (другой сервис) и принести клиенту результат оттуда.\n\nЧто делает Nginx важным:\n\n• Быстро отдает статику: Nginx очень хорошо умеет отдавать статические файлы (изображения, CSS, JavaScript и т.д.). Это позволяет веб-сайту загружаться быстрее.\n• Работает как маршрутизатор: Он может перенаправлять запросы на разные серверы в зависимости от запроса.\n• Высокая производительность: Nginx может обрабатывать большое количество запросов одновременно, не замедляя работу сайта.\n• Балансировка нагрузки: Если у тебя много серверов, Nginx может распределять запросы между ними, чтобы ни один сервер не был перегружен.\n\n▌Nginx и микросервис для отдачи статики из MinIO\n\nТеперь представим, что нам нужно организовать раздачу статики (например, изображений) для нашего сайта, но мы не хотим хранить все эти файлы прямо на нашем сервере. Вместо этого мы используем MinIO - это такое облачное хранилище, как S3 от Amazon, только можем разместить его у себя.\n\nВот как Nginx может помочь создать микросервис для этой задачи:\n\n1. MinIO (кухня): Это наше хранилище статических файлов. Он работает как отдельный сервис. Мы загружаем все наши картинки и другие файлы в MinIO.\n\n2. Nginx (официант): Получает запрос от пользователя на картинку (например, /images/logo.png).\n\n3. Конфигурация Nginx (меню ресторана): Мы говорим Nginx: \"Если кто-то запрашивает файлы из папки /images/, то не ищи их у себя на сервере, а иди за ними в MinIO.\"\n\n4. Перенаправление запроса (заказ на кухню): Nginx перенаправляет запрос в MinIO, используя специальный адрес, который знает только он.\n\n5. MinIO отдает файл (блюдо готово): MinIO находит запрошенный файл (картинку) и отдает его Nginx.\n\n6. Nginx отдает файл пользователю (официант приносит блюдо): Nginx получает картинку от MinIO и отдает ее пользователю, как будто он взял ее из своей папки.\n\nПример конфигурации Nginx (упрощенный):\n<pre><code>server {\n    listen 80;\n    server_name example.com;\n\n    location /images/ {\n        proxy_pass http://minio-server:9000/mybucket/images/; # Адрес MinIO сервера\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n    }\n}</code></pre>\nЧто здесь происходит:\n\n• listen 80; - Nginx слушает 80 порт (стандартный для веб-сайтов).\n• server_name example.com; - Это доменное имя твоего сайта.\n• location /images/ { ... } - Этот блок конфигурации применяется только к запросам, которые начинаются с /images/.\n• proxy_pass http://minio-server:9000/mybucket/images/; - Самая важная строка. Она говорит Nginx перенаправлять все запросы из /images/ на адрес MinIO-сервера http://minio-server:9000 в бакет (папку) mybucket, в подпапку images. minio-server должен быть разрешен в DNS как адрес вашего MinIO сервера.\n• proxy_set_header ... - Эти строки передают дополнительную информацию о запросе в MinIO (хост, IP-адрес пользователя). Они могут быть полезны для логирования и контроля доступа.\n\nПреимущества такого подхода:\n\n• Разделение ответственности: Nginx отвечает только за маршрутизацию и отдачу, а MinIO - за хранение.\n• Масштабируемость: MinIO можно масштабировать независимо от веб-сервера.\n• Централизованное хранение: Все статические файлы хранятся в одном месте, что упрощает управление.\n• Безопасность: Можно настроить MinIO для ограничения доступа к файлам.\n\nВ заключение:\n\nNginx выступает как шлюз, который позволяет пользователям получать статические файлы из MinIO, как если бы они хранились на том же сервере. Это простой и эффективный способ организации микросервисной архитектуры для веб-сайтов и приложений.\n",
    "group": "Прочее",
    "subGroup": "DevOps",
    "ignoreHtml": false,
    "order": 2,
    "_created": "2025-10-22T14:14:34.424Z",
    "_changed": "2025-10-22T14:14:34.424Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "nginx",
      "minio",
      "##",
      "простыми",
      "словами",
      "представь",
      "что",
      "это",
      "официант",
      "ресторане",
      "(который",
      "называется",
      "твой",
      "сервер)",
      "клиент",
      "(пользователь)",
      "приходит",
      "ресторан",
      "(твой",
      "сайт)",
      "хочет",
      "получить",
      "определенное",
      "блюдо",
      "(статический",
      "ресурс",
      "например",
      "картинку",
      "или",
      "файл",
      "html)",
      "(официант)",
      "получает",
      "этот",
      "заказ",
      "(запрос)",
      "решает",
      "кто",
      "его",
      "выполнит",
      "простом",
      "случае",
      "может",
      "сам",
      "принести",
      "клиенту",
      "готовое",
      "файл)",
      "прямо",
      "из",
      "своей",
      "кладовой",
      "(папки",
      "на",
      "сервере)",
      "более",
      "сложных",
      "случаях",
      "перенаправить",
      "кухню",
      "(другой",
      "сервис)",
      "результат",
      "оттуда",
      "делает",
      "важным:",
      "быстро",
      "отдает",
      "статику:",
      "очень",
      "хорошо",
      "умеет",
      "отдавать",
      "статические",
      "файлы",
      "(изображения",
      "css",
      "javascript",
      "позволяет",
      "веб-сайту",
      "загружаться",
      "быстрее",
      "работает",
      "как",
      "маршрутизатор:",
      "он",
      "перенаправлять",
      "запросы",
      "разные",
      "серверы",
      "зависимости",
      "от",
      "запроса",
      "высокая",
      "производительность:",
      "обрабатывать",
      "большое",
      "количество",
      "запросов",
      "одновременно",
      "не",
      "замедляя",
      "работу",
      "сайта",
      "балансировка",
      "нагрузки:",
      "если",
      "тебя",
      "много",
      "серверов",
      "распределять",
      "между",
      "ними",
      "чтобы",
      "ни",
      "один",
      "сервер",
      "был",
      "перегружен",
      "▌nginx",
      "микросервис",
      "для",
      "отдачи",
      "статики",
      "теперь",
      "представим",
      "нам",
      "нужно",
      "организовать",
      "раздачу",
      "(например",
      "изображений)",
      "нашего",
      "но",
      "мы",
      "хотим",
      "хранить",
      "все",
      "эти",
      "нашем",
      "сервере",
      "вместо",
      "этого",
      "используем",
      "такое",
      "облачное",
      "хранилище",
      "s3",
      "amazon",
      "только",
      "можем",
      "разместить",
      "себя",
      "вот",
      "помочь",
      "создать",
      "этой",
      "задачи:",
      "(кухня):",
      "наше",
      "статических",
      "файлов",
      "отдельный",
      "сервис",
      "загружаем",
      "наши",
      "картинки",
      "другие",
      "(официант):",
      "запрос",
      "пользователя",
      "/images/logo",
      "png)",
      "конфигурация",
      "(меню",
      "ресторана):",
      "говорим",
      "nginx:",
      "\"если",
      "кто-то",
      "запрашивает",
      "папки",
      "/images/",
      "то",
      "ищи",
      "их",
      "иди",
      "за",
      "перенаправление",
      "(заказ",
      "кухню):",
      "перенаправляет",
      "используя",
      "специальный",
      "адрес",
      "который",
      "знает",
      "(блюдо",
      "готово):",
      "находит",
      "запрошенный",
      "(картинку)",
      "пользователю",
      "(официант",
      "приносит",
      "блюдо):",
      "ее",
      "будто",
      "взял",
      "пример",
      "конфигурации",
      "(упрощенный):",
      "server",
      "listen",
      "80;",
      "server_name",
      "example",
      "com;",
      "location",
      "proxy_pass",
      "http://minio-server:9000/mybucket/images/;",
      "сервера",
      "proxy_set_header",
      "host",
      "$host;",
      "x-real-ip",
      "$remote_addr;",
      "здесь",
      "происходит:",
      "слушает",
      "80",
      "порт",
      "(стандартный",
      "веб-сайтов)",
      "доменное",
      "имя",
      "твоего",
      "блок",
      "применяется",
      "запросам",
      "которые",
      "начинаются",
      "самая",
      "важная",
      "строка",
      "она",
      "говорит",
      "minio-сервера",
      "http://minio-server:9000",
      "бакет",
      "(папку)",
      "mybucket",
      "подпапку",
      "images",
      "minio-server",
      "должен",
      "быть",
      "разрешен",
      "dns",
      "вашего",
      "строки",
      "передают",
      "дополнительную",
      "информацию",
      "запросе",
      "(хост",
      "ip-адрес",
      "пользователя)",
      "они",
      "могут",
      "полезны",
      "логирования",
      "контроля",
      "доступа",
      "преимущества",
      "такого",
      "подхода:",
      "разделение",
      "ответственности:",
      "отвечает",
      "маршрутизацию",
      "отдачу",
      "хранение",
      "масштабируемость:",
      "можно",
      "масштабировать",
      "независимо",
      "веб-сервера",
      "централизованное",
      "хранение:",
      "хранятся",
      "одном",
      "месте",
      "упрощает",
      "управление",
      "безопасность:",
      "настроить",
      "ограничения",
      "файлам",
      "заключение:",
      "выступает",
      "шлюз",
      "пользователям",
      "получать",
      "бы",
      "хранились",
      "том",
      "же",
      "простой",
      "эффективный",
      "способ",
      "организации",
      "микросервисной",
      "архитектуры",
      "веб-сайтов",
      "приложений",
      "прочее",
      "devops"
    ],
    "_tags": "api nginx minio ## простыми словами представь что это официант ресторане (который называется твой сервер) клиент (пользователь) приходит ресторан (твой сайт) хочет получить определенное блюдо (статический ресурс например картинку или файл html) (официант) получает этот заказ (запрос) решает кто его выполнит простом случае может сам принести клиенту готовое файл) прямо из своей кладовой (папки на сервере) более сложных случаях перенаправить кухню (другой сервис) результат оттуда делает важным: быстро отдает статику: очень хорошо умеет отдавать статические файлы (изображения css javascript позволяет веб-сайту загружаться быстрее работает как маршрутизатор: он перенаправлять запросы разные серверы зависимости от запроса высокая производительность: обрабатывать большое количество запросов одновременно не замедляя работу сайта балансировка нагрузки: если тебя много серверов распределять между ними чтобы ни один сервер был перегружен ▌nginx микросервис для отдачи статики теперь представим нам нужно организовать раздачу (например изображений) нашего но мы хотим хранить все эти нашем сервере вместо этого используем такое облачное хранилище s3 amazon только можем разместить себя вот помочь создать этой задачи: (кухня): наше статических файлов отдельный сервис загружаем наши картинки другие (официант): запрос пользователя /images/logo png) конфигурация (меню ресторана): говорим nginx: \"если кто-то запрашивает папки /images/ то ищи их иди за перенаправление (заказ кухню): перенаправляет используя специальный адрес который знает (блюдо готово): находит запрошенный (картинку) пользователю (официант приносит блюдо): ее будто взял пример конфигурации (упрощенный): server listen 80; server_name example com; location proxy_pass http://minio-server:9000/mybucket/images/; сервера proxy_set_header host $host; x-real-ip $remote_addr; здесь происходит: слушает 80 порт (стандартный веб-сайтов) доменное имя твоего блок применяется запросам которые начинаются самая важная строка она говорит minio-сервера http://minio-server:9000 бакет (папку) mybucket подпапку images minio-server должен быть разрешен dns вашего строки передают дополнительную информацию запросе (хост ip-адрес пользователя) они могут полезны логирования контроля доступа преимущества такого подхода: разделение ответственности: отвечает маршрутизацию отдачу хранение масштабируемость: можно масштабировать независимо веб-сервера централизованное хранение: хранятся одном месте упрощает управление безопасность: настроить ограничения файлам заключение: выступает шлюз пользователям получать бы хранились том же простой эффективный способ организации микросервисной архитектуры веб-сайтов приложений прочее devops",
    "_version": 0
  },
  {
    "_id": "68f8ea3d0d20f7250003de0f",
    "title": "Docker, Kubernetes, OpenShift и как они между собой связаны",
    "content": "В промышленной разработке есть необходимость «упаковки» собранного приложения, например, чтобы его можно было передать на тот сервер, где оно будет работать, в том виде, в каком разработчик собрал его у себя на компьютере, такая «упаковка» должна служить как бы защитой. Это исключает сюрпризы, вроде тех, когда во время теста приложение работает, а при переносе в рабочую среду — ломается. \nТак же «упаковка» изолирует одно приложение, от другого, находящееся на том же самом сервере, такая изоляция позволяет одному приложению не мешать работе другого (например: одно приложение не сможет забрать себе всю оперативную память сервера, оставив второе приложение на произвол судьбы). \nОсобенно заметны плюсы «упаковки» при микросервисной архитектуре, оно и понятно, много микросервисов – много небольших приложений, которые должны общаться между собой, но при этом не должны мешать друг другу. \nВ пример можно привести комод (сервер), в котором много разных ящиков, и мы можем спокойно перекладывать разные носки из одного ящика в другой, и при этом они не будут смешиваться ни друг с другом, ни с труселями.\nУпаковка создается средствам виртуализации.\t \nКогда-то давно, в качестве «упаковки» использовались виртуальные машины (VM). Олды вспомнят как разворачивали Windows XP на Vista на виртуальной машине. \nСейчас VM для упаковки приложений - это прошлый век. \nМир захватили контейнеры.  Потому что они: легче, производительнее и безопаснее.\nНужно запомнить некоторые преимущества контейнеров: \n•\tимеют меньший размер (занимают меньше памяти на сервере);\n•\tимеют доступ к общим ресурсам сервера (оперативная память, вычислительное время процессора);\n•\tимеют лучшую переносимость в другую среду (из тестовой в промышленную);\n•\tобеспечивают более высокую скорость запуска (так как контейнер легковесен, то и запускается быстрее). \n\nDocker - матерь контейнеров.\n\nКогда говорят контейнер, имеют ввиду Docker.\nDocker — программное обеспечение для автоматизации развёртывания и управления приложениями в средах с поддержкой контейнеризации. \n\nЕсли на примерах, то Docker это такая помесь онлайн конструктора и 3D принтера с краном. То есть он может сначала спроектировать шаблон(образ) для контейнера, напечатать (создать) контейнер по заданным условиям (образу), а потом переместить его куда надо. \nВместо рычагов используются Dockerfile. Процесс управления прост: пишешь файлы, команды – запускаешь – смотришь что получилось. \nDocker Compose – прокаченный Docker\n\nТеперь давайте рассмотрим сценарий, когда необходима работа нескольких контейнеров в месте. Для этого служит утилита - Docker Compose.\nDocker Compose — это инструментальное средство, входящее в состав Docker. Оно предназначено для решения задач, связанных с развёртыванием проектов.\n\nРазница между Docker и Docker Compose: \nDocker применяется для управления отдельными контейнерами. Docker Compose используется для одновременного управления несколькими контейнерами. Этот инструмент предлагает теже возможности, что и Docker, но позволяет работать с более сложными структурами.\n <p><img src=\"https://cdn.javarush.com/images/article/28505e49-f815-49db-a87b-fd7bc2ac5baa/1080.webp\" alt=\"В\" style=\"max-width: 100%;\"></p> \nТипичный сценарий использования Docker Compose:\n\nПредставьте себе, что вы являетесь разработчиком некоего веб-проекта. В этот проект входит два веб-сайта. Первый позволяет людям, занимающимся бизнесом, создавать, всего в несколько щелчков мышью, интернет-магазины. Второй нацелен на поддержку клиентов. Эти два сайта взаимодействуют с одной и той же базой данных.\n\nВаш проект становится всё популярнее, и оказывается, что мощности сервера, на котором он работает, уже недостаточно. В результате вы решаете перевести весь проект на другую машину.\n\nЕсли, нечто вроде Docker Compose вы не использовали, то вам придётся переносить и перенастраивать контейнеры по одному, надеясь на то, что вы, в процессе этой работы, ничего не забудете.\n\nЕсли же вы используете Docker Compose, то перенос вашего проекта на новый сервер — это вопрос, который решается выполнением нескольких команд. Для того чтобы завершить перенос проекта на новое место, вам нужно лишь выполнить кое-какие настройки и загрузить на новый сервер резервную копию базы данных.\nЧто тут надо запомнить: Контейнеры — это основное средство для «упаковки» приложений.  Контейнерами занимается Docker, создает образы контейнеров, поднимает и перемещает контейнеры. Для одновременного управления пачкой контейнеров используется Docker Compose который входит состав Docker. Эти программы – являются свободно распространяемым ПО (халява – одним словом)\n\n<b>Kubernetes (K8s) – автоматизация Docker</b>\n\nИ так мы развернули контейнеры, знаем, чем переносить их «пачками» с машины на машину. \nНо вдруг один из контейнеров упал! Что делать? Кто его поднимет снова? \n\nКонечно можно это сделать руками, через Docker. Но это же надо что то делать, что то писать, нужен какой то инструмент для автоматизации.\nВот здесь на сцену выходит Kubernetes (сокращенно K8s), он так же займется управлением и оркестрацией (автоматизированное управление связанными сущностями) контейнеров. Имея в распоряжении K8s не надо денно и ночно следить за контейнерами. Достаточно определить сценарий поведения, а K8s сделает все сам. \n\nОсновные возможности Kubernetes\n1.\tОбеспечивает масштабирование и управление вашей конфигурацией.\n2.\tВы можете описать, что вы хотите получить при развёртывании кластера, и К8s — это сделает. Например, указать количество подов , сколько памяти на них выделить, указать количество реплик(экземпляров) приложений, развернутых (в контейнерах) на подах.\n3.\tОтвечает за поддержание системы в определенном состоянии, если что-то упало, то К8s это поднимет, согласно установленной конфигурации.\n\nЧто тут надо запомнить: \nKubernetes – инструмент для оркестрации контейнеризированных приложений — автоматизации их развёртывания, масштабирования и координации в условиях кластера. Поддерживает основные технологии контейнеризации, включая Docker. K8s является открытым(open-source) программным обеспечением.\nOpenShift – феррари в мире виртуализации, круто, быстро и дорого\n\nРазвивая тему, дальше переходим к OpenShift.\nOpenShift это надстройка над Kubernetes, предлагающая дополнительные функции \nОн сразу же готов к использованию, его не надо долго и мучительно настраивать, можно немедленно пускать в продакшн.\nСмотрите сколько всяких иконок, над Kubernetes. И каждая из них делает свои крутые штуки.\nОсновные моменты OpenShift:\n•\tЭто платный продукт, в отличие от K8s;\n•\tDevOps из «коробки», поддержка основных сценариев развертывания blue/green, canary;\n•\tВстроенная поддержка Jenkins;\n•\tПредоставляет удобные инструменты для администрирования и работы с кластером;\n•\tИмеет более строгую модель безопасности и встроенный мониторинг.\n\nСтоит еще раз заострить внимание, что OpenShift является платным продуктом, в отличие от Kubernetes. Разница в следующем: если мы берем голый Kubernetes, то все проблемы мы решаем сами. Если говорить об OpenShift, то это продукт компании Red Hat, которая в рамках платной поддержки решает возникающие проблемы.\n\nПодведем общие итоги:\nВ промышленной разработке есть необходимость «упаковки» приложения, этот подход особенно актуален в микросервисной архитектуре. \nКонтейнеры — это основное средство для «упаковки» приложений.  Контейнерами занимается Docker, создает образы контейнеров, поднимает и перемещает контейнеры. Для одновременного управления пачкой контейнеров используется Docker Compose который входит состав Docker. Эти программы – являются свободно распространяемым ПО.\nKubernetes(K8s) – инструмент для оркестровки контейнеризированных приложений — автоматизации их развёртывания, масштабирования и координации в условиях кластера. Поддерживает основные технологии контейнеризации, включая Docker. K8s является открытым(open-source) программным обеспечением.\nOpenShift это надстройка над Kubernetes, предлагающая дополнительные функции. Это платный продукт, в отличие от K8s предназначенный для корпоративного использования. Предоставляет DevOps из «коробки»: поддержка основных сценариев развертывания blue/green, canary, имеет встроенную поддержку Jenkins и предоставляет удобные инструменты для администрирования и работы с кластером. Имеет более строгую модель безопасности и встроенный мониторинг.\n\n",
    "group": "Прочее",
    "subGroup": "DevOps",
    "ignoreHtml": false,
    "order": 3,
    "_created": "2025-10-22T14:29:17.530Z",
    "_changed": "2025-10-22T14:29:17.530Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "docker",
      "kubernetes",
      "openshift",
      "как",
      "они",
      "между",
      "собой",
      "связаны",
      "промышленной",
      "разработке",
      "есть",
      "необходимость",
      "«упаковки»",
      "собранного",
      "приложения",
      "например",
      "чтобы",
      "его",
      "можно",
      "было",
      "передать",
      "на",
      "тот",
      "сервер",
      "где",
      "оно",
      "будет",
      "работать",
      "том",
      "виде",
      "каком",
      "разработчик",
      "собрал",
      "себя",
      "компьютере",
      "такая",
      "«упаковка»",
      "должна",
      "служить",
      "бы",
      "защитой",
      "это",
      "исключает",
      "сюрпризы",
      "вроде",
      "тех",
      "когда",
      "во",
      "время",
      "теста",
      "приложение",
      "работает",
      "при",
      "переносе",
      "рабочую",
      "среду",
      "ломается",
      "так",
      "же",
      "изолирует",
      "одно",
      "от",
      "другого",
      "находящееся",
      "самом",
      "сервере",
      "изоляция",
      "позволяет",
      "одному",
      "приложению",
      "не",
      "мешать",
      "работе",
      "(например:",
      "сможет",
      "забрать",
      "себе",
      "всю",
      "оперативную",
      "память",
      "сервера",
      "оставив",
      "второе",
      "произвол",
      "судьбы)",
      "особенно",
      "заметны",
      "плюсы",
      "микросервисной",
      "архитектуре",
      "понятно",
      "много",
      "микросервисов",
      "небольших",
      "приложений",
      "которые",
      "должны",
      "общаться",
      "но",
      "этом",
      "друг",
      "другу",
      "пример",
      "привести",
      "комод",
      "(сервер)",
      "котором",
      "разных",
      "ящиков",
      "мы",
      "можем",
      "спокойно",
      "перекладывать",
      "разные",
      "носки",
      "из",
      "одного",
      "ящика",
      "другой",
      "будут",
      "смешиваться",
      "ни",
      "другом",
      "труселями",
      "упаковка",
      "создается",
      "средствам",
      "виртуализации",
      "когда-то",
      "давно",
      "качестве",
      "использовались",
      "виртуальные",
      "машины",
      "(vm)",
      "олды",
      "вспомнят",
      "разворачивали",
      "windows",
      "xp",
      "vista",
      "виртуальной",
      "машине",
      "сейчас",
      "vm",
      "для",
      "упаковки",
      "прошлый",
      "век",
      "мир",
      "захватили",
      "контейнеры",
      "потому",
      "что",
      "они:",
      "легче",
      "производительнее",
      "безопаснее",
      "нужно",
      "запомнить",
      "некоторые",
      "преимущества",
      "контейнеров:",
      "•\tимеют",
      "меньший",
      "размер",
      "(занимают",
      "меньше",
      "памяти",
      "сервере);",
      "доступ",
      "общим",
      "ресурсам",
      "(оперативная",
      "вычислительное",
      "процессора);",
      "лучшую",
      "переносимость",
      "другую",
      "(из",
      "тестовой",
      "промышленную);",
      "•\tобеспечивают",
      "более",
      "высокую",
      "скорость",
      "запуска",
      "(так",
      "контейнер",
      "легковесен",
      "то",
      "запускается",
      "быстрее)",
      "матерь",
      "контейнеров",
      "говорят",
      "имеют",
      "ввиду",
      "программное",
      "обеспечение",
      "автоматизации",
      "развёртывания",
      "управления",
      "приложениями",
      "средах",
      "поддержкой",
      "контейнеризации",
      "если",
      "примерах",
      "помесь",
      "онлайн",
      "конструктора",
      "3d",
      "принтера",
      "краном",
      "он",
      "может",
      "сначала",
      "спроектировать",
      "шаблон(образ)",
      "контейнера",
      "напечатать",
      "(создать)",
      "по",
      "заданным",
      "условиям",
      "(образу)",
      "потом",
      "переместить",
      "куда",
      "надо",
      "вместо",
      "рычагов",
      "используются",
      "dockerfile",
      "процесс",
      "прост:",
      "пишешь",
      "файлы",
      "команды",
      "запускаешь",
      "смотришь",
      "получилось",
      "compose",
      "прокаченный",
      "теперь",
      "давайте",
      "рассмотрим",
      "сценарий",
      "необходима",
      "работа",
      "нескольких",
      "месте",
      "этого",
      "служит",
      "утилита",
      "инструментальное",
      "средство",
      "входящее",
      "состав",
      "предназначено",
      "решения",
      "задач",
      "связанных",
      "развёртыванием",
      "проектов",
      "разница",
      "compose:",
      "применяется",
      "отдельными",
      "контейнерами",
      "используется",
      "одновременного",
      "несколькими",
      "этот",
      "инструмент",
      "предлагает",
      "теже",
      "возможности",
      "сложными",
      "структурами",
      "типичный",
      "использования",
      "представьте",
      "вы",
      "являетесь",
      "разработчиком",
      "некоего",
      "веб-проекта",
      "проект",
      "входит",
      "два",
      "веб-сайта",
      "первый",
      "людям",
      "занимающимся",
      "бизнесом",
      "создавать",
      "всего",
      "несколько",
      "щелчков",
      "мышью",
      "интернет-магазины",
      "второй",
      "нацелен",
      "поддержку",
      "клиентов",
      "эти",
      "сайта",
      "взаимодействуют",
      "одной",
      "той",
      "базой",
      "данных",
      "ваш",
      "становится",
      "всё",
      "популярнее",
      "оказывается",
      "мощности",
      "уже",
      "недостаточно",
      "результате",
      "решаете",
      "перевести",
      "весь",
      "машину",
      "нечто",
      "использовали",
      "вам",
      "придётся",
      "переносить",
      "перенастраивать",
      "надеясь",
      "процессе",
      "этой",
      "работы",
      "ничего",
      "забудете",
      "используете",
      "перенос",
      "вашего",
      "проекта",
      "новый",
      "вопрос",
      "который",
      "решается",
      "выполнением",
      "команд",
      "того",
      "завершить",
      "новое",
      "место",
      "лишь",
      "выполнить",
      "кое-какие",
      "настройки",
      "загрузить",
      "резервную",
      "копию",
      "базы",
      "тут",
      "запомнить:",
      "основное",
      "занимается",
      "создает",
      "образы",
      "поднимает",
      "перемещает",
      "пачкой",
      "программы",
      "являются",
      "свободно",
      "распространяемым",
      "(халява",
      "одним",
      "словом)",
      "(k8s)",
      "автоматизация",
      "развернули",
      "знаем",
      "чем",
      "их",
      "«пачками»",
      "вдруг",
      "один",
      "упал!",
      "делать?",
      "кто",
      "поднимет",
      "снова?",
      "конечно",
      "сделать",
      "руками",
      "через",
      "делать",
      "писать",
      "нужен",
      "какой",
      "вот",
      "здесь",
      "сцену",
      "выходит",
      "(сокращенно",
      "k8s)",
      "займется",
      "управлением",
      "оркестрацией",
      "(автоматизированное",
      "управление",
      "связанными",
      "сущностями)",
      "имея",
      "распоряжении",
      "k8s",
      "денно",
      "ночно",
      "следить",
      "за",
      "достаточно",
      "определить",
      "поведения",
      "сделает",
      "все",
      "сам",
      "основные",
      "\tобеспечивает",
      "масштабирование",
      "вашей",
      "конфигурацией",
      "\tвы",
      "можете",
      "описать",
      "хотите",
      "получить",
      "развёртывании",
      "кластера",
      "к8s",
      "указать",
      "количество",
      "подов",
      "сколько",
      "них",
      "выделить",
      "реплик(экземпляров)",
      "развернутых",
      "(в",
      "контейнерах)",
      "подах",
      "\tотвечает",
      "поддержание",
      "системы",
      "определенном",
      "состоянии",
      "что-то",
      "упало",
      "согласно",
      "установленной",
      "конфигурации",
      "оркестрации",
      "контейнеризированных",
      "масштабирования",
      "координации",
      "условиях",
      "поддерживает",
      "технологии",
      "включая",
      "является",
      "открытым(open-source)",
      "программным",
      "обеспечением",
      "феррари",
      "мире",
      "круто",
      "быстро",
      "дорого",
      "развивая",
      "тему",
      "дальше",
      "переходим",
      "надстройка",
      "над",
      "предлагающая",
      "дополнительные",
      "функции",
      "сразу",
      "готов",
      "использованию",
      "долго",
      "мучительно",
      "настраивать",
      "немедленно",
      "пускать",
      "продакшн",
      "смотрите",
      "всяких",
      "иконок",
      "каждая",
      "делает",
      "свои",
      "крутые",
      "штуки",
      "моменты",
      "openshift:",
      "•\tэто",
      "платный",
      "продукт",
      "отличие",
      "k8s;",
      "•\tdevops",
      "«коробки»",
      "поддержка",
      "основных",
      "сценариев",
      "развертывания",
      "blue/green",
      "canary;",
      "•\tвстроенная",
      "jenkins;",
      "•\tпредоставляет",
      "удобные",
      "инструменты",
      "администрирования",
      "кластером;",
      "•\tимеет",
      "строгую",
      "модель",
      "безопасности",
      "встроенный",
      "мониторинг",
      "стоит",
      "еще",
      "раз",
      "заострить",
      "внимание",
      "платным",
      "продуктом",
      "следующем:",
      "берем",
      "голый",
      "проблемы",
      "решаем",
      "сами",
      "говорить",
      "об",
      "компании",
      "red",
      "hat",
      "которая",
      "рамках",
      "платной",
      "поддержки",
      "решает",
      "возникающие",
      "подведем",
      "общие",
      "итоги:",
      "подход",
      "актуален",
      "kubernetes(k8s)",
      "оркестровки",
      "предназначенный",
      "корпоративного",
      "предоставляет",
      "devops",
      "«коробки»:",
      "canary",
      "имеет",
      "встроенную",
      "jenkins",
      "кластером",
      "прочее"
    ],
    "_tags": "api docker kubernetes openshift как они между собой связаны промышленной разработке есть необходимость «упаковки» собранного приложения например чтобы его можно было передать на тот сервер где оно будет работать том виде каком разработчик собрал себя компьютере такая «упаковка» должна служить бы защитой это исключает сюрпризы вроде тех когда во время теста приложение работает при переносе рабочую среду ломается так же изолирует одно от другого находящееся самом сервере изоляция позволяет одному приложению не мешать работе (например: сможет забрать себе всю оперативную память сервера оставив второе произвол судьбы) особенно заметны плюсы микросервисной архитектуре понятно много микросервисов небольших приложений которые должны общаться но этом друг другу пример привести комод (сервер) котором разных ящиков мы можем спокойно перекладывать разные носки из одного ящика другой будут смешиваться ни другом труселями упаковка создается средствам виртуализации когда-то давно качестве использовались виртуальные машины (vm) олды вспомнят разворачивали windows xp vista виртуальной машине сейчас vm для упаковки прошлый век мир захватили контейнеры потому что они: легче производительнее безопаснее нужно запомнить некоторые преимущества контейнеров: •\tимеют меньший размер (занимают меньше памяти сервере); доступ общим ресурсам (оперативная вычислительное процессора); лучшую переносимость другую (из тестовой промышленную); •\tобеспечивают более высокую скорость запуска (так контейнер легковесен то запускается быстрее) матерь контейнеров говорят имеют ввиду программное обеспечение автоматизации развёртывания управления приложениями средах поддержкой контейнеризации если примерах помесь онлайн конструктора 3d принтера краном он может сначала спроектировать шаблон(образ) контейнера напечатать (создать) по заданным условиям (образу) потом переместить куда надо вместо рычагов используются dockerfile процесс прост: пишешь файлы команды запускаешь смотришь получилось compose прокаченный теперь давайте рассмотрим сценарий необходима работа нескольких месте этого служит утилита инструментальное средство входящее состав предназначено решения задач связанных развёртыванием проектов разница compose: применяется отдельными контейнерами используется одновременного несколькими этот инструмент предлагает теже возможности сложными структурами типичный использования представьте вы являетесь разработчиком некоего веб-проекта проект входит два веб-сайта первый людям занимающимся бизнесом создавать всего несколько щелчков мышью интернет-магазины второй нацелен поддержку клиентов эти сайта взаимодействуют одной той базой данных ваш становится всё популярнее оказывается мощности уже недостаточно результате решаете перевести весь машину нечто использовали вам придётся переносить перенастраивать надеясь процессе этой работы ничего забудете используете перенос вашего проекта новый вопрос который решается выполнением команд того завершить новое место лишь выполнить кое-какие настройки загрузить резервную копию базы тут запомнить: основное занимается создает образы поднимает перемещает пачкой программы являются свободно распространяемым (халява одним словом) (k8s) автоматизация развернули знаем чем их «пачками» вдруг один упал! делать? кто поднимет снова? конечно сделать руками через делать писать нужен какой вот здесь сцену выходит (сокращенно k8s) займется управлением оркестрацией (автоматизированное управление связанными сущностями) имея распоряжении k8s денно ночно следить за достаточно определить поведения сделает все сам основные \tобеспечивает масштабирование вашей конфигурацией \tвы можете описать хотите получить развёртывании кластера к8s указать количество подов сколько них выделить реплик(экземпляров) развернутых (в контейнерах) подах \tотвечает поддержание системы определенном состоянии что-то упало согласно установленной конфигурации оркестрации контейнеризированных масштабирования координации условиях поддерживает технологии включая является открытым(open-source) программным обеспечением феррари мире круто быстро дорого развивая тему дальше переходим надстройка над предлагающая дополнительные функции сразу готов использованию долго мучительно настраивать немедленно пускать продакшн смотрите всяких иконок каждая делает свои крутые штуки моменты openshift: •\tэто платный продукт отличие k8s; •\tdevops «коробки» поддержка основных сценариев развертывания blue/green canary; •\tвстроенная jenkins; •\tпредоставляет удобные инструменты администрирования кластером; •\tимеет строгую модель безопасности встроенный мониторинг стоит еще раз заострить внимание платным продуктом следующем: берем голый проблемы решаем сами говорить об компании red hat которая рамках платной поддержки решает возникающие подведем общие итоги: подход актуален kubernetes(k8s) оркестровки предназначенный корпоративного предоставляет devops «коробки»: canary имеет встроенную jenkins кластером прочее",
    "_version": 0
  },
  {
    "_id": "68fd33ec0d20f725000437c8",
    "title": "144444444444444",
    "content": "4444444444444444444444",
    "group": "Группа1",
    "subGroup": "sdfsdfsdf",
    "ignoreHtml": false,
    "order": 10,
    "_created": "2025-10-25T20:32:44.292Z",
    "_changed": "2025-10-25T20:32:44.292Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "144444444444444",
      "4444444444444444444444",
      "группа1",
      "sdfsdfsdf",
      "10"
    ],
    "_tags": "api 144444444444444 4444444444444444444444 группа1 sdfsdfsdf 10",
    "_version": 0
  },
  {
    "_id": "68fbe4530d20f72500041e90",
    "title": "Колбэк-функция",
    "content": " коллбэк — это функция, которая должна быть выполнена после того, как другая функция завершила выполнение (отсюда и название: callback — функция обратного вызова).\n\nЧуть сложнее: В JavaScript функции — это объекты. Поэтому функции могут принимать другие функции в качестве аргументов, а также возвращать функции в качестве результата. Функции, которые это умеют, называются функциями высшего порядка. А любая функция, которая передается как аргумент, называется callback-функцией.\nЗачем нужны коллбэки?\nПо одной простой причине: JavaScript — это событийно-ориентированный язык. Поэтому вместо того, чтобы ждать ответа для дальнейшего выполнения программы, JavaScript продолжит выполнение, одновременно ожидая других событий. \n<pre><code>const first = () => {\n  console.log(1);\n};\n\nconst second = () => {\n  console.log(2);\n};\n\nfirst();\nsecond();</code></pre>\n Функция first выполнится первой, а функция second уже после нее. Поэтому в консоли будет выведен следующий результат:\n\n// 1 // 2\nПока что все понятно. Но что, если функция first содержит некий код, который не может выполниться немедленно? К примеру, работа с API, где мы отправляем запрос и должны ждать ответа. Чтобы смоделировать такую ситуацию, мы используем функцию setTimeout, которая вызывает функцию после заданного временного промежутка. Мы отсрочим выполнение функции на 500 миллисекунд, как будто бы это запрос к некому API. Теперь код будет выглядеть так:\n<pre><code>const first = () => {\n  // Как будто бы запрос к API\n  setTimeout(() => {\n    console.log(1);\n  }, 500 );\n};\n\nconst second = () => {\n  console.log(2);\n};\n\nfirst();</code></pre>\nsecond();\nНеважно, понимаете ли вы сейчас, как работает setTimeout(). Основная идея — теперь мы отложили исполнение команды console.log(1) на 500 миллисекунд. И что теперь выведет наша программа?\n\n<pre><code>first(); second(); // 2 // 1</code></pre>\nХотя мы по-прежнему вызываем функцию first первой, ее вывод появился вторым, после вывода функции second. Но JavaScript не нарушает порядок вызова функций, он просто не дожидается ответа от функции first, а сразу двигается дальше — к функции second.\n\nПоэтому нельзя просто вызывать функции в нужном порядке и надеяться, что они в любом случае выполнятся в том же порядке. Коллбэки же позволяют нам быть уверенными в том, что определенный код не начнет исполнение до того момента, пока другой код не завершит исполнение.\nПерепишем пример вызова функции с setTimeout для последовательного выполнения функций:\n\n<pre><code>const first = (callback) => {\n  // Как будто бы запрос к API\n  setTimeout(() => {\n    console.log(1);\n    callback();\n  }, 500 );\n};\n\nconst second = () => {\n  console.log(2);\n};\n\nfirst(second);\n// 1\n// 2</code></pre>\nПример из реальной жизни\nНа прошлой неделе я опубликовал статью «Создаем бота для Твиттера в 38 строк кода». Этот код работает благодаря API Твиттера. И когда мы делаем запрос к API, мы должны дождаться ответа до того, как начнем выполнять с этим ответом какие-то действия. Это прекрасный пример того, как в реальной жизни выглядит коллбэк. Вот как выглядит сам запрос:\n\n<pre><code>T.get('search/tweets', params, (err, data, response) => {\n  if (!err) {\n    // Происходит какая-то магия\n  } else {\n    console.log(err);\n  }\n});</code></pre>\nT.get просто значит, что мы выполняем get запрос к API Твиттера. В запросе три параметра: 'search/tweets' – это адрес (роут) запроса, params – наши параметры поиска и в конце передается анонимная функция-callback.\n\nКоллбэк здесь нужен, потому что нам нужно дождаться ответа от сервера до того, как приступим к дальнейшему выполнению кода. Мы не знаем, успешным будет наш запрос или нет, поэтому после отправки параметров поиска на search/tweets через get-запрос, мы просто ждем. Как только Твиттер ответит, выполнится наша callback-функция. Твиттер отправит нам в качестве ответа или объект err (error – ошибка), или объект response. В коллбэке мы можем через if() проверить, был ли запрос успешным или нет, и затем действовать соответственно.",
    "group": "JavaScript",
    "subGroup": "JavaScript Basic",
    "ignoreHtml": false,
    "order": 1,
    "_created": "2025-10-24T20:40:51.941Z",
    "_changed": "2025-10-25T20:36:37.018Z",
    "_createdby": "api",
    "_changedby": "osokinkostyan12@gmail.com",
    "_keywords": [
      "api",
      "osokinkostyan12",
      "gmail",
      "com",
      "колбэк-функция",
      "коллбэк",
      "это",
      "функция",
      "которая",
      "должна",
      "быть",
      "выполнена",
      "после",
      "того",
      "как",
      "другая",
      "завершила",
      "выполнение",
      "(отсюда",
      "название:",
      "callback",
      "обратного",
      "вызова)",
      "чуть",
      "сложнее:",
      "javascript",
      "функции",
      "объекты",
      "поэтому",
      "могут",
      "принимать",
      "другие",
      "качестве",
      "аргументов",
      "также",
      "возвращать",
      "результата",
      "которые",
      "умеют",
      "называются",
      "функциями",
      "высшего",
      "порядка",
      "любая",
      "передается",
      "аргумент",
      "называется",
      "callback-функцией",
      "зачем",
      "нужны",
      "коллбэки?",
      "по",
      "одной",
      "простой",
      "причине:",
      "событийно-ориентированный",
      "язык",
      "вместо",
      "чтобы",
      "ждать",
      "ответа",
      "для",
      "дальнейшего",
      "выполнения",
      "программы",
      "продолжит",
      "одновременно",
      "ожидая",
      "других",
      "событий",
      "const",
      "first",
      "()",
      "=>",
      "console",
      "log(1);",
      "};",
      "second",
      "log(2);",
      "first();",
      "second();",
      "выполнится",
      "первой",
      "уже",
      "нее",
      "консоли",
      "будет",
      "выведен",
      "следующий",
      "результат:",
      "//",
      "пока",
      "что",
      "все",
      "понятно",
      "но",
      "если",
      "содержит",
      "некий",
      "код",
      "который",
      "не",
      "может",
      "выполниться",
      "немедленно?",
      "примеру",
      "работа",
      "где",
      "мы",
      "отправляем",
      "запрос",
      "должны",
      "смоделировать",
      "такую",
      "ситуацию",
      "используем",
      "функцию",
      "settimeout",
      "вызывает",
      "заданного",
      "временного",
      "промежутка",
      "отсрочим",
      "на",
      "500",
      "миллисекунд",
      "будто",
      "бы",
      "некому",
      "теперь",
      "выглядеть",
      "так:",
      "settimeout(()",
      ");",
      "неважно",
      "понимаете",
      "ли",
      "вы",
      "сейчас",
      "работает",
      "settimeout()",
      "основная",
      "идея",
      "отложили",
      "исполнение",
      "команды",
      "log(1)",
      "выведет",
      "наша",
      "программа?",
      "хотя",
      "по-прежнему",
      "вызываем",
      "ее",
      "вывод",
      "появился",
      "вторым",
      "вывода",
      "нарушает",
      "порядок",
      "вызова",
      "функций",
      "он",
      "просто",
      "дожидается",
      "от",
      "сразу",
      "двигается",
      "дальше",
      "нельзя",
      "вызывать",
      "нужном",
      "порядке",
      "надеяться",
      "они",
      "любом",
      "случае",
      "выполнятся",
      "том",
      "же",
      "коллбэки",
      "позволяют",
      "нам",
      "уверенными",
      "определенный",
      "начнет",
      "до",
      "момента",
      "другой",
      "завершит",
      "перепишем",
      "пример",
      "последовательного",
      "функций:",
      "(callback)",
      "callback();",
      "first(second);",
      "из",
      "реальной",
      "жизни",
      "прошлой",
      "неделе",
      "опубликовал",
      "статью",
      "«создаем",
      "бота",
      "твиттера",
      "38",
      "строк",
      "кода»",
      "этот",
      "благодаря",
      "когда",
      "делаем",
      "дождаться",
      "начнем",
      "выполнять",
      "этим",
      "ответом",
      "какие-то",
      "действия",
      "прекрасный",
      "выглядит",
      "вот",
      "сам",
      "запрос:",
      "get('search/tweets'",
      "params",
      "(err",
      "data",
      "response)",
      "if",
      "(!err)",
      "происходит",
      "какая-то",
      "магия",
      "else",
      "log(err);",
      "});",
      "get",
      "значит",
      "выполняем",
      "запросе",
      "три",
      "параметра:",
      "'search/tweets'",
      "адрес",
      "(роут)",
      "запроса",
      "наши",
      "параметры",
      "поиска",
      "конце",
      "анонимная",
      "функция-callback",
      "здесь",
      "нужен",
      "потому",
      "нужно",
      "сервера",
      "приступим",
      "дальнейшему",
      "выполнению",
      "кода",
      "знаем",
      "успешным",
      "наш",
      "или",
      "нет",
      "отправки",
      "параметров",
      "search/tweets",
      "через",
      "get-запрос",
      "ждем",
      "только",
      "твиттер",
      "ответит",
      "callback-функция",
      "отправит",
      "объект",
      "err",
      "(error",
      "ошибка)",
      "response",
      "коллбэке",
      "можем",
      "if()",
      "проверить",
      "был",
      "затем",
      "действовать",
      "соответственно",
      "basic"
    ],
    "_tags": "api osokinkostyan12 gmail com колбэк-функция коллбэк это функция которая должна быть выполнена после того как другая завершила выполнение (отсюда название: callback обратного вызова) чуть сложнее: javascript функции объекты поэтому могут принимать другие качестве аргументов также возвращать результата которые умеют называются функциями высшего порядка любая передается аргумент называется callback-функцией зачем нужны коллбэки? по одной простой причине: событийно-ориентированный язык вместо чтобы ждать ответа для дальнейшего выполнения программы продолжит одновременно ожидая других событий const first () => console log(1); }; second log(2); first(); second(); выполнится первой уже нее консоли будет выведен следующий результат: // пока что все понятно но если содержит некий код который не может выполниться немедленно? примеру работа где мы отправляем запрос должны смоделировать такую ситуацию используем функцию settimeout вызывает заданного временного промежутка отсрочим на 500 миллисекунд будто бы некому теперь выглядеть так: settimeout(() ); неважно понимаете ли вы сейчас работает settimeout() основная идея отложили исполнение команды log(1) выведет наша программа? хотя по-прежнему вызываем ее вывод появился вторым вывода нарушает порядок вызова функций он просто дожидается от сразу двигается дальше нельзя вызывать нужном порядке надеяться они любом случае выполнятся том же коллбэки позволяют нам уверенными определенный начнет до момента другой завершит перепишем пример последовательного функций: (callback) callback(); first(second); из реальной жизни прошлой неделе опубликовал статью «создаем бота твиттера 38 строк кода» этот благодаря когда делаем дождаться начнем выполнять этим ответом какие-то действия прекрасный выглядит вот сам запрос: get('search/tweets' params (err data response) if (!err) происходит какая-то магия else log(err); }); get значит выполняем запросе три параметра: 'search/tweets' адрес (роут) запроса наши параметры поиска конце анонимная функция-callback здесь нужен потому нужно сервера приступим дальнейшему выполнению кода знаем успешным наш или нет отправки параметров search/tweets через get-запрос ждем только твиттер ответит callback-функция отправит объект err (error ошибка) response коллбэке можем if() проверить был затем действовать соответственно basic",
    "_version": 1
  },
  {
    "_id": "68fe10330d20f725000446fd",
    "title": "Замыкание",
    "content": "Замыкание (closure) представляют собой конструкцию, когда функция, созданная в одной области видимости, запоминает свое лексическое окружение даже в том случае, когда она выполняет вне своей области видимости. \nДля организации замыкания необходимы три компонента: \n- внешняя функция, которая определяет некоторую область видимости и в которой определены некоторые переменные - лексическое окружение \n- переменные (лексическое окружение), которые определены во внешней функции \n- вложенная функция, которая использует эти переменные\n<pre><code>function outer(){       // внешняя функция\n    let n;              // некоторая переменная\n    return inner(){     // вложенная функция\n        // действия с переменной n\n    }\n}</code></pre>\nГрубо говоря, функция inner и представляет в данном случае замыкание, которое запонимание свое лексического окружение - переменную х.\nРассмотрим замыкания на простейшем примере:\n<pre><code>function outer(){\n    let x = 5;\n    function inner(){\n        x++;\n        console.log(x);\n    };\n    return inner;\n}\nconst fn = outer(); // fn = inner, так как функция outer возвращает функцию inner\n// вызываем внутреннюю функцию inner\nfn();   // 6\nfn();   // 7\nfn();   // 8</code></pre>\nЗдесь функция outer задает область видимости, в которой определены внутренняя функция inner и переменная x. Переменная x представляет лексическое окружение для функции inner. В самой функции inner инкрементируем переменную x и выводим ее значение на консоль. В конце функция outer возвращает функцию inner.\nДалее вызываем функцию outer:\n<pre><code>const fn = outer();</code></pre>\nПоскольку функция outer возвращает функцию inner, то константа fn будет хранить ссылку на функцию inner. При этом эта функция запомнила свое окружение - то есть внешнюю переменную x.\n\nДалее мы фактически три раза вызываем функцию Inner, и мы видим, что переменная x, которая определена вне функции inner, инкрементируется:\n<pre><code>fn();   // 6\nfn();   // 7\nfn();   // 8</code></pre>\nТо есть несмотря на то, что переменная x определена вне функции inner, эта функция запомнила свое окружение и может его использовать, несомотря на то, что она вызывается вне функции outer, в которой была определена. В этом и суть замыканий.\n\nПричем для каждой копии замыкания определяется своя копия лексического окружения:\n<pre><code>// определяем объект-пространство имен\nfunction outer(){\n    let x = 5;\n    function inner(){\n        x++;\n        console.log(x);\n    };\n    return inner;\n}\nconst fn1 = outer();\nconst fn2 = outer();\nfn1();  // 6\nfn1();  // 7\nfn2();  // 6\nfn2();  // 7</code></pre>\nЗдесь видно, что для fn1 и fn2 есть своя копия переменной х, которой они манипулируют независимо друг от друга.\n\nРассмотрим еще один пример:\n<pre><code>function multiply(n){\n    let x = n;\n    return function(m){ return x * m;};\n}\nconst fn1 = multiply(5);\nconst result1 = fn1(6); // 30\nconsole.log(result1); // 30\n \nconst fn2= multiply(4);\nconst result2 = fn2(6); // 24\nconsole.log(result2); // 24</code></pre>\nИтак, здесь вызов функции multiply() приводит к вызову другой внутренней функции. Внутренняя же функция:\n<pre><code>function(m){ return x * m;};</code></pre>\nзапоминает окружение, в котором она была создана, в частности, значение переменной x.\n\nВ итоге при вызове функции multiply определяется константа fn1, которая и представляет собой замыкание, то есть объединяет две вещи: функцию и окружение, в котором функция была создана. Окружение состоит из любой локальной переменной, которая была в области действия функции multiply во время создания замыкания.\n\nТо есть fn1 — это замыкание, которое содержит и внутреннюю функцию function(m){ return x * m;}, и переменную x, которая существовала во время создания замыкания.\n\nПри создании двух замыканий: fn1 и fn2, для каждого из этих замыканий создается свое окружение.\n\nПри этом важно не запутаться в параметрах. При определении замыкания:\n<pre><code>const fn1 = multiply(5);</code></pre>\nЧисло 5 передается для параметра n функции multiply.\n\nПри вызове внутренней функции:\n<pre><code>const result1 = fn1(6);</code></pre>\nЧисло 6 передается для параметра m во внутреннюю функцию function(m){ return x * m;};.\n\nТакже мы можем использовать другой вариант для вызова замыкания:\n<pre><code>function multiply(n){\n    let x = n;\n    return function(m){ return x * m;};\n}\nconst result = multiply(5)(6); // 30\nconsole.log(result);</code></pre>\n<b>Замыкания и объектно-ориентированное программирование</b>\nЗамыкания по сути явились предтечей объектно-ориентированного программирования. И использование замыканий в некоторой степени позволяет имитировать создание объектов и работу с ними. Например, рассмотрим следующий код:\n<pre><code>function person(name, age){\n    console.log(\"Person\", name, \"created\");\n \n    function print(){\n         console.log(\"Person \", name, \" (\" +age +\")\");\n    }\n    function work(){\n         console.log(\"Person \", name, \" works\");\n    }\n    function incrementAge(value){\n        age = age + value;\n    }\n    return [print, work, incrementAge];\n}\n \nconst tom = person(\"Tom\", 39);\ntom[0]();       // print\ntom[1]();       // work\ntom[2](1);      // incrementAge\ntom[0]();       // print</code></pre>\nФункция person принимает два параметра и определяет три вложенных функции. По сути эти вложенных функции и образуют замыкания, а в качестве лексического окружения используют параметры функции person.\n\nЗдесь функция person выступает своего рода конструктором объекта person - условного человека, а ее параметры name и age принимают извне соответственно имя и возраст человека. Три вложенных функции - print, work, incrementAge могут обращаться к своему лексическому окружению - параметрам функции person.\n\nЧтобы к этим функциям можно было обратиться извне, функция person возвращает вложенные функции в виде массива:\n<pre><code>return [print, work, incrementAge];</code></pre>\nДалее мы можем вызвать функцию person, передав в нее некоторые параметры, и получить ее результат - условного человека:\n<pre><code>const tom = person(\"Tom\", 39);</code></pre>\nЧто такое в данном случае константа tom? По сути это возвращенный массив из трех функций, котоорые позволяют манипулировать человеком tom. Соответственно, обратившись к определенному элементу в массиве, мы можем вызвать соответствующую функцию:\n<pre><code>tom[0]();       // print</code></pre>\nТо есть выражение tom[0] возвращает функцию print, а выражение tom[0]() вызывает ее. В итоге в данном случае вывод консоли браузера будет следующим:\n\n<pre><code>Person Tom created\nPerson  Tom  (39)\nPerson  Tom  works\nPerson  Tom  (40)\n</code></pre>\n",
    "group": "JavaScript",
    "subGroup": "JavaScript Basic",
    "ignoreHtml": false,
    "order": 3,
    "_created": "2025-10-26T12:12:35.495Z",
    "_changed": "2025-10-26T12:13:38.284Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "замыкание",
      "(closure)",
      "представляют",
      "собой",
      "конструкцию",
      "когда",
      "функция",
      "созданная",
      "одной",
      "области",
      "видимости",
      "запоминает",
      "свое",
      "лексическое",
      "окружение",
      "даже",
      "том",
      "случае",
      "она",
      "выполняет",
      "вне",
      "своей",
      "для",
      "организации",
      "замыкания",
      "необходимы",
      "три",
      "компонента:",
      "внешняя",
      "которая",
      "определяет",
      "некоторую",
      "область",
      "которой",
      "определены",
      "некоторые",
      "переменные",
      "(лексическое",
      "окружение)",
      "которые",
      "во",
      "внешней",
      "функции",
      "вложенная",
      "использует",
      "эти",
      "function",
      "outer(){",
      "//",
      "let",
      "n;",
      "некоторая",
      "переменная",
      "return",
      "inner(){",
      "действия",
      "переменной",
      "грубо",
      "говоря",
      "inner",
      "представляет",
      "данном",
      "которое",
      "запонимание",
      "лексического",
      "переменную",
      "рассмотрим",
      "на",
      "простейшем",
      "примере:",
      "5;",
      "x++;",
      "console",
      "log(x);",
      "};",
      "inner;",
      "const",
      "fn",
      "outer();",
      "так",
      "как",
      "outer",
      "возвращает",
      "функцию",
      "вызываем",
      "внутреннюю",
      "fn();",
      "здесь",
      "задает",
      "внутренняя",
      "самой",
      "инкрементируем",
      "выводим",
      "ее",
      "значение",
      "консоль",
      "конце",
      "далее",
      "outer:",
      "поскольку",
      "то",
      "константа",
      "будет",
      "хранить",
      "ссылку",
      "при",
      "этом",
      "эта",
      "запомнила",
      "есть",
      "внешнюю",
      "мы",
      "фактически",
      "раза",
      "видим",
      "что",
      "определена",
      "инкрементируется:",
      "несмотря",
      "может",
      "его",
      "использовать",
      "несомотря",
      "вызывается",
      "была",
      "суть",
      "замыканий",
      "причем",
      "каждой",
      "копии",
      "определяется",
      "своя",
      "копия",
      "окружения:",
      "определяем",
      "объект-пространство",
      "имен",
      "fn1",
      "fn2",
      "fn1();",
      "fn2();",
      "видно",
      "они",
      "манипулируют",
      "независимо",
      "друг",
      "от",
      "друга",
      "еще",
      "один",
      "пример:",
      "multiply(n){",
      "function(m){",
      "m;};",
      "multiply(5);",
      "result1",
      "fn1(6);",
      "30",
      "log(result1);",
      "fn2=",
      "multiply(4);",
      "result2",
      "fn2(6);",
      "24",
      "log(result2);",
      "итак",
      "вызов",
      "multiply()",
      "приводит",
      "вызову",
      "другой",
      "внутренней",
      "же",
      "функция:",
      "котором",
      "создана",
      "частности",
      "итоге",
      "вызове",
      "multiply",
      "объединяет",
      "две",
      "вещи:",
      "состоит",
      "из",
      "любой",
      "локальной",
      "время",
      "создания",
      "это",
      "содержит",
      "m;}",
      "существовала",
      "создании",
      "двух",
      "замыканий:",
      "каждого",
      "этих",
      "создается",
      "важно",
      "не",
      "запутаться",
      "параметрах",
      "определении",
      "замыкания:",
      "число",
      "передается",
      "параметра",
      "функции:",
      "также",
      "можем",
      "вариант",
      "вызова",
      "result",
      "multiply(5)(6);",
      "log(result);",
      "объектно-ориентированное",
      "программирование",
      "по",
      "сути",
      "явились",
      "предтечей",
      "объектно-ориентированного",
      "программирования",
      "использование",
      "некоторой",
      "степени",
      "позволяет",
      "имитировать",
      "создание",
      "объектов",
      "работу",
      "ними",
      "например",
      "следующий",
      "код:",
      "person(name",
      "age){",
      "log(\"person\"",
      "name",
      "\"created\");",
      "print(){",
      "log(\"person",
      "(\"",
      "+age",
      "+\")\");",
      "work(){",
      "works\");",
      "incrementage(value){",
      "age",
      "value;",
      "[print",
      "work",
      "incrementage];",
      "tom",
      "person(\"tom\"",
      "39);",
      "tom[0]();",
      "print",
      "tom[1]();",
      "tom[2](1);",
      "incrementage",
      "person",
      "принимает",
      "два",
      "вложенных",
      "образуют",
      "качестве",
      "окружения",
      "используют",
      "параметры",
      "выступает",
      "своего",
      "рода",
      "конструктором",
      "объекта",
      "условного",
      "человека",
      "принимают",
      "извне",
      "соответственно",
      "имя",
      "возраст",
      "могут",
      "обращаться",
      "своему",
      "лексическому",
      "окружению",
      "параметрам",
      "чтобы",
      "этим",
      "функциям",
      "можно",
      "было",
      "обратиться",
      "вложенные",
      "виде",
      "массива:",
      "вызвать",
      "передав",
      "нее",
      "получить",
      "результат",
      "человека:",
      "такое",
      "tom?",
      "возвращенный",
      "массив",
      "трех",
      "функций",
      "котоорые",
      "позволяют",
      "манипулировать",
      "человеком",
      "обратившись",
      "определенному",
      "элементу",
      "массиве",
      "соответствующую",
      "функцию:",
      "выражение",
      "tom[0]",
      "tom[0]()",
      "вызывает",
      "вывод",
      "консоли",
      "браузера",
      "следующим:",
      "created",
      "(39)",
      "works",
      "(40)",
      "javascript",
      "basic"
    ],
    "_tags": "api замыкание (closure) представляют собой конструкцию когда функция созданная одной области видимости запоминает свое лексическое окружение даже том случае она выполняет вне своей для организации замыкания необходимы три компонента: внешняя которая определяет некоторую область которой определены некоторые переменные (лексическое окружение) которые во внешней функции вложенная использует эти function outer(){ // let n; некоторая переменная return inner(){ действия переменной грубо говоря inner представляет данном которое запонимание лексического переменную рассмотрим на простейшем примере: 5; x++; console log(x); }; inner; const fn outer(); так как outer возвращает функцию вызываем внутреннюю fn(); здесь задает внутренняя самой инкрементируем выводим ее значение консоль конце далее outer: поскольку то константа будет хранить ссылку при этом эта запомнила есть внешнюю мы фактически раза видим что определена инкрементируется: несмотря может его использовать несомотря вызывается была суть замыканий причем каждой копии определяется своя копия окружения: определяем объект-пространство имен fn1 fn2 fn1(); fn2(); видно они манипулируют независимо друг от друга еще один пример: multiply(n){ function(m){ m;}; multiply(5); result1 fn1(6); 30 log(result1); fn2= multiply(4); result2 fn2(6); 24 log(result2); итак вызов multiply() приводит вызову другой внутренней же функция: котором создана частности итоге вызове multiply объединяет две вещи: состоит из любой локальной время создания это содержит m;} существовала создании двух замыканий: каждого этих создается важно не запутаться параметрах определении замыкания: число передается параметра функции: также можем вариант вызова result multiply(5)(6); log(result); объектно-ориентированное программирование по сути явились предтечей объектно-ориентированного программирования использование некоторой степени позволяет имитировать создание объектов работу ними например следующий код: person(name age){ log(\"person\" name \"created\"); print(){ log(\"person (\" +age +\")\"); work(){ works\"); incrementage(value){ age value; [print work incrementage]; tom person(\"tom\" 39); tom[0](); print tom[1](); tom[2](1); incrementage person принимает два вложенных образуют качестве окружения используют параметры выступает своего рода конструктором объекта условного человека принимают извне соответственно имя возраст могут обращаться своему лексическому окружению параметрам чтобы этим функциям можно было обратиться вложенные виде массива: вызвать передав нее получить результат человека: такое tom? возвращенный массив трех функций котоорые позволяют манипулировать человеком обратившись определенному элементу массиве соответствующую функцию: выражение tom[0] tom[0]() вызывает вывод консоли браузера следующим: created (39) works (40) javascript basic",
    "_version": 1
  },
  {
    "_id": "68fe6c5d0d20f72500044d20",
    "title": "Методы массивов",
    "content": "<pre><code>arr.push(...items) – добавляет элементы в конец,\narr.pop() – извлекает элемент из конца,\narr.shift() – извлекает элемент из начала,\narr.unshift(...items) – добавляет элементы в начало.</code></pre>\n<b>splice</b>\nМетод arr.splice – это универсальный «швейцарский нож» для работы с массивами. Умеет всё: добавлять, удалять и заменять элементы.\nСинтаксис:\n<pre><code>arr.splice(start[, deleteCount, elem1, ..., elemN])</code></pre>\nОн изменяет arr начиная с индекса start: удаляет deleteCount элементов и затем вставляет elem1, ..., elemN на их место. Возвращает массив из удалённых элементов.\nНачнём с удаления:\n<pre><code>let arr = [\"Я\", \"изучаю\", \"JavaScript\"];\narr.splice(1, 1); // начиная с индекса 1, удалить 1 элемент\nalert( arr ); // осталось [\"Я\", \"JavaScript\"]</code></pre>\nВ следующем примере мы удалим 3 элемента и заменим их двумя другими.\n<pre><code>let arr = [\"Я\", \"изучаю\", \"JavaScript\", \"прямо\", \"сейчас\"];\n// удалить 3 первых элемента и заменить их другими\narr.splice(0, 3, \"Давай\", \"танцевать\");\nalert( arr ) // теперь [\"Давай\", \"танцевать\", \"прямо\", \"сейчас\"]</code></pre>\nЗдесь видно, что splice возвращает массив из удалённых элементов:\n<pre><code>let arr = [\"Я\", \"изучаю\", \"JavaScript\", \"прямо\", \"сейчас\"];\n// удалить 2 первых элемента\nlet removed = arr.splice(0, 2);\nalert( removed ); // \"Я\", \"изучаю\" <-- массив из удалённых элементов</code></pre>\nМетод splice также может вставлять элементы без удаления, для этого достаточно установить deleteCount в 0:\n<pre><code>let arr = [\"Я\", \"изучаю\", \"JavaScript\"];\n// с индекса 2\n// удалить 0 элементов\n// вставить \"сложный\", \"язык\"\narr.splice(2, 0, \"сложный\", \"язык\");\nalert( arr ); // \"Я\", \"изучаю\", \"сложный\", \"язык\", \"JavaScript\"</code></pre>\nВ этом и в других методах массива допускается использование отрицательных индексов. Они определяют позицию с конца массива, как тут:\n<pre><code>let arr = [1, 2, 5];\n// начиная с индекса -1 (перед последним элементом)\n// удалить 0 элементов,\n// затем вставить числа 3 и 4\narr.splice(-1, 0, 3, 4);\nalert( arr ); // 1,2,3,4,5</code></pre>\n<b>slice</b>\nМетод arr.slice намного проще, чем похожий на него arr.splice.\nСинтаксис:\n<pre><code>arr.slice([start], [end])</code></pre>\nОн возвращает новый массив, в который копирует все элементы с индекса start до end (не включая end). start и end могут быть отрицательными, в этом случае отсчёт позиции будет вестись с конца массива.\nЭто похоже на строковый метод str.slice, но вместо подстрок возвращает подмассивы.\nНапример:\n<pre><code>let arr = [\"t\", \"e\", \"s\", \"t\"];\nalert( arr.slice(1, 3) ); // e,s (копирует с 1 до 3)\nalert( arr.slice(-2) ); // s,t (копирует с -2 до конца)</code></pre>\nМожно вызвать slice без аргументов: arr.slice() создаёт копию arr. Это часто используют, чтобы создать копию массива для дальнейших преобразований, которые не должны менять исходный массив.\n\n<b>concat</b>\nМетод arr.concat создаёт новый массив, в который копирует данные из других массивов и дополнительные значения.\nСинтаксис:\narr.concat(arg1, arg2...)\nОн принимает любое количество аргументов, которые могут быть как массивами, так и простыми значениями.\nВ результате – новый массив, включающий в себя элементы из arr, затем arg1, arg2 и так далее.\nЕсли аргумент argN – массив, то копируются все его элементы. Иначе копируется сам аргумент.\nНапример:\n<pre><code>let arr = [1, 2];\n// создать массив из: arr и [3,4]\nalert( arr.concat([3, 4]) ); // 1,2,3,4\n// создать массив из: arr и [3,4] и [5,6]\nalert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6\n// создать массив из: arr и [3,4], потом добавить значения 5 и 6\nalert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6</code></pre>\nОбычно он копирует только элементы из массивов. Другие объекты, даже если они выглядят как массивы, добавляются как есть:\n<pre><code>let arr = [1, 2];\nlet arrayLike = {\n  0: \"что-то\",\n  length: 1\n};\nalert( arr.concat(arrayLike) ); // 1,2,[object Object]</code></pre>\n…Но если массивоподобный объект имеет специальное свойство Symbol.isConcatSpreadable, то он обрабатывается как массив, с помощью concat: вместо него добавляются его элементы:\n<pre><code>let arr = [1, 2];\nlet arrayLike = {\n  0: \"что-то\",\n  1: \"ещё\",\n  [Symbol.isConcatSpreadable]: true,\n  length: 2\n};\nalert( arr.concat(arrayLike) ); // 1,2,что-то,ещё</code></pre>\n\n<b>Поиск в массиве</b>\n\nindexOf/lastIndexOf и includes\nУ методов arr.indexOf и arr.includes одинаковый синтаксис и они делают по сути то же самое, что и их строковые аналоги, но работают с элементами вместо символов:\n\narr.indexOf(item, from) ищет item начиная с индекса from и возвращает номер индекса, на котором был найден искомый элемент, в противном случае -1.\narr.includes(item, from) ищет item начиная с индекса from и возвращает true, если поиск успешен.\nОбычно эти методы используются только с одним аргументом: искомым item. По умолчанию поиск ведется с начала.\nНапример:\n<pre><code>let arr = [1, 0, false];\nalert( arr.indexOf(0) ); // 1\nalert( arr.indexOf(false) ); // 2\nalert( arr.indexOf(null) ); // -1\nalert( arr.includes(1) ); // true</code></pre>\nПожалуйста, обратите внимание, что методы используют строгое сравнение ===. Таким образом, если мы ищем false, он находит именно false, а не ноль.\nЕсли мы хотим проверить наличие элемента в массиве и нет необходимости знать его индекс, предпочтительно использовать arr.includes.\nМетод arr.lastIndexOf похож на indexOf, но ищет справа налево.\n<pre><code>let fruits = ['Яблоко', 'Апельсин', 'Яблоко']\nalert( fruits.indexOf('Яблоко') ); // 0 (первый 'Яблоко')\nalert( fruits.lastIndexOf('Яблоко') ); // 2 (последний 'Яблоко')\n</code></pre>\nМетод includes правильно обрабатывает NaN\nНезначительная, но заслуживающая внимания особенность includes – он правильно обрабатывает NaN, в отличие от indexOf:\n\n<pre><code>const arr = [NaN];\nalert( arr.indexOf(NaN) ); // -1 (неверно, должен быть 0)\nalert( arr.includes(NaN) );// true (верно)</code></pre>\nЭто связано с тем, что includes был добавлен в JavaScript гораздо позже и использует более современный алгоритм сравнения.\n<pre><code>find и findIndex/findLastIndex</code></pre>\nПредставьте, что у нас есть массив объектов. Как нам найти объект с определённым условием? Здесь пригодится метод arr.find.\nСинтаксис:\n<pre><code>let result = arr.find(function(item, index, array) {\n  // если true - возвращается текущий элемент и перебор прерывается\n  // если все итерации оказались ложными, возвращается undefined\n});</code></pre>\nФункция вызывается по очереди для каждого элемента массива:\nitem – очередной элемент.\nindex – его индекс.\narray – сам массив.\nЕсли функция возвращает true, поиск прерывается и возвращается item. Если ничего не найдено, возвращается undefined.\nНапример, у нас есть массив пользователей, каждый из которых имеет поля id и name. Найдем пользователя с id == 1:\n<pre><code>let users = [\n  {id: 1, name: \"Вася\"},\n  {id: 2, name: \"Петя\"},\n  {id: 3, name: \"Маша\"}\n];\nlet user = users.find(item => item.id == 1);\n\nalert(user.name); // Вася</code></pre>\nВ реальной жизни массивы объектов – обычное дело, поэтому метод find крайне полезен.\nОбратите внимание, что в данном примере мы передаём find функцию item => item.id == 1 с одним аргументом. Это типично, другие аргументы этой функции используются редко.\nУ метода arr.findIndex такой же синтаксис, но он возвращает индекс, на котором был найден элемент, а не сам элемент. Значение -1 возвращается, если ничего не найдено.\nМетод arr.findLastIndex похож на findIndex, но ищет справа налево, наподобие lastIndexOf.\nНапример:\n<pre><code>let users = [\n  {id: 1, name: \"Вася\"},\n  {id: 2, name: \"Петя\"},\n  {id: 3, name: \"Маша\"},\n  {id: 4, name: \"Вася\"}\n];\n// Найти индекс первого Васи\nalert(users.findIndex(user => user.name == 'Вася')); // 0\n// Найти индекс последнего Васи\nalert(users.findLastIndex(user => user.name == 'Вася')); // 3\n</code></pre>\n<b>Преобразование массива</b>\nПерейдём к методам преобразования и упорядочения массива.\n<b>map</b>\nМетод arr.map является одним из наиболее полезных и часто используемых.\nОн вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции.\nСинтаксис:\nlet result = arr.map(function(item, index, array) {\n  // возвращается новое значение вместо элемента\n});\nНапример, здесь мы преобразуем каждый элемент в его длину:\nlet lengths = [\"Бильбо\", \"Гэндальф\", \"Назгул\"].map(item => item.length);\nalert(lengths); // 6,8,6\n<b>reverse</b>\nМетод arr.reverse меняет порядок элементов в arr на обратный.\nНапример:\n<pre><code>let arr = [1, 2, 3, 4, 5];\narr.reverse();\nalert( arr ); // 5,4,3,2,1</code></pre>\nОн также возвращает массив arr с изменённым порядком элементов.\n<b>split и join</b>\nСитуация из реальной жизни. Мы пишем приложение для обмена сообщениями, и посетитель вводит имена тех, кому его отправить, через запятую: Вася, Петя, Маша. Но нам-то гораздо удобнее работать с массивом имён, чем с одной строкой. Как его получить?\nМетод str.split(delim) именно это и делает. Он разбивает строку на массив по заданному разделителю delim.\nВ примере ниже таким разделителем является строка из запятой и пробела.\n<pre><code>let names = 'Вася, Петя, Маша';\nlet arr = names.split(', ');\nfor (let name of arr) {\n  alert( `Сообщение получат: ${name}.` ); // Сообщение получат: Вася (и другие имена)\n}</code></pre>\nУ метода split есть необязательный второй числовой аргумент – ограничение на количество элементов в массиве. Если их больше, чем указано, то остаток массива будет отброшен. На практике это редко используется:\n<pre><code>let arr = 'Вася, Петя, Маша, Саша'.split(', ', 2);\nalert(arr); // Вася, Петя</code></pre>\nВызов arr.join(glue) делает в точности противоположное split. Он создаёт строку из элементов arr, вставляя glue между ними.\nНапример:\n<pre><code>let arr = ['Вася', 'Петя', 'Маша'];\nlet str = arr.join(';'); // объединить массив в строку через ;\nalert( str ); // Вася;Петя;Маша</code></pre>\n<b>reduce/reduceRight</b>\nКогда нам нужно перебрать массив – мы можем использовать forEach, for или for..of.\nКогда нам нужно перебрать массив и вернуть данные для каждого элемента – мы можем использовать map.\nМетоды arr.reduce и arr.reduceRight похожи на методы выше, но они немного сложнее. Они используются для вычисления единого значения на основе всего массива.\nСинтаксис:\n<pre><code>let value = arr.reduce(function(accumulator, item, index, array) {\n  // ...\n}, [initial]);</code></pre>\nФункция применяется по очереди ко всем элементам массива и «переносит» свой результат на следующий вызов.\nАргументы:\naccumulator – результат предыдущего вызова этой функции, равен initial при первом вызове (если передан initial),\nitem – очередной элемент массива,\nindex – его позиция,\narray – сам массив.\nПри вызове функции результат её предыдущего вызова передаётся на следующий вызов в качестве первого аргумента.\nТак, первый аргумент является по сути аккумулятором, который хранит объединённый результат всех предыдущих вызовов функции. По окончании он становится результатом reduce.\nЭтот метод проще всего понять на примере.\nТут мы получим сумму всех элементов массива одной строкой:\n<pre><code>let arr = [1, 2, 3, 4, 5];\nМы также можем опустить начальное значение:\n<pre><code>let arr = [1, 2, 3, 4, 5];\n// убрано начальное значение (нет 0 в конце)\nlet result = arr.reduce((sum, current) => sum + current);\nalert( result ); // 15</code></pre>\nНо такое использование требует крайней осторожности. Если массив пуст, то вызов reduce без начального значения выдаст ошибку.\nlet arr = [];\n<pre><code>// Error: Reduce of empty array with no initial value\n// если бы существовало начальное значение, reduce вернул бы его для пустого массива.\narr.reduce((sum, current) => sum + current);</code></pre>\nМетод arr.reduceRight работает аналогично, но проходит по массиву справа налево.\n<b>Array.isArray</b>\nМассивы не образуют отдельный тип данных. Они основаны на объектах.\nПоэтому typeof не может отличить простой объект от массива:\nalert(typeof {}); // object\nalert(typeof []); // тоже object\n…Но массивы используются настолько часто, что для этого придумали специальный метод: Array.isArray(value). Он возвращает true, если value массив, и false, если нет.\n<pre><code>alert(Array.isArray({})); // false\nalert(Array.isArray([])); // true</code></pre>",
    "group": "JavaScript",
    "subGroup": "JavaScript Basic",
    "ignoreHtml": false,
    "order": 3,
    "_created": "2025-10-26T18:45:49.580Z",
    "_changed": "2025-10-26T18:45:49.580Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "методы",
      "массивов",
      "arr",
      "push(",
      "items)",
      "добавляет",
      "элементы",
      "конец",
      "pop()",
      "извлекает",
      "элемент",
      "из",
      "конца",
      "shift()",
      "начала",
      "unshift(",
      "начало",
      "splice",
      "метод",
      "это",
      "универсальный",
      "«швейцарский",
      "нож»",
      "для",
      "работы",
      "массивами",
      "умеет",
      "всё:",
      "добавлять",
      "удалять",
      "заменять",
      "синтаксис:",
      "splice(start[",
      "deletecount",
      "elem1",
      "elemn])",
      "он",
      "изменяет",
      "начиная",
      "индекса",
      "start:",
      "удаляет",
      "элементов",
      "затем",
      "вставляет",
      "elemn",
      "на",
      "их",
      "место",
      "возвращает",
      "массив",
      "удалённых",
      "начнём",
      "удаления:",
      "let",
      "[\"я\"",
      "\"изучаю\"",
      "\"javascript\"];",
      "splice(1",
      "1);",
      "//",
      "удалить",
      "alert(",
      ");",
      "осталось",
      "\"javascript\"]",
      "следующем",
      "примере",
      "мы",
      "удалим",
      "элемента",
      "заменим",
      "двумя",
      "другими",
      "\"javascript\"",
      "\"прямо\"",
      "\"сейчас\"];",
      "первых",
      "заменить",
      "splice(0",
      "\"давай\"",
      "\"танцевать\");",
      "теперь",
      "[\"давай\"",
      "\"танцевать\"",
      "\"сейчас\"]",
      "здесь",
      "видно",
      "что",
      "элементов:",
      "removed",
      "2);",
      "\"я\"",
      "также",
      "может",
      "вставлять",
      "без",
      "удаления",
      "этого",
      "достаточно",
      "установить",
      "0:",
      "вставить",
      "\"сложный\"",
      "\"язык\"",
      "splice(2",
      "\"язык\");",
      "этом",
      "других",
      "методах",
      "массива",
      "допускается",
      "использование",
      "отрицательных",
      "индексов",
      "они",
      "определяют",
      "позицию",
      "как",
      "тут:",
      "[1",
      "5];",
      "-1",
      "(перед",
      "последним",
      "элементом)",
      "числа",
      "splice(-1",
      "4);",
      "slice",
      "намного",
      "проще",
      "чем",
      "похожий",
      "него",
      "slice([start]",
      "[end])",
      "новый",
      "который",
      "копирует",
      "все",
      "start",
      "до",
      "end",
      "(не",
      "включая",
      "end)",
      "могут",
      "быть",
      "отрицательными",
      "случае",
      "отсчёт",
      "позиции",
      "будет",
      "вестись",
      "похоже",
      "строковый",
      "str",
      "но",
      "вместо",
      "подстрок",
      "подмассивы",
      "например:",
      "[\"t\"",
      "\"e\"",
      "\"s\"",
      "\"t\"];",
      "slice(1",
      "3)",
      "(копирует",
      "slice(-2)",
      "-2",
      "конца)",
      "можно",
      "вызвать",
      "аргументов:",
      "slice()",
      "создаёт",
      "копию",
      "часто",
      "используют",
      "чтобы",
      "создать",
      "дальнейших",
      "преобразований",
      "которые",
      "не",
      "должны",
      "менять",
      "исходный",
      "concat",
      "данные",
      "дополнительные",
      "значения",
      "concat(arg1",
      "arg2",
      "принимает",
      "любое",
      "количество",
      "аргументов",
      "так",
      "простыми",
      "значениями",
      "результате",
      "включающий",
      "себя",
      "arg1",
      "далее",
      "если",
      "аргумент",
      "argn",
      "то",
      "копируются",
      "его",
      "иначе",
      "копируется",
      "сам",
      "2];",
      "из:",
      "[3",
      "4]",
      "concat([3",
      "4])",
      "[5",
      "6]",
      "6])",
      "потом",
      "добавить",
      "6)",
      "обычно",
      "только",
      "другие",
      "объекты",
      "даже",
      "выглядят",
      "массивы",
      "добавляются",
      "есть:",
      "arraylike",
      "\"что-то\"",
      "length:",
      "};",
      "concat(arraylike)",
      "[object",
      "object]",
      "…но",
      "массивоподобный",
      "объект",
      "имеет",
      "специальное",
      "свойство",
      "symbol",
      "isconcatspreadable",
      "обрабатывается",
      "помощью",
      "concat:",
      "элементы:",
      "1:",
      "\"ещё\"",
      "[symbol",
      "isconcatspreadable]:",
      "true",
      "что-то",
      "ещё",
      "поиск",
      "массиве",
      "indexof/lastindexof",
      "includes",
      "методов",
      "indexof",
      "одинаковый",
      "синтаксис",
      "делают",
      "по",
      "сути",
      "же",
      "самое",
      "строковые",
      "аналоги",
      "работают",
      "элементами",
      "символов:",
      "indexof(item",
      "from)",
      "ищет",
      "item",
      "from",
      "номер",
      "котором",
      "был",
      "найден",
      "искомый",
      "противном",
      "includes(item",
      "успешен",
      "эти",
      "используются",
      "одним",
      "аргументом:",
      "искомым",
      "умолчанию",
      "ведется",
      "false];",
      "indexof(0)",
      "indexof(false)",
      "indexof(null)",
      "includes(1)",
      "пожалуйста",
      "обратите",
      "внимание",
      "строгое",
      "сравнение",
      "===",
      "таким",
      "образом",
      "ищем",
      "false",
      "находит",
      "именно",
      "ноль",
      "хотим",
      "проверить",
      "наличие",
      "нет",
      "необходимости",
      "знать",
      "индекс",
      "предпочтительно",
      "использовать",
      "lastindexof",
      "похож",
      "справа",
      "налево",
      "fruits",
      "['яблоко'",
      "'апельсин'",
      "'яблоко']",
      "indexof('яблоко')",
      "(первый",
      "'яблоко')",
      "lastindexof('яблоко')",
      "(последний",
      "правильно",
      "обрабатывает",
      "nan",
      "незначительная",
      "заслуживающая",
      "внимания",
      "особенность",
      "отличие",
      "от",
      "indexof:",
      "const",
      "[nan];",
      "indexof(nan)",
      "(неверно",
      "должен",
      "0)",
      "includes(nan)",
      ");//",
      "(верно)",
      "связано",
      "тем",
      "добавлен",
      "javascript",
      "гораздо",
      "позже",
      "использует",
      "более",
      "современный",
      "алгоритм",
      "сравнения",
      "find",
      "findindex/findlastindex",
      "представьте",
      "нас",
      "есть",
      "объектов",
      "нам",
      "найти",
      "определённым",
      "условием?",
      "пригодится",
      "result",
      "find(function(item",
      "index",
      "array)",
      "возвращается",
      "текущий",
      "перебор",
      "прерывается",
      "итерации",
      "оказались",
      "ложными",
      "});",
      "функция",
      "вызывается",
      "очереди",
      "каждого",
      "массива:",
      "очередной",
      "array",
      "ничего",
      "найдено",
      "например",
      "пользователей",
      "каждый",
      "которых",
      "поля",
      "id",
      "name",
      "найдем",
      "пользователя",
      "==",
      "users",
      "{id:",
      "name:",
      "\"вася\"}",
      "\"петя\"}",
      "\"маша\"}",
      "];",
      "user",
      "find(item",
      "=>",
      "alert(user",
      "name);",
      "вася",
      "реальной",
      "жизни",
      "обычное",
      "дело",
      "поэтому",
      "крайне",
      "полезен",
      "данном",
      "передаём",
      "функцию",
      "аргументом",
      "типично",
      "аргументы",
      "этой",
      "функции",
      "редко",
      "метода",
      "findindex",
      "такой",
      "значение",
      "findlastindex",
      "наподобие",
      "первого",
      "васи",
      "alert(users",
      "findindex(user",
      "'вася'));",
      "последнего",
      "findlastindex(user",
      "преобразование",
      "перейдём",
      "методам",
      "преобразования",
      "упорядочения",
      "map",
      "является",
      "наиболее",
      "полезных",
      "используемых",
      "вызывает",
      "результатов",
      "выполнения",
      "map(function(item",
      "новое",
      "преобразуем",
      "длину:",
      "lengths",
      "[\"бильбо\"",
      "\"гэндальф\"",
      "\"назгул\"]",
      "map(item",
      "length);",
      "alert(lengths);",
      "reverse",
      "меняет",
      "порядок",
      "обратный",
      "reverse();",
      "изменённым",
      "порядком",
      "split",
      "join",
      "ситуация",
      "пишем",
      "приложение",
      "обмена",
      "сообщениями",
      "посетитель",
      "вводит",
      "имена",
      "тех",
      "кому",
      "отправить",
      "через",
      "запятую:",
      "петя",
      "маша",
      "нам-то",
      "удобнее",
      "работать",
      "массивом",
      "имён",
      "одной",
      "строкой",
      "получить?",
      "split(delim)",
      "делает",
      "разбивает",
      "строку",
      "заданному",
      "разделителю",
      "delim",
      "ниже",
      "разделителем",
      "строка",
      "запятой",
      "пробела",
      "names",
      "'вася",
      "маша';",
      "split('",
      "');",
      "for",
      "(let",
      "of",
      "arr)",
      "`сообщение",
      "получат:",
      "${name}",
      "сообщение",
      "(и",
      "имена)",
      "необязательный",
      "второй",
      "числовой",
      "ограничение",
      "больше",
      "указано",
      "остаток",
      "отброшен",
      "практике",
      "используется:",
      "саша'",
      "alert(arr);",
      "вызов",
      "join(glue)",
      "точности",
      "противоположное",
      "вставляя",
      "glue",
      "между",
      "ними",
      "['вася'",
      "'петя'",
      "'маша'];",
      "join(';');",
      "объединить",
      "вася;петя;маша",
      "reduce/reduceright",
      "когда",
      "нужно",
      "перебрать",
      "можем",
      "foreach",
      "или",
      "вернуть",
      "reduce",
      "reduceright",
      "похожи",
      "выше",
      "немного",
      "сложнее",
      "вычисления",
      "единого",
      "основе",
      "всего",
      "value",
      "reduce(function(accumulator",
      "[initial]);",
      "применяется",
      "ко",
      "всем",
      "элементам",
      "«переносит»",
      "свой",
      "результат",
      "следующий",
      "аргументы:",
      "accumulator",
      "предыдущего",
      "вызова",
      "равен",
      "initial",
      "при",
      "первом",
      "вызове",
      "(если",
      "передан",
      "initial)",
      "позиция",
      "её",
      "передаётся",
      "качестве",
      "аргумента",
      "первый",
      "аккумулятором",
      "хранит",
      "объединённый",
      "всех",
      "предыдущих",
      "вызовов",
      "окончании",
      "становится",
      "результатом",
      "этот",
      "понять",
      "тут",
      "получим",
      "сумму",
      "строкой:",
      "опустить",
      "начальное",
      "значение:",
      "убрано",
      "(нет",
      "конце)",
      "reduce((sum",
      "current)",
      "sum",
      "current);",
      "15",
      "такое",
      "требует",
      "крайней",
      "осторожности",
      "пуст",
      "начального",
      "выдаст",
      "ошибку",
      "[];",
      "error:",
      "empty",
      "with",
      "no",
      "бы",
      "существовало",
      "вернул",
      "пустого",
      "работает",
      "аналогично",
      "проходит",
      "массиву",
      "isarray",
      "образуют",
      "отдельный",
      "тип",
      "данных",
      "основаны",
      "объектах",
      "typeof",
      "отличить",
      "простой",
      "alert(typeof",
      "{});",
      "object",
      "[]);",
      "тоже",
      "настолько",
      "придумали",
      "специальный",
      "метод:",
      "isarray(value)",
      "alert(array",
      "isarray({}));",
      "isarray([]));",
      "basic"
    ],
    "_tags": "api методы массивов arr push( items) добавляет элементы конец pop() извлекает элемент из конца shift() начала unshift( начало splice метод это универсальный «швейцарский нож» для работы массивами умеет всё: добавлять удалять заменять синтаксис: splice(start[ deletecount elem1 elemn]) он изменяет начиная индекса start: удаляет элементов затем вставляет elemn на их место возвращает массив удалённых начнём удаления: let [\"я\" \"изучаю\" \"javascript\"]; splice(1 1); // удалить alert( ); осталось \"javascript\"] следующем примере мы удалим элемента заменим двумя другими \"javascript\" \"прямо\" \"сейчас\"]; первых заменить splice(0 \"давай\" \"танцевать\"); теперь [\"давай\" \"танцевать\" \"сейчас\"] здесь видно что элементов: removed 2); \"я\" также может вставлять без удаления этого достаточно установить 0: вставить \"сложный\" \"язык\" splice(2 \"язык\"); этом других методах массива допускается использование отрицательных индексов они определяют позицию как тут: [1 5]; -1 (перед последним элементом) числа splice(-1 4); slice намного проще чем похожий него slice([start] [end]) новый который копирует все start до end (не включая end) могут быть отрицательными случае отсчёт позиции будет вестись похоже строковый str но вместо подстрок подмассивы например: [\"t\" \"e\" \"s\" \"t\"]; slice(1 3) (копирует slice(-2) -2 конца) можно вызвать аргументов: slice() создаёт копию часто используют чтобы создать дальнейших преобразований которые не должны менять исходный concat данные дополнительные значения concat(arg1 arg2 принимает любое количество аргументов так простыми значениями результате включающий себя arg1 далее если аргумент argn то копируются его иначе копируется сам 2]; из: [3 4] concat([3 4]) [5 6] 6]) потом добавить 6) обычно только другие объекты даже выглядят массивы добавляются есть: arraylike \"что-то\" length: }; concat(arraylike) [object object] …но массивоподобный объект имеет специальное свойство symbol isconcatspreadable обрабатывается помощью concat: элементы: 1: \"ещё\" [symbol isconcatspreadable]: true что-то ещё поиск массиве indexof/lastindexof includes методов indexof одинаковый синтаксис делают по сути же самое строковые аналоги работают элементами символов: indexof(item from) ищет item from номер котором был найден искомый противном includes(item успешен эти используются одним аргументом: искомым умолчанию ведется false]; indexof(0) indexof(false) indexof(null) includes(1) пожалуйста обратите внимание строгое сравнение === таким образом ищем false находит именно ноль хотим проверить наличие нет необходимости знать индекс предпочтительно использовать lastindexof похож справа налево fruits ['яблоко' 'апельсин' 'яблоко'] indexof('яблоко') (первый 'яблоко') lastindexof('яблоко') (последний правильно обрабатывает nan незначительная заслуживающая внимания особенность отличие от indexof: const [nan]; indexof(nan) (неверно должен 0) includes(nan) );// (верно) связано тем добавлен javascript гораздо позже использует более современный алгоритм сравнения find findindex/findlastindex представьте нас есть объектов нам найти определённым условием? пригодится result find(function(item index array) возвращается текущий перебор прерывается итерации оказались ложными }); функция вызывается очереди каждого массива: очередной array ничего найдено например пользователей каждый которых поля id name найдем пользователя == users {id: name: \"вася\"} \"петя\"} \"маша\"} ]; user find(item => alert(user name); вася реальной жизни обычное дело поэтому крайне полезен данном передаём функцию аргументом типично аргументы этой функции редко метода findindex такой значение findlastindex наподобие первого васи alert(users findindex(user 'вася')); последнего findlastindex(user преобразование перейдём методам преобразования упорядочения map является наиболее полезных используемых вызывает результатов выполнения map(function(item новое преобразуем длину: lengths [\"бильбо\" \"гэндальф\" \"назгул\"] map(item length); alert(lengths); reverse меняет порядок обратный reverse(); изменённым порядком split join ситуация пишем приложение обмена сообщениями посетитель вводит имена тех кому отправить через запятую: петя маша нам-то удобнее работать массивом имён одной строкой получить? split(delim) делает разбивает строку заданному разделителю delim ниже разделителем строка запятой пробела names 'вася маша'; split(' '); for (let of arr) `сообщение получат: ${name} сообщение (и имена) необязательный второй числовой ограничение больше указано остаток отброшен практике используется: саша' alert(arr); вызов join(glue) точности противоположное вставляя glue между ними ['вася' 'петя' 'маша']; join(';'); объединить вася;петя;маша reduce/reduceright когда нужно перебрать можем foreach или вернуть reduce reduceright похожи выше немного сложнее вычисления единого основе всего value reduce(function(accumulator [initial]); применяется ко всем элементам «переносит» свой результат следующий аргументы: accumulator предыдущего вызова равен initial при первом вызове (если передан initial) позиция её передаётся качестве аргумента первый аккумулятором хранит объединённый всех предыдущих вызовов окончании становится результатом этот понять тут получим сумму строкой: опустить начальное значение: убрано (нет конце) reduce((sum current) sum current); 15 такое требует крайней осторожности пуст начального выдаст ошибку []; error: empty with no бы существовало вернул пустого работает аналогично проходит массиву isarray образуют отдельный тип данных основаны объектах typeof отличить простой alert(typeof {}); object []); тоже настолько придумали специальный метод: isarray(value) alert(array isarray({})); isarray([])); basic",
    "_version": 0
  },
  {
    "_id": "68ff90750d20f7250004618b",
    "title": "Git rebase и git merge",
    "content": "Git rebase и git merge — это два основных способа объединить изменения из одной ветки в другую.  Оба достигают схожей цели, но делают это по-разному, что приводит к разным историям коммитов.\nGit Merge\n•   Как работает: Merge берет изменения из целевой ветки (например, feature) и создает новый коммит слияния в текущей ветке (например, main). Этот коммит слияния явно указывает на то, что изменения из feature были интегрированы в main.\n•   История коммитов: История коммитов сохраняет информацию обо всех ветках и слияниях.  Вы увидите четкие ветки, которые отходят и сливаются обратно.\n\n•   Плюсы:\n    *   Простота и безопасность: Merge — это обычно более простой и безопасный вариант, особенно для начинающих.  Он не переписывает историю, поэтому проще восстановиться, если что-то пойдет не так.\n    *   Сохраняет контекст:  Сохраняет информацию о том, когда и как были объединены ветки, что может быть полезно для отслеживания истории изменений.\n    *   Легко отменить: Если что-то пойдет не так после слияния, относительно легко отменить коммит слияния и вернуться к предыдущему состоянию.\n\n•   Минусы:\n    *   Загроможденная история:  Со временем, если ветки сливаются часто, история коммитов может стать загроможденной коммитами слияния, что усложняет ее чтение и понимание.\n    *   Усложняет git bisect:  git bisect — это полезный инструмент для поиска коммита, вызвавшего регрессию.  Слияния могут усложнить этот процесс, так как они вводят дополнительные коммиты для анализа.\n\nGit Rebase\n•   Как работает: Rebase берет коммиты из текущей ветки (например, feature) и перемещает их так, чтобы они начинались с последнего коммита в целевой ветке (например, main).  Фактически, он переписывает историю текущей ветки.  Каждый коммит в ветке feature применяется поверх main как новый коммит.\n•   История коммитов:  История коммитов выглядит более линейной и чистой, как будто работа над веткой feature всегда велась поверх последней версии main.\n\n•   Плюсы:\n    *   Чистая история:  Rebase создает более чистую и линейную историю коммитов, что облегчает ее чтение и понимание.\n    *   Упрощает git bisect:  Линейная история упрощает использование git bisect для поиска проблем.\n    *   Более легкое отслеживание изменений:  Легче увидеть эволюцию изменений в проекте, так как нет коммитов слияния, загромождающих историю.\n\n•   Минусы:\n    *   Переписывает историю:  Rebase переписывает историю, что может быть опасным, особенно если ветка уже была опубликована и другие разработчики строят свою работу на ее основе.\n    *   Сложность при конфликтах:  Конфликты при rebase могут быть сложнее, чем при merge, особенно если их много.\n    *   Потеря информации:  Rebase удаляет информацию о ветвлении, что может быть нежелательным в некоторых случаях.\n\nКогда использовать Merge vs. Rebase\n\n•   Merge:\n    *   Когда важна история ветвления (например, для аудита или отслеживания фич).\n    *   Когда вы работаете в команде и хотите избежать проблем с переписыванием истории в общих ветках.\n    *   Когда безопасность важнее чистоты истории.\n\n•   Rebase:\n    *   Когда вы хотите поддерживать чистую и линейную историю коммитов (особенно в главной ветке).\n    *   Когда вы работаете в локальной ветке, которая еще не была опубликована.\n    *   Когда вы хотите упростить процесс git bisect.\n\nПравило золотого сечения:\n•   Никогда не переписывайте историю опубликованных коммитов.  Если вы работаете в ветке, которую другие разработчики уже используют (например, main или develop), не используйте rebase, если только вы не абсолютно уверены, что это не вызовет проблем.  В таких случаях безопаснее использовать merge.\n•   Rebase только свои локальные ветки.  Rebase можно использовать в локальных ветках, которые еще не были опубликованы, чтобы привести их в порядок перед слиянием в общую ветку. Rebase можно использовать в локальных ветках, которые еще не были опубликованы, чтобы привести их в порядок перед слиянием в общую ветку.\n\nПример:\nПредположим, у вас есть две ветки: main и feature.  Вы хотите объединить изменения из feature в main.\n\n•   **Merge:**\nЭто создаст новый коммит слияния в main, объединяющий изменения из feature. История коммитов будет выглядеть примерно так:\n  A -- B -- C -- D -- M (main)\n     \\    /\n      E -- F  (feature)\nГде M — коммит слияния.\n\n•  Rebase:\n    git checkout feature\n    git rebase main\n    git checkout main\n    git merge feature\nСначала выполняется rebase, перенося коммиты E и F на вершину ветки main. Затем выполняется merge, но поскольку ветка feature уже содержит все коммиты из main (благодаря rebase), это будет fast-forward merge (ветка main просто переместится на коммит F). История коммитов будет выглядеть примерно так:\n  A -- B -- C -- D -- E' -- F' (main, feature)\nГде E' и F' — это перенесенные версии коммитов E и F.\n\nВ заключение:\nОба git rebase и git merge являются важными инструментами в арсенале Git. Выбор между ними зависит от конкретной ситуации и от того, что вы больше цените: чистую историю или безопасность. Понимание их различий и правильное использование поможет вам эффективно управлять своим репозиторием и сотрудничать с другими разработчиками. Всегда будьте осторожны при использовании rebase, особенно в общих ветках.\n\n",
    "group": "Прочее",
    "subGroup": "Git",
    "ignoreHtml": false,
    "order": 1,
    "_created": "2025-10-27T15:32:05.122Z",
    "_changed": "2025-10-27T15:32:05.122Z",
    "_createdby": "api",
    "_changedby": "api",
    "_keywords": [
      "api",
      "git",
      "rebase",
      "merge",
      "это",
      "два",
      "основных",
      "способа",
      "объединить",
      "изменения",
      "из",
      "одной",
      "ветки",
      "другую",
      "оба",
      "достигают",
      "схожей",
      "цели",
      "но",
      "делают",
      "по-разному",
      "что",
      "приводит",
      "разным",
      "историям",
      "коммитов",
      "как",
      "работает:",
      "берет",
      "целевой",
      "(например",
      "feature)",
      "создает",
      "новый",
      "коммит",
      "слияния",
      "текущей",
      "ветке",
      "main)",
      "этот",
      "явно",
      "указывает",
      "на",
      "то",
      "feature",
      "были",
      "интегрированы",
      "main",
      "история",
      "коммитов:",
      "сохраняет",
      "информацию",
      "обо",
      "всех",
      "ветках",
      "слияниях",
      "вы",
      "увидите",
      "четкие",
      "которые",
      "отходят",
      "сливаются",
      "обратно",
      "плюсы:",
      "простота",
      "безопасность:",
      "обычно",
      "более",
      "простой",
      "безопасный",
      "вариант",
      "особенно",
      "для",
      "начинающих",
      "он",
      "не",
      "переписывает",
      "историю",
      "поэтому",
      "проще",
      "восстановиться",
      "если",
      "что-то",
      "пойдет",
      "так",
      "контекст:",
      "том",
      "когда",
      "объединены",
      "может",
      "быть",
      "полезно",
      "отслеживания",
      "истории",
      "изменений",
      "легко",
      "отменить:",
      "после",
      "относительно",
      "отменить",
      "вернуться",
      "предыдущему",
      "состоянию",
      "минусы:",
      "загроможденная",
      "история:",
      "со",
      "временем",
      "часто",
      "стать",
      "загроможденной",
      "коммитами",
      "усложняет",
      "ее",
      "чтение",
      "понимание",
      "bisect:",
      "bisect",
      "полезный",
      "инструмент",
      "поиска",
      "коммита",
      "вызвавшего",
      "регрессию",
      "могут",
      "усложнить",
      "процесс",
      "они",
      "вводят",
      "дополнительные",
      "коммиты",
      "анализа",
      "перемещает",
      "их",
      "чтобы",
      "начинались",
      "последнего",
      "фактически",
      "каждый",
      "применяется",
      "поверх",
      "выглядит",
      "линейной",
      "чистой",
      "будто",
      "работа",
      "над",
      "веткой",
      "всегда",
      "велась",
      "последней",
      "версии",
      "чистая",
      "чистую",
      "линейную",
      "облегчает",
      "упрощает",
      "линейная",
      "использование",
      "проблем",
      "легкое",
      "отслеживание",
      "изменений:",
      "легче",
      "увидеть",
      "эволюцию",
      "проекте",
      "нет",
      "загромождающих",
      "историю:",
      "опасным",
      "ветка",
      "уже",
      "была",
      "опубликована",
      "другие",
      "разработчики",
      "строят",
      "свою",
      "работу",
      "основе",
      "сложность",
      "при",
      "конфликтах:",
      "конфликты",
      "сложнее",
      "чем",
      "много",
      "потеря",
      "информации:",
      "удаляет",
      "ветвлении",
      "нежелательным",
      "некоторых",
      "случаях",
      "использовать",
      "vs",
      "merge:",
      "важна",
      "ветвления",
      "аудита",
      "или",
      "фич)",
      "работаете",
      "команде",
      "хотите",
      "избежать",
      "переписыванием",
      "общих",
      "безопасность",
      "важнее",
      "чистоты",
      "rebase:",
      "поддерживать",
      "(особенно",
      "главной",
      "ветке)",
      "локальной",
      "которая",
      "еще",
      "упростить",
      "правило",
      "золотого",
      "сечения:",
      "никогда",
      "переписывайте",
      "опубликованных",
      "которую",
      "используют",
      "develop)",
      "используйте",
      "только",
      "абсолютно",
      "уверены",
      "вызовет",
      "таких",
      "безопаснее",
      "свои",
      "локальные",
      "можно",
      "локальных",
      "опубликованы",
      "привести",
      "порядок",
      "перед",
      "слиянием",
      "общую",
      "ветку",
      "пример:",
      "предположим",
      "вас",
      "есть",
      "две",
      "ветки:",
      "**merge:**",
      "создаст",
      "объединяющий",
      "будет",
      "выглядеть",
      "примерно",
      "так:",
      "--",
      "(main)",
      "(feature)",
      "где",
      "checkout",
      "сначала",
      "выполняется",
      "перенося",
      "вершину",
      "затем",
      "поскольку",
      "содержит",
      "все",
      "(благодаря",
      "rebase)",
      "fast-forward",
      "(ветка",
      "просто",
      "переместится",
      "f)",
      "e'",
      "f'",
      "(main",
      "перенесенные",
      "заключение:",
      "являются",
      "важными",
      "инструментами",
      "арсенале",
      "выбор",
      "между",
      "ними",
      "зависит",
      "от",
      "конкретной",
      "ситуации",
      "того",
      "больше",
      "цените:",
      "различий",
      "правильное",
      "поможет",
      "вам",
      "эффективно",
      "управлять",
      "своим",
      "репозиторием",
      "сотрудничать",
      "другими",
      "разработчиками",
      "будьте",
      "осторожны",
      "использовании",
      "прочее"
    ],
    "_tags": "api git rebase merge это два основных способа объединить изменения из одной ветки другую оба достигают схожей цели но делают по-разному что приводит разным историям коммитов как работает: берет целевой (например feature) создает новый коммит слияния текущей ветке main) этот явно указывает на то feature были интегрированы main история коммитов: сохраняет информацию обо всех ветках слияниях вы увидите четкие которые отходят сливаются обратно плюсы: простота безопасность: обычно более простой безопасный вариант особенно для начинающих он не переписывает историю поэтому проще восстановиться если что-то пойдет так контекст: том когда объединены может быть полезно отслеживания истории изменений легко отменить: после относительно отменить вернуться предыдущему состоянию минусы: загроможденная история: со временем часто стать загроможденной коммитами усложняет ее чтение понимание bisect: bisect полезный инструмент поиска коммита вызвавшего регрессию могут усложнить процесс они вводят дополнительные коммиты анализа перемещает их чтобы начинались последнего фактически каждый применяется поверх выглядит линейной чистой будто работа над веткой всегда велась последней версии чистая чистую линейную облегчает упрощает линейная использование проблем легкое отслеживание изменений: легче увидеть эволюцию проекте нет загромождающих историю: опасным ветка уже была опубликована другие разработчики строят свою работу основе сложность при конфликтах: конфликты сложнее чем много потеря информации: удаляет ветвлении нежелательным некоторых случаях использовать vs merge: важна ветвления аудита или фич) работаете команде хотите избежать переписыванием общих безопасность важнее чистоты rebase: поддерживать (особенно главной ветке) локальной которая еще упростить правило золотого сечения: никогда переписывайте опубликованных которую используют develop) используйте только абсолютно уверены вызовет таких безопаснее свои локальные можно локальных опубликованы привести порядок перед слиянием общую ветку пример: предположим вас есть две ветки: **merge:** создаст объединяющий будет выглядеть примерно так: -- (main) (feature) где checkout сначала выполняется перенося вершину затем поскольку содержит все (благодаря rebase) fast-forward (ветка просто переместится f) e' f' (main перенесенные заключение: являются важными инструментами арсенале выбор между ними зависит от конкретной ситуации того больше цените: различий правильное поможет вам эффективно управлять своим репозиторием сотрудничать другими разработчиками будьте осторожны использовании прочее",
    "_version": 0
  }
]
